var Lt = Object.defineProperty;
var yt = (o) => {
  throw TypeError(o);
};
var St = (o, t, e) => t in o ? Lt(o, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : o[t] = e;
var r = (o, t, e) => St(o, typeof t != "symbol" ? t + "" : t, e), Tt = (o, t, e) => t.has(o) || yt("Cannot " + e);
var h = (o, t, e) => (Tt(o, t, "read from private field"), e ? e.call(o) : t.get(o)), wt = (o, t, e) => t.has(o) ? yt("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(o) : t.set(o, e);
const kt = {
  onDragStart: null,
  onDragging: null,
  onDragEnd: null
};
function Mt(o, t = {}) {
  t = {
    ...kt,
    ...t
  };
  const e = () => {
    const a = [...o.parentNode.children].indexOf(o);
    o.draggable = !0, o.ondragstart = (l) => {
      l.dataTransfer.effectAllowed = "move", l.dataTransfer.dropEffect = "move", l.dataTransfer.setData("text/plain", a.toString()), t.onDragStart && t.onDragStart(a);
    }, o.ondragover = (l) => (l.preventDefault(), !1), o.ondragenter = (l) => {
      l.preventDefault(), t.onDragging && t.onDragging(a);
    }, o.ondrop = (l) => {
      l.preventDefault(), l.dataTransfer.dropEffect = "move";
      const B = parseInt(l.dataTransfer.getData("text/plain"), 10);
      t.onDragEnd && t.onDragEnd(B, a);
    };
  }, i = () => {
    o.draggable = !1, o.ondragstart = null, o.ondragover = null, o.ondragenter = null, o.ondrop = null;
  };
  return e(), {
    /**
     * @param {DraggableOptions} _options
     */
    update(s) {
      t = {
        ...kt,
        ...s
      }, i(), e();
    },
    destroy: i
  };
}
var d;
class c {
  constructor() {
    /**
     * @type {any}
     */
    wt(this, d, {});
  }
  /**
   * @template {keyof T} K
   * @param {K} key
   * @param {((data: T[K]) => void|Promise<void>) | null} listener
   * @returns {() => void} clean up function
   */
  on(t, e) {
    if (typeof e != "function")
      throw `invalid event listener passed for "${t.toString()}" event!`;
    return h(this, d)[t] || (h(this, d)[t] = []), h(this, d)[t].push(e), () => {
      this.off(t, e);
    };
  }
  /**
   * @template {keyof T} K
   * @param {K} key
   * @param {((data: T[K]) => void|Promise<void>)} listener
   */
  off(t, e) {
    if (!h(this, d)[t])
      throw `no listeners found for ${t.toString()}, there is nothing to delete`;
    let i = !1, s = 0;
    for (const a of h(this, d)[t])
      a === e && (h(this, d)[t].splice(s, 1), i = !0), s++;
    if (!i)
      throw `listener not found for ${t.toString()}, there is nothing to delete`;
    return this;
  }
  /**
   * @template {keyof T} K
   * @param {K} key
   * @param {T[K]} data
   */
  dispatch(t, e) {
    if (e === void 0) throw "data is undefined!";
    if (h(this, d)[t])
      for (const i of h(this, d)[t])
        i(e);
    return this;
  }
}
d = new WeakMap();
function xt(o, t) {
  const e = document.createElement("div");
  e.classList.add("ripple"), e.style.position = "absolute", e.style.color = "inherit", e.style.borderRadius = "50%", e.style.pointerEvents = "none", e.style.width = "100px", e.style.height = "100px", e.style.marginTop = "-50px", e.style.marginLeft = "-50px", e.style.opacity = `${t.opacity}`, e.style.backgroundColor = t.color, e.style.transform = "scale(0) translate(0, 0)", e.style.transition = `transform ${t.spreadDuration} ${t.spreadTiming} 0s,opacity ${t.clearDuration} ${t.clearTiming} 0s`, o.currentTarget.appendChild(e);
  const i = o.currentTarget.getBoundingClientRect();
  t.centered ? (e.style.top = `${i.height / 2}px`, e.style.left = `${i.width / 2}px`) : (e.style.top = `${o.clientY - i.top}px`, e.style.left = `${o.clientX - i.left}px`);
  const s = Math.max(i.width, i.height) * 0.02;
  return e.style.transform = `scale(${s}) translate(0, 0)`, e;
}
function Ct(o) {
  o && (o.addEventListener("transitionend", (t) => {
    t.propertyName === "opacity" && o.remove();
  }), o.style.opacity = "0");
}
const Rt = {
  color: "var(--ui-ripple-color, currentColor)",
  opacity: "var(--ui-ripple-opacity, 0.2)",
  centered: !1,
  spreadDuration: ".4s",
  spreadTiming: "linear",
  clearDuration: "1s",
  clearTiming: "ease-in-out",
  useClick: !1
};
function u(o, t = {}) {
  t = { ...Rt, ...t };
  let e;
  const i = (a) => {
    e = xt(a, t);
  }, s = () => {
    Ct(e);
  };
  return o.classList.add("ripple-container"), o.style.overflow = "hidden", t.useClick === !0 ? o.addEventListener("click", (a) => {
    e = xt(a, t), Ct(e);
  }) : (o.addEventListener("pointerdown", i), o.addEventListener("pointerup", s), o.addEventListener("pointerleave", s)), () => {
    o.classList.remove("ripple-container"), o.removeEventListener("pointerdown", i), o.removeEventListener("pointerup", s), o.removeEventListener("pointerleave", s);
  };
}
function Ht() {
  return /(android)/i.test(navigator.userAgent);
}
const n = String.raw, X = String.raw;
class Et {
  constructor() {
    this.callbacks = [];
  }
  /**
   * @param {(() => void|Promise<void>)[]} cb
   */
  add(...t) {
    this.callbacks.push(...t);
  }
  run() {
    for (let t = 0; t < this.callbacks.length; t++)
      if (this.callbacks[t] !== null)
        try {
          this.callbacks[t](), this.callbacks[t] = null;
        } catch (e) {
          console.error("cleanup error:", e);
        }
    this.callbacks = this.callbacks.filter((t) => t !== null);
  }
}
const $t = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CleanUp: Et,
  Events: c,
  createDraggable: Mt,
  createRipple: u,
  css: X,
  defaultRippleOptions: Rt,
  html: n,
  isAndroid: Ht
}, Symbol.toStringTag, { value: "Module" })), H = class H extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.ui = {
      root: this,
      get leftSlot() {
        return [...this.root.querySelectorAll('[slot="left"]')];
      },
      get centerSlot() {
        return [...this.root.querySelectorAll('[slot="center"]')];
      },
      get rightSlot() {
        return [...this.root.querySelectorAll('[slot="right"]')];
      },
      get position() {
        return this.root.getAttribute("position");
      },
      set position(t) {
        if (!t) {
          this.root.removeAttribute("position");
          return;
        }
        this.root.setAttribute("position", t);
      }
    }, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        * {
          box-sizing: border-box;
        }

        :host {
          display: flex !important;
          position: absolute !important;
          z-index: 100;
          background-color: var(--ui-backdrop-bgColor);
          -webkit-backdrop-filter: var(--ui-backdropFilter);
          backdrop-filter: var(--ui-backdropFilter);
          overflow: hidden;
          user-select: none;
        }

        :host([position="top"]) {
          top: 0;
          left: 0;
          right: 0;
          height: var(--ui-app-bar-height);
          border-bottom: 1px solid var(--ui-borderColor);
          padding-left: var(--ui-spacing);
          padding-right: var(--ui-spacing);
        }

        :host > ui-flex-grid-row {
          width: 100%;
          height: 100%;
          align-items: center;
          justify-content: space-between;
        }

        :host > ui-flex-grid-row > * {
          height: 100%;
        }

        :host > ui-flex-grid-row > *:nth-child(1),
        :host > ui-flex-grid-row > *:nth-child(3) {
          width: fit-content;
        }

        :host > ui-flex-grid-row > [slot="left"] {
          margin-left: 0 !important;
        }

        :host > ui-flex-grid-row > [slot="center"] {
          width: 100%;
        }

        :host > ui-flex-grid-row > [slot="right"] {
          margin-right: 0 !important;
          justify-content: flex-end;
        }
      </style>

      <ui-flex-grid-row gap="0.25rem">
        <ui-flex-grid-row gap="0.25rem">
          <slot name="left"></slot>
        </ui-flex-grid-row>

        <ui-flex-grid-row gap="0.25rem" style="overflow: hidden;">
          <slot name="center"></slot>
        </ui-flex-grid-row>

        <ui-flex-grid-row gap="0.25rem">
          <slot name="right"></slot>
        </ui-flex-grid-row>
      </ui-flex-grid-row>
    `;
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
};
r(H, "register", () => {
  customElements.get("ui-app-bar") || customElements.define("ui-app-bar", H);
});
let K = H;
const q = class q extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.ui = {
      root: this,
      /**
       * @returns {T}
       */
      get child() {
        return this.root.querySelector("*");
      },
      /**
       * @param {string | null} [value]
       */
      show(t = null) {
        this.root.style.display = t;
      },
      hide() {
        this.root.style.display = "none";
      }
    }, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        * {
          box-sizing: border-box;
        }

        :host {
          display: flex;
          align-items: center;
          justify-content: center;
          flex: 1;
        }
      </style>

      <slot></slot>
    `;
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
};
r(q, "register", () => {
  customElements.get("ui-app-bar-item") || customElements.define("ui-app-bar-item", q);
});
let Q = q;
const g = class g extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.removeRippleCallback = null, this.ui = {
      root: this,
      /**
       * @type {Events<UIButtonEvents>}
       */
      events: new c(),
      get noripple() {
        return !this.root.removeRippleCallback;
      },
      set noripple(t) {
        if (!t) {
          if (this.root.removeRippleCallback) return;
          this.root.removeRippleCallback = u(this.root);
        }
        this.root.removeRippleCallback && (this.root.removeRippleCallback(), this.root.removeRippleCallback = null);
      },
      get color() {
        return this.root.getAttribute("color");
      },
      set color(t) {
        if (!t) {
          this.root.removeAttribute("color");
          return;
        }
        this.root.setAttribute("color", t);
      },
      get variant() {
        return this.root.getAttribute("variant");
      },
      set variant(t) {
        if (!t) {
          this.root.removeAttribute("variant");
          return;
        }
        this.root.setAttribute("variant", t);
      },
      get disabled() {
        return this.root.hasAttribute("disabled");
      },
      set disabled(t) {
        if (!t) {
          this.root.removeAttribute("disabled");
          return;
        }
        this.root.setAttribute("disabled", "");
      }
    }, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        * {
          box-sizing: border-box;
        }

        :host {
          display: flex;
          align-items: center;
          justify-content: center;
          position: relative !important;
          padding: var(--ui-spacing) calc(var(--ui-spacing) * 2.5);
          border: 1px solid currentColor;
          border-radius: var(--ui-radius);
          overflow: hidden;
          text-transform: capitalize;
          cursor: pointer;
          outline: none;
          user-select: none;
          font-size: 1.1rem;
          font-weight: 450;
          font-family: var(--ui-fontFamily);
          font-variation-settings: var(--ui-button-fontVariation);
        }

        :host([variant="full"]) {
          border: none;
        }

        :host([variant="full"][color="primary"]) {
          background-color: var(--ui-primary-bgColor);
          color: var(--ui-primary-color);
        }

        :host([variant="full"][color="secondary"]) {
          background-color: var(--ui-secondary-bgColor);
          color: var(--ui-secondary-color);
        }

        :host([variant="full"][color="destructive"]) {
          background-color: var(--ui-destructive-bgColor);
          color: var(--ui-destructive-color);
        }

        :host([variant="outline"]) {
          border-color: currentColor;
          background-color: transparent;
        }

        :host([variant="outline"][color="primary"]) {
          color: var(--ui-primary-bgColor);
        }

        :host([variant="outline"][color="secondary"]) {
          color: var(--ui-secondary-bgColor);
        }

        :host([variant="outline"][color="destructive"]) {
          color: var(--ui-destructive-bgColor);
        }

        :host([variant="ghost"]) {
          border-color: transparent;
          background-color: transparent;
          font-weight: 900;
        }

        :host([variant="ghost"][color="primary"]) {
          color: var(--ui-primary-bgColor);
        }

        :host([variant="ghost"][color="secondary"]) {
          color: var(--ui-secondary-bgColor);
        }

        :host([variant="ghost"][color="destructive"]) {
          color: var(--ui-destructive-bgColor);
        }

        :host([disabled]),
        :host([disabled]:hover),
        :host([disabled]:active) {
          background-color: transparent;
          opacity: 0.25;
          cursor: default;
          pointer-events: none;
        }
      </style>

      <slot></slot>
    `, typeof this.removeRippleCallback != "function" && (this.removeRippleCallback = u(this)), this.addEventListener("click", () => {
      this.ui.events.dispatch("click", this);
    });
  }
  connectedCallback() {
    this.setAttribute("role", "button");
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "noripple":
        this.ui.noripple = i !== null;
        break;
    }
  }
};
r(g, "register", () => {
  customElements.get("ui-button") || customElements.define("ui-button", g);
}), r(g, "observedAttributes", ["noripple"]);
let W = g;
const b = class b extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.removeRippleCallback = null, this.ui = {
      root: this,
      /**
       * @type {Events<UIIconButtonEvents>}
       */
      events: new c(),
      get noripple() {
        return !this.root.removeRippleCallback;
      },
      set noripple(t) {
        if (!t) {
          if (this.root.removeRippleCallback) return;
          this.root.removeRippleCallback = u(this.root);
        }
        this.root.removeRippleCallback && (this.root.removeRippleCallback(), this.root.removeRippleCallback = null);
      },
      get color() {
        return this.root.getAttribute("color");
      },
      set color(t) {
        if (!t) {
          this.root.removeAttribute("color");
          return;
        }
        this.root.setAttribute("color", t);
      },
      get ghost() {
        return this.root.hasAttribute("ghost");
      },
      set ghost(t) {
        if (!t) {
          this.root.removeAttribute("ghost");
          return;
        }
        this.root.setAttribute("ghost", "");
      },
      get disabled() {
        return this.root.hasAttribute("disabled");
      },
      set disabled(t) {
        if (!t) {
          this.root.removeAttribute("disabled");
          return;
        }
        this.root.setAttribute("disabled", "");
      }
    }, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        * {
          box-sizing: border-box;
        }

        :host {
          display: block;
          position: relative;
          width: 2.5rem;
          height: 2.5rem;
          padding: calc(var(--ui-spacing) / 2);
          border: 1px solid currentColor;
          border-radius: var(--ui-radius);
          outline: none;
          overflow: hidden;
          cursor: pointer;
          user-select: none;
          font-size: 1.1rem;
          font-weight: 450;
          font-family: var(--ui-fontFamily);
          font-variation-settings: var(--ui-button-fontVariation);
          transition: color 0.5s linear;
        }

        :host([ghost]) {
          border-color: transparent !important;
          box-shadow: none;
          font-weight: 900;
        }

        :host([color="primary"]) {
          color: var(--ui-primary-bgColor);
          border-color: var(--ui-primary-bgColor);
        }

        :host([color="secondary"]) {
          color: var(--ui-secondary-bgColor);
          border-color: var(--ui-secondary-bgColor);
        }

        :host([color="destructive"]) {
          color: var(--ui-destructive-bgColor);
          border-color: var(--ui-destructive-bgColor);
        }

        /* :disabled */

        :host([disabled]),
        :host([disabled]:hover),
        :host([disabled]:active) {
          opacity: 0.25;
          cursor: default;
          pointer-events: none;
        }

        ui-svg {
          display: flex;
          align-items: center;
          justify-content: center;
        }
      </style>

      <ui-svg>
        <slot></slot>
      </ui-svg>
    `, typeof this.removeRippleCallback != "function" && (this.removeRippleCallback = u(this, { centered: !0 })), this.addEventListener("click", () => {
      this.ui.events.dispatch("click", this);
    });
  }
  connectedCallback() {
    this.setAttribute("role", "button");
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "noripple":
        this.ui.noripple = i !== null;
        break;
    }
  }
};
r(b, "register", () => {
  customElements.get("ui-icon-button") || customElements.define("ui-icon-button", b);
}), r(b, "observedAttributes", ["noripple"]);
let N = b;
const z = class z extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.ui = {}, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        * {
          box-sizing: border-box;
        }

        :host {
          display: block;
          width: 100%;
          max-width: 65rem;
          margin: 0 auto !important;
          padding: var(--ui-spacing);
        }
      </style>

      <slot></slot>
    `;
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
};
r(z, "register", () => {
  customElements.get("ui-container") || customElements.define("ui-container", z);
});
let G = z;
const qt = n`
  <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
    <g
      id="SVGRepo_tracerCarrier"
      stroke-linecap="round"
      stroke-linejoin="round"
    ></g>
    <g id="SVGRepo_iconCarrier">
      <rect width="24" height="24" fill="none"></rect>
      <path
        d="M7 17L16.8995 7.10051"
        stroke="currentColor"
        stroke-linecap="round"
        stroke-linejoin="round"
      ></path>
      <path
        d="M7 7.00001L16.8995 16.8995"
        stroke="currentColor"
        stroke-linecap="round"
        stroke-linejoin="round"
      ></path>
    </g>
  </svg>
`, m = class m extends HTMLElement {
  /**
   * @param {string} title
   */
  constructor(t) {
    super(), this.attachShadow({ mode: "open" }), this.shadowRenderCleanUp = new Et(), this._title = t || "", this.ui = {
      root: this,
      /** @type {Events<T>} */
      events: new c(),
      get title() {
        return this.root.shadowRoot.querySelector('[name="title"]').innerHTML;
      },
      set title(e) {
        const i = this.root.shadowRoot.querySelector('[name="title"]');
        this.root._title = i.innerHTML = e || "";
      },
      get fullscreen() {
        return this.root.hasAttribute("fullscreen");
      },
      set fullscreen(e) {
        if (!e) {
          this.root.removeAttribute("fullscreen");
          return;
        }
        this.root.setAttribute("fullscreen", "");
      },
      /**
       * @param {boolean} modal
       * @param {boolean} [inert] - This will prevent the autofocus on input elements (default: true)
       */
      open(e = !1, i = !0) {
        const s = this.root.shadowRoot.querySelector("dialog"), a = s.inert;
        s.inert = i, e ? s.showModal() : s.show(), this.events.dispatch("open", null), s.inert = a;
      },
      close() {
        this.events.dispatch("close", null), this.root.shadowRoot.querySelector("dialog").close();
      }
    }, this.shadowRender();
  }
  shadowRender() {
    this.shadowRenderCleanUp.run(), this.shadowRoot.innerHTML = n`
      <style>
        * {
          box-sizing: border-box;
        }

        :host dialog * {
          box-sizing: border-box;
        }

        dialog {
          position: fixed !important;

          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);

          max-width: 100%;
          max-height: 100%;

          margin: 0;
          padding: 0;

          border: none;
          outline: none;

          background-color: transparent;

          -ms-overflow-style: none;
          scrollbar-width: none;

          z-index: 999;
        }

        dialog::-webkit-scrollbar {
          display: none;
        }

        dialog::backdrop {
          background-color: var(--ui-backdrop-bgColor);
          backdrop-filter: var(--ui-backdropFilter);
        }

        dialog > .container {
          background-color: var(--ui-bgColor);
          color: var(--ui-color);

          border: 1px solid var(--ui-borderColor);
          border-radius: var(--ui-radius);

          padding: var(--ui-spacing);

          display: flex;
          flex-direction: column;
          justify-content: space-between;

          position: relative;
        }

        :host([fullscreen]) dialog {
          width: 100%;
          height: 100%;
        }

        :host([fullscreen]) dialog > .container {
          width: calc(100% - var(--ui-spacing) * 2);
          height: calc(
            100% -
              (
                env(safe-area-inset-top, 0) + env(safe-area-inset-bottom, 0) +
                  (var(--ui-spacing) * 2)
              )
          );

          margin: var(--ui-spacing);
          margin-top: calc(env(safe-area-inset-top, 0) + var(--ui-spacing));
          margin-bottom: calc(
            env(safe-area-inset-bottom, 0) + var(--ui-spacing)
          );
        }

        /*
         * Header Styles
         */

        .header {
          display: flex;
          align-items: center;
          justify-content: space-between;

          border-top-right-radius: var(--ui-radius);
          border-top-left-radius: var(--ui-radius);

          width: 100%;
          height: var(--ui-dialog-header-height);
        }

        .header h4 {
          margin: auto 0;
        }

        :host([fullscreen]) .header {
          z-index: 15;
          position: absolute;
          top: var(--ui-spacing);
          right: var(--ui-spacing);
          left: var(--ui-spacing);
          width: calc(100% - var(--ui-spacing) * 2);
        }

        /*
         * Content Styles
         */

        .content {
          padding: var(--ui-spacing);
          height: fit-content;
          min-width: fit-content;
          width: 100%;
        }

        :host([fullscreen]) .content {
          z-index: 10;
          position: absolute;
          top: calc(var(--ui-dialog-header-height) + var(--ui-spacing));
          bottom: calc(var(--ui-dialog-footer-height) + var(--ui-spacing));
          right: var(--ui-spacing);
          left: var(--ui-spacing);
          padding: unset;
          height: unset;
          width: unset;
          min-width: unset;
        }

        /*
         * Footer Styles
         */

        .footer {
          margin-top: var(--ui-spacing);
          border-bottom-right-radius: var(--ui-radius);
          border-bottom-left-radius: var(--ui-radius);

          width: 100%;
          height: var(--ui-dialog-footer-height);
        }

        :host([fullscreen]) .footer {
          z-index: 15;
          position: absolute;
          right: var(--ui-spacing);
          bottom: var(--ui-spacing);
          left: var(--ui-spacing);
          width: calc(100% - var(--ui-spacing) * 2);
        }

        .footer ui-flex-grid-row {
          height: 100%;
          flex-wrap: nowrap;
          justify-content: flex-end;
          align-items: center;
        }
      </style>

      <dialog>
        <div class="container">
          <div class="header">
            <span style="white-space: nowrap;">
              <h3 name="title"></h3>
            </span>

            <ui-icon-button
              style="width: var(--ui-dialog-header-height); height: 100%;"
              ghost
            >
              ${qt}
            </ui-icon-button>
          </div>

          <div class="content">
            <slot></slot>
          </div>

          <div class="footer">
            <ui-flex-grid-row gap="calc(var(--ui-spacing) / 2)">
              <slot name="actions"></slot>
            </ui-flex-grid-row>
          </div>
        </div>
      </dialog>
    `, this.ui.title = this._title;
    const t = this.shadowRoot.querySelector(".header ui-icon-button"), e = () => this.ui.close();
    t.addEventListener("click", e);
    const i = this.shadowRoot.querySelector("dialog"), s = (a) => a.preventDefault();
    i.addEventListener("cancel", s), this.shadowRenderCleanUp.add(() => {
      t.removeEventListener("click", e), i.removeEventListener("cancel", s);
    });
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "title":
        this.ui.title = i;
        break;
    }
  }
};
r(m, "register", () => {
  customElements.get("ui-dialog") || customElements.define("ui-dialog", m);
}), r(m, "observedAttributes", ["title"]);
let _ = m;
const j = class j extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.ui = {
      root: this,
      /**
       * @type {Events<UIDrawerEvents>}
       */
      events: new c(),
      get open() {
        return this.root.hasAttribute("open");
      },
      set open(t) {
        if (!t) {
          this.root.removeAttribute("open"), this.events.dispatch("close", this.root);
          return;
        }
        this.root.setAttribute("open", ""), this.events.dispatch("open", this.root);
      }
    }, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        * {
          box-sizing: border-box;
        }

        :host {
          display: block;

          position: absolute !important;
          z-index: 150;
          top: 0;
          left: -100%;
          width: 100%;
          height: 100%;

          overflow: hidden;

          transition: left 0s ease 0.5s;
        }

        :host([open]) {
          background-color: var(--ui-backdrop-bgColor);
          -webkit-backdrop-filter: var(--ui-backdropFilter);
          backdrop-filter: var(--ui-backdropFilter);

          left: 0;

          transition: none;
        }

        aside {
          position: absolute;
          z-index: 150;
          top: 0;
          left: -100%;
          width: var(--ui-drawer-width, fit-content);
          max-width: 100%;
          height: 100%;

          overflow-x: hidden;
          overflow-y: auto;
          scroll-behavior: smooth;

          -ms-overflow-style: none;
          scrollbar-width: none;

          background-color: var(--ui-card-bgColor);
          color: var(--ui-card-color);

          /*
                    background-color: var(--ui-backdrop-bgColor);
                    -webkit-backdrop-filter: var(--ui-backdropFilter);
                    backdrop-filter: var(--ui-backdropFilter);
                    */

          border-right: 1px solid var(--ui-card-borderColor);

          transition: left 0.5s ease;
        }

        aside::-webkit-scrollbar {
          display: none;
        }

        :host([open]) aside {
          left: 0;
        }
      </style>

      <aside>
        <slot></slot>
      </aside>
    `, this.shadowRoot.querySelector("aside").addEventListener("click", (t) => t.stopPropagation()), this.addEventListener("click", () => this.ui.open = !1);
  }
  connectedCallback() {
    this.setAttribute("role", "button");
  }
  disconnectedCallback() {
  }
};
r(j, "register", () => {
  customElements.get("ui-drawer") || customElements.define("ui-drawer", j);
});
let U = j;
const At = n`
  <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
    <g
      id="SVGRepo_tracerCarrier"
      stroke-linecap="round"
      stroke-linejoin="round"
    ></g>
    <g id="SVGRepo_iconCarrier">
      <rect width="24" height="24" fill="none"></rect>
      <path
        d="M17 9.5L12 14.5L7 9.5"
        stroke="currentColor"
        stroke-linecap="round"
        stroke-linejoin="round"
      ></path>
    </g>
  </svg>
`, f = class f extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.ui = {
      root: this,
      get title() {
        return this.root.shadowRoot.querySelector(".title").innerHTML;
      },
      set title(t) {
        let e = this.root.shadowRoot.querySelector(".title");
        if (!t) {
          e.classList.remove("visible");
          return;
        }
        e.classList.add("visible"), e.innerHTML = n`
          <span
            style="
              font-size: 1.5rem;
              font-weight: 600;
              font-variation-settings: var(--ui-heading-fontVariation);
            "
          >
            ${t}
          </span>
        `;
      },
      get fold() {
        return this.root.hasAttribute("fold");
      },
      set fold(t) {
        if (!t) {
          this.root.removeAttribute("fold");
          return;
        }
        this.root.setAttribute("fold", "");
      }
    }, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        * {
          box-sizing: border-box;
        }

        ul {
          list-style: none;
          padding: var(--ui-spacing);
          overflow: hidden;
          border-bottom: 1px solid var(--ui-borderColor);
        }

        ui-drawer-group-item {
          display: flex;
          cursor: pointer;
        }

        .title:not(.visible) {
          display: none;
        }

        .icon {
          transition: transform 0.25s ease;
        }

        :host([fold]) .icon {
          transform: rotate(-90deg);
        }

        :host([fold]) ::slotted(*) {
          display: none !important;
        }
      </style>

      <ul>
        <ui-drawer-group-item
          style="position: relative; border-radius: var(--ui-radius);"
          role="button"
        >
          <ui-flex-grid-row>
            <ui-flex-grid-item class="title"></ui-flex-grid-item>

            <ui-flex-grid-item class="icon" flex="0">
              <ui-svg style="width: 2.5rem; height: 2.5rem;">
                ${At}
              </ui-svg>
            </ui-flex-grid-item>
          </ui-flex-grid-row>
        </ui-drawer-group-item>

        <slot></slot>
      </ul>
    `;
    const t = this.shadowRoot.querySelector("ui-drawer-group-item");
    t.addEventListener("click", () => {
      this.ui.fold = !this.ui.fold;
    }), u(t);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "title":
        this.ui.title = i;
        break;
    }
  }
};
r(f, "register", () => {
  customElements.get("ui-drawer-group") || customElements.define("ui-drawer-group", f);
}), r(f, "observedAttributes", ["title"]);
let I = f;
const $ = class $ extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.ui = {}, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        * {
          box-sizing: border-box;
        }

        :host {
          display: block;
          width: 100%;
        }

        li {
          padding: var(--ui-spacing) calc(var(--ui-spacing) * 1.5);
          display: flex;
          flex-direction: row;
          flex-wrap: nowrap;
          width: 100%;
        }

        ::slotted(*) {
          width: 100%;
        }
      </style>

      <li>
        <slot></slot>
      </li>
    `;
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
};
r($, "register", () => {
  customElements.get("ui-drawer-group-item") || customElements.define("ui-drawer-group-item", $);
});
let tt = $;
const v = class v extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.flex = "1", this.ui = {
      root: this,
      get flex() {
        return this.root.flex;
      },
      set flex(t) {
        this.root.flex = t || "1";
        const e = this.root.shadowRoot.querySelector('style[name="flex"]');
        e.textContent = X`
          :host {
            flex: ${this.root.flex};
          }
        `;
      }
    }, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        * {
          box-sizing: border-box;
        }

        :host {
          display: block;
        }
      </style>

      <style name="flex">
        :host {
          flex: 1;
        }
      </style>

      <slot></slot>
    `;
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "flex":
        this.ui.flex = i;
        break;
    }
  }
};
r(v, "register", () => {
  customElements.get("ui-flex-grid-item") || customElements.define("ui-flex-grid-item", v);
}), r(v, "observedAttributes", ["flex"]);
let et = v;
const y = class y extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.gap = "0", this.ui = {
      root: this,
      get gap() {
        return this.root.gap;
      },
      set gap(t) {
        this.root.gap = t || "0";
        const e = this.root.shadowRoot.querySelector('style[name="gap"]');
        e.textContent = X`
          :host > ::slotted(*) {
            margin: 0 ${this.root.gap} !important;
          }
        `;
      },
      get justify() {
        return this.root.style.justifyContent;
      },
      set justify(t) {
        this.root.style.justifyContent = t;
      },
      get align() {
        return this.root.style.alignItems;
      },
      set align(t) {
        this.root.style.alignItems = t;
      }
    }, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        * {
          box-sizing: border-box;
        }

        :host {
          display: flex !important;
          flex-flow: row nowrap;
          position: relative !important;
          width: 100%;
        }
      </style>

      <style name="gap">
        :host > ::slotted(*) {
          margin: 0 0 !important;
        }
      </style>

      <style>
        :host > ::slotted(*:first-child) {
          margin-left: 0 !important;
        }

        :host > ::slotted(*:last-child) {
          margin-right: 0 !important;
        }
      </style>

      <slot></slot>
    `;
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "gap":
        this.ui.gap = i;
        break;
      case "justify":
        this.ui.justify = i;
        break;
      case "align":
        this.ui.align = i;
        break;
    }
  }
};
r(y, "register", () => {
  customElements.get("ui-flex-grid-row") || customElements.define("ui-flex-grid-row", y);
}), r(y, "observedAttributes", ["gap", "justify", "align"]);
let it = y;
const w = class w extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.gap = "0", this.ui = {
      root: this,
      get gap() {
        return this.root.gap;
      },
      set gap(t) {
        this.root.gap = t || "0";
        const e = this.root.shadowRoot.querySelector('style[name="gap"]');
        e.textContent = X`
          :host > ::slotted(*) {
            margin: ${this.root.gap} 0 !important;
          }
        `;
      }
    }, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        * {
          box-sizing: border-box;
        }

        :host {
          display: flex !important;
          flex-flow: column nowrap;
          position: relative !important;
          width: 100%;
          height: fit-content;
        }
      </style>

      <style name="gap">
        :host > ::slotted(*) {
          margin: 0 0 !important;
        }
      </style>

      <style>
        :host > ::slotted(*:first-child) {
          margin-top: 0 !important;
        }

        :host > ::slotted(*:last-child) {
          margin-bottom: 0 !important;
        }
      </style>

      <slot></slot>
    `;
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "gap":
        this.ui.gap = i;
        break;
    }
  }
};
r(w, "register", () => {
  customElements.get("ui-flex-grid") || customElements.define("ui-flex-grid", w);
}), r(w, "observedAttributes", ["gap"]);
let ot = w;
const k = class k extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.ui = {
      /**
       * @type {import("../ui-text").UILabel | null}
       */
      label: null,
      /**
       * @type {HTMLInputElement | null}
       */
      input: null,
      get primary() {
        return this.label.ui.primary;
      },
      set primary(t) {
        this.label.ui.primary = t;
      },
      get secondary() {
        return this.label.ui.secondary;
      },
      set secondary(t) {
        this.label.ui.secondary = t;
      },
      get value() {
        return this.input.value;
      },
      set value(t) {
        this.input.value = t;
      },
      get checked() {
        return this.input.checked;
      },
      set checked(t) {
        this.input.checked = t;
      }
    }, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <ui-label ripple>
        <input slot="input" type="checkbox"></input>
      </ui-label>
    `, this.ui.label = this.shadowRoot.querySelector("ui-label"), this.ui.input = this.shadowRoot.querySelector("input");
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oV
   * @param {string | null} nV
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "primary":
        this.ui.primary = i;
        break;
      case "secondary":
        this.ui.primary = i;
        break;
      case "value":
        this.ui.value = i;
        break;
      case "checked":
        this.ui.checked = i !== null;
        break;
    }
  }
};
r(k, "register", () => {
  customElements.get("ui-check") || customElements.define("ui-check", k);
}), r(k, "observedAttributes", ["primary", "secondary", "value", "checked"]);
let rt = k;
const x = class x extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.removeRipple = null, this.running = !1, this.onClick = async () => {
      this.ui.inputSlot.forEach(
        (t) => t.click()
      );
    }, this.onInputClick = async (t) => {
      t.stopPropagation();
    }, this.ui = {
      root: this,
      get ripple() {
        return this.root.running;
      },
      set ripple(t) {
        if (!t) {
          this.root.disableRipple();
          return;
        }
        this.root.enableRipple();
      },
      get primary() {
        return this.root.shadowRoot.querySelector("ui-primary").innerHTML;
      },
      set primary(t) {
        this.root.shadowRoot.querySelector("ui-primary").innerHTML = t || "";
      },
      get secondary() {
        return this.root.shadowRoot.querySelector("ui-secondary").innerHTML;
      },
      set secondary(t) {
        this.root.shadowRoot.querySelector("ui-secondary").innerHTML = t || "";
      },
      get inputSlot() {
        return [...this.root.querySelectorAll('[slot="input"]')];
      }
    }, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        * {
          box-sizing: border-box;
        }

        :host {
          position: relative !important;
          display: flex !important;
          flex-direction: row;
          width: 100%;
          padding: var(--ui-spacing);
          border-radius: var(--ui-radius);
        }

        :host > .text {
          display: flex;
          flex: 1;
          flex-direction: column;
          justify-content: center;
          margin-right: var(--ui-spacing);
        }

        :host > .input {
          display: flex;
          align-items: center;
          justify-content: flex-end;
        }
      </style>

      <span class="text">
        <ui-primary></ui-primary>
        <ui-secondary></ui-secondary>
      </span>

      <span class="input">
        <slot name="input"></slot>
        <slot></slot>
      </span>
    `;
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "ripple":
        this.ui.ripple = i !== null;
        break;
      case "primary":
        this.ui.primary = i;
        break;
      case "secondary":
        this.ui.secondary = i;
        break;
    }
  }
  enableRipple() {
    if (this.removeRipple || (this.removeRipple = u(this), this.style.cursor = "pointer", this.running)) return;
    this.addEventListener("click", this.onClick), [...this.querySelectorAll('[slot="input"]')].forEach((e) => {
      e.addEventListener("click", this.onInputClick);
    }), this.running = !0;
  }
  disableRipple() {
    this.running && (this.removeRipple && this.removeRipple(), this.removeEventListener("click", this.onClick), this.ui.inputSlot.forEach((t) => {
      t.removeEventListener("click", this.onInputClick);
    }), this.running = !1);
  }
};
r(x, "register", () => {
  customElements.get("ui-label") || customElements.define("ui-label", x);
}), r(x, "observedAttributes", ["ripple", "secondary", "primary"]);
let st = x;
const F = class F extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.ui = {}, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        :host {
          font-size: 1.1rem;
          font-family: var(--ui-fontFamily);
          font-variation-settings: var(--ui-text-primary-fontVariation);
        }
      </style>

      <slot></slot>
    `;
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
};
r(F, "register", () => {
  customElements.get("ui-primary") || customElements.define("ui-primary", F);
});
let nt = F;
const D = class D extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.ui = {}, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        :host {
          font-size: 0.9rem;
          font-family: var(--ui-fontFamily);
          font-variation-settings: var(--ui-text-secondary-fontVariation);
        }
      </style>

      <slot></slot>
    `;
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
};
r(D, "register", () => {
  customElements.get("ui-secondary") || customElements.define("ui-secondary", D);
});
let p = D;
const C = class C extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.ui = {
      root: this,
      /** @type {Events<E>} */
      events: new c(),
      /** @type {HTMLInputElement | null} */
      input: null,
      get title() {
        return this.root.getAttribute("title");
      },
      set title(t) {
        let e = this.root.querySelector('[slot="title"]');
        !t && e && this.root.removeChild(e), t && (e || (e = new p(), e.slot = "title", this.root.appendChild(e)), e.innerHTML = t);
      },
      get type() {
        return this.input.type;
      },
      set type(t) {
        this.input.type = t || "";
      },
      get value() {
        return this.input.value;
      },
      set value(t) {
        this.input.value = t;
      },
      get placeholder() {
        return this.input.placeholder;
      },
      set placeholder(t) {
        this.input.placeholder = t || "";
      },
      get invalid() {
        return this.root.hasAttribute("invalid");
      },
      set invalid(t) {
        if (!t) {
          this.root.removeAttribute("invalid");
          return;
        }
        this.root.setAttribute("invalid", "");
      },
      get min() {
        return this.input.min;
      },
      set min(t) {
        this.input.min = t;
      },
      get max() {
        return this.input.max;
      },
      set max(t) {
        this.input.max = t;
      },
      /**
       * @param {FocusOptions | null} [options]
       */
      focus(t = null) {
        this.root.shadowRoot.querySelector("input").focus(t);
      },
      blur() {
        this.root.shadowRoot.querySelector("input").blur();
      }
    }, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        * {
          box-sizing: border-box;
        }

        :host {
          display: block;
          position: relative;
          width: 100%;
          height: fit-content;
        }

        input {
          width: 100%;
          display: block;
          margin: 0;
          padding: var(--ui-spacing) calc(var(--ui-spacing) * 2);
          border: none !important;
          border-radius: inherit;
          outline: none !important;
          font-size: 0.9rem;
          font-family: var(--ui-fontFamily);
          font-variation-settings: var(--ui-input-fontVariation);
          accent-color: var(--ui-primary-bgColor);
          background-color: transparent !important;
        }

        .container {
          width: 100%;
          border: none;
          border: 1px solid var(--ui-borderColor);
          border-radius: var(--ui-radius);
          transition: border-color 0.25s linear;
        }

        .container:has(input:focus) {
          border-color: var(--ui-primary-bgColor);
        }

        :host([invalid]) .container {
          border-color: var(--ui-destructive-bgColor);
        }

        ::slotted([slot="title"]) {
          display: block;
          padding: 0 var(--ui-spacing);
          user-select: none;
          transform: translateY(calc(var(--ui-spacing) / 2));
        }
      </style>

      <div class="container">
        <slot name="title"></slot>
        <input />
      </div>
    `, this.ui.input = this.shadowRoot.querySelector("input"), this.ui.input.type = this.getAttribute("type") || "text", this.ui.input.oninput = () => {
      this.ui.events.dispatch("input", this.ui.input.value);
    }, this.ui.input.onchange = () => {
      this.ui.events.dispatch("change", this.ui.input.value);
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "title":
        this.ui.title = i;
        break;
      case "type":
        this.ui.type = i;
        break;
      case "value":
        this.ui.value = i;
        break;
      case "placeholder":
        this.ui.placeholder = i;
        break;
      case "invalid":
        this.ui.input.ariaInvalid = i !== null ? "" : null;
        break;
      case "min":
        this.ui.min = i;
        break;
      case "max":
        this.ui.max = i;
        break;
    }
  }
};
r(C, "register", () => {
  customElements.get("ui-input") || customElements.define("ui-input", C);
}), r(C, "observedAttributes", [
  "title",
  "type",
  "value",
  "placeholder",
  "invalid",
  "min",
  "max"
]);
let at = C;
const zt = n`
  <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
    <g
      id="SVGRepo_tracerCarrier"
      stroke-linecap="round"
      stroke-linejoin="round"
    ></g>
    <g id="SVGRepo_iconCarrier">
      <g clip-path="url(#clip0_15_152)">
        <rect width="24" height="24" fill="none"></rect>
        <circle
          cx="10.5"
          cy="10.5"
          r="6.5"
          stroke="currentColor"
          stroke-linejoin="round"
        ></circle>
        <path
          d="M19.6464 20.3536C19.8417 20.5488 20.1583 20.5488 20.3536 20.3536C20.5488 20.1583 20.5488 19.8417 20.3536 19.6464L19.6464 20.3536ZM20.3536 19.6464L15.3536 14.6464L14.6464 15.3536L19.6464 20.3536L20.3536 19.6464Z"
          fill="currentColor"
        ></path>
      </g>
      <defs>
        <clipPath id="clip0_15_152">
          <rect width="24" height="24" fill="none"></rect>
        </clipPath>
      </defs>
    </g>
  </svg>
`, R = class R extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.storagekey = "", this.ui = {
      root: this,
      /** @type {Events<E>} */
      events: new c(),
      /** @type {HTMLInputElement | null} */
      input: null,
      /** @type {import("../ui-button").UIIconButton} */
      submit: this.querySelector('[name="submit"]'),
      get title() {
        return this.root.querySelector('[slot="title"]').innerHTML;
      },
      set title(t) {
        let e = this.root.querySelector('[slot="title"]');
        !t && e && this.root.removeChild(e), t && (e || (e = new p(), e.slot = "title", this.root.appendChild(e)), e.innerHTML = t);
      },
      get value() {
        return this.input.value;
      },
      set value(t) {
        this.input.value = t;
      },
      get placeholder() {
        return this.input.placeholder;
      },
      set placeholder(t) {
        this.input.placeholder = t || "";
      },
      get invalid() {
        return this.root.hasAttribute("invalid");
      },
      set invalid(t) {
        if (!t) {
          this.root.removeAttribute("invalid");
          return;
        }
        this.root.setAttribute("invalid", "");
      },
      get nosubmit() {
        return this.submit.style.display === "none";
      },
      set nosubmit(t) {
        if (!t) {
          this.submit.style.display = null;
          return;
        }
        this.submit.style.display = "none";
      },
      get storage() {
        return this.root.hasAttribute("storage");
      },
      set storage(t) {
        if (!t) {
          this.root.removeAttribute("storage");
          return;
        }
        this.root.setAttribute("storage", "");
      },
      get storageprefix() {
        return this.root.getAttribute("storageprefix");
      },
      set storageprefix(t) {
        if (!t) {
          this.root.removeAttribute("storageprefix");
          return;
        }
        this.root.setAttribute("storageprefix", t);
      },
      get storagekey() {
        return this.root.storagekey;
      },
      set storagekey(t) {
        this.root.storagekey = t, this.storage && (this.value = localStorage.getItem(this.storageprefix + this.root.storagekey) || "", this.events.dispatch("storage", this.value));
      },
      /**
       * @param {FocusOptions | null} [options]
       */
      focus(t = null) {
        this.root.shadowRoot.querySelector("input").focus(t);
      },
      blur() {
        this.root.shadowRoot.querySelector("input").blur();
      }
    }, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        * {
          box-sizing: border-box;
        }

        :host {
          display: block;
          position: relative;
          width: 100%;
          height: fit-content;
        }

        input {
          width: 100%;
          display: block;
          margin: 0;
          padding: var(--ui-spacing) calc(var(--ui-spacing) * 2);
          border: none !important;
          border-radius: inherit;
          outline: none !important;
          font-size: 0.9rem;
          font-family: var(--ui-fontFamily);
          font-variation-settings: var(--ui-input-fontVariation);
          accent-color: var(--ui-primary-bgColor);
          background-color: transparent !important;
        }

        :host(:not([nosubmit])) input {
          width: calc(100% - 2rem);
        }

        .container {
          position: relative;
          width: 100%;
          border: none;
          border: 1px solid var(--ui-borderColor);
          border-radius: var(--ui-radius);
          transition: border-color 0.25s linear;
          background-color: var(--ui-backdrop-bgColor);
          -webkit-backdrop-filter: var(--ui-backdropFilter);
          backdrop-filter: var(--ui-backdropFilter);
        }

        .container:has(input:focus) {
          border-color: var(--ui-primary-bgColor);
        }

        :host([invalid]) .container {
          border-color: var(--ui-destructive-bgColor);
        }

        ::slotted([slot="title"]) {
          display: block;
          padding: 0 var(--ui-spacing);
          user-select: none;
          transform: translateY(calc(var(--ui-spacing) / 2));
        }

        ui-icon-button {
          position: absolute;
          top: 0;
          right: 0;
          height: 100%;
          border-top-left-radius: 0;
          border-bottom-left-radius: 0;
        }
      </style>

      <div class="container">
        <slot name="title"></slot>
        <input type="search" />
        <ui-icon-button name="submit" ghost>${zt}</ui-icon-button>
      </div>
    `, this.ui.submit = this.shadowRoot.querySelector('[name="submit"]'), this.ui.input = this.shadowRoot.querySelector("input"), this.ui.input.type = "search", this.ui.input.addEventListener("keydown", async (e) => {
      this.ui.nosubmit || e.key === "Enter" && this.ui.submit.click();
    });
    let t = null;
    this.ui.input.addEventListener("input", async () => {
      this.ui.storage && (t !== null && clearTimeout(t), t = setTimeout(() => {
        localStorage.setItem(
          this.ui.storageprefix + this.ui.storagekey,
          this.ui.input.value
        ), t = null;
      }, 250)), this.ui.events.dispatch("input", this.ui.input.value);
    }), this.shadowRoot.querySelector("ui-icon-button").addEventListener("click", () => {
      this.ui.events.dispatch("submit", this.ui.input.value);
    });
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "title":
        this.ui.title = i;
        break;
      case "value":
        this.ui.value = i;
        break;
      case "placeholder":
        this.ui.placeholder = i;
        break;
      case "invalid":
        this.ui.input.ariaInvalid = i !== null ? "" : null;
        break;
      case "nosubmit":
        this.ui.nosubmit = i !== null;
        break;
      case "storagekey":
        this.ui.storagekey = i;
        break;
    }
  }
};
r(R, "register", () => {
  customElements.get("ui-search") || customElements.define("ui-search", R);
}), r(R, "observedAttributes", [
  "title",
  "value",
  "placeholder",
  "invalid",
  "nosubmit",
  "storage",
  "storageprefix",
  "storagekey"
]);
let lt = R;
const V = class V extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.ui = {
      root: this,
      get value() {
        return this.root.getAttribute("value");
      },
      set value(t) {
        if (!t) {
          this.root.removeAttribute("value");
          return;
        }
        this.root.setAttribute("value", t);
      },
      get selected() {
        return this.root.hasAttribute("selected");
      },
      set selected(t) {
        if (!t) {
          this.root.removeAttribute("selected");
          return;
        }
        this.root.setAttribute("selected", "");
      }
    }, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        :host {
          display: none;
          align-items: center;

          padding: var(--ui-spacing);
          padding-right: 2.5rem;

          height: calc(1em * var(--ui-lineHeight) + var(--ui-spacing) * 2);

          white-space: nowrap;
          text-overflow: ellipsis;

          transition:
            background-color 0.25s linear,
            color 0.25s linear;

          overflow: hidden;
        }
      </style>

      <slot></slot>
    `;
  }
  connectedCallback() {
    this.setAttribute("role", "button");
  }
  disconnectedCallback() {
  }
};
r(V, "register", () => {
  customElements.get("ui-select-option") || customElements.define("ui-select-option", V);
});
let M = V;
const O = class O extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.ui = {
      root: this,
      /**
       *  @type {Events<UISelectEvents>}
       */
      events: new c(),
      get open() {
        return this.root.hasAttribute("open");
      },
      set open(t) {
        if (!t) {
          this.root.removeAttribute("open");
          return;
        }
        this.root.setAttribute("open", "");
      },
      /**
       * @returns {UISelectOption[]}
       */
      options() {
        return [...this.root.children].filter(
          (t) => t instanceof M
        );
      },
      /**
       * @returns {UISelectOption | null}
       */
      selected() {
        try {
          return this.options().find(
            (t) => t.ui.selected
          ) || null;
        } catch {
          return null;
        }
      }
    }, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        * {
          box-sizing: border-box;
        }

        :host {
          --ui-bgColor: "transparent";
          --items-length: 0;

          position: relative !important;
          display: block !important;

          width: 100%;
          height: calc(1em * var(--ui-lineHeight) + var(--ui-spacing) * 2);
          transition: height 0.25s ease;

          background-color: var(--ui-bgColor);
          color: var(--ui-color);

          border: 1px solid var(--ui-borderColor);
          border-radius: var(--ui-radius);

          line-height: 1.15;

          overflow: hidden;

          font-size: 0.9rem;
          font-family: var(--ui-fontFamily);
          font-variation-settings: var(--ui-select-fontVariation);
        }

        .options {
          cursor: pointer;
          display: none;
          display: flex;
          flex-direction: column;
          min-height: 100%;
        }

        .icon {
          display: flex;
          justify-content: center;
          align-items: center;
          position: absolute;
          top: 0;
          right: 0;
          width: 2.5rem;
          height: 100%;
          color: var(--ui-primary-bgColor);
        }

        ::slotted(ui-select-option) {
          display: flex;
        }

        :host(.open) {
          height: calc(
            (1em * var(--ui-lineHeight) + var(--ui-spacing) * 2) *
              var(--items-length)
          );
        }

        :host(.open) .options {
          display: block;
        }

        :host(.open) .icon {
          display: none;
        }

        :host(.open) ::slotted(ui-select-option[selected]) {
          background-color: var(--ui-primary-bgColor);
          color: var(--ui-primary-color);
        }

        :host(.open) ::slotted(ui-select-option:not([selected]):hover) {
          background-color: hsla(var(--ui-color-hsl), 0.1);
        }

        :host(:not(.open))
          .options:has(> ::slotted(ui-select-option[selected])) {
          display: block;
        }

        :host(:not(.open)) ::slotted(ui-select-option:not([selected])) {
          display: none;
        }
      </style>

      <div class="options">
        <div class="icon"><ui-svg>${At}</ui-svg></div>

        <slot></slot>
      </div>
    `;
    const t = (i) => {
      const s = async (a) => {
        (a.composedPath() || []).forEach((l) => {
          l instanceof M && ([...this.querySelectorAll("ui-select-option")].forEach(
            (B) => B.removeAttribute("selected")
          ), l.setAttribute("selected", ""), this.ui.events.dispatch("change", l));
        });
      };
      this.classList.toggle("open") ? (i.stopPropagation(), this.addEventListener("click", s)) : setTimeout(() => this.removeEventListener("click", s));
    };
    this.shadowRoot.querySelector(".options").addEventListener("click", t), this.style.setProperty(
      "--items-length",
      this.querySelectorAll("ui-select-option").length.toString()
    );
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
};
r(O, "register", () => {
  customElements.get("ui-select") || customElements.define("ui-select", O);
});
let ct = O;
const E = class E extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.ui = {
      root: this,
      /** @type {Events<E>} */
      events: new c(),
      /** @type {HTMLTextAreaElement | null} */
      textarea: null,
      get title() {
        return this.root.getAttribute("title");
      },
      set title(t) {
        let e = this.root.querySelector('[slot="title"]');
        !t && e && this.root.removeChild(e), t && (e || (e = new p(), e.slot = "title", this.root.appendChild(e)), e.innerHTML = t);
      },
      get value() {
        return this.textarea.value;
      },
      set value(t) {
        this.textarea.value = t;
      },
      get placeholder() {
        return this.textarea.placeholder;
      },
      set placeholder(t) {
        this.textarea.placeholder = t || "";
      },
      get invalid() {
        return this.root.hasAttribute("invalid");
      },
      set invalid(t) {
        if (!t) {
          this.root.removeAttribute("invalid");
          return;
        }
        this.root.setAttribute("invalid", "");
      },
      get rows() {
        return this.textarea.rows;
      },
      set rows(t) {
        this.textarea.rows = t;
      },
      get cols() {
        return this.textarea.cols;
      },
      set cols(t) {
        this.textarea.cols = t;
      },
      /**
       * @param {FocusOptions | null} [options]
       */
      focus(t = null) {
        this.root.shadowRoot.querySelector("textarea").focus(t);
      },
      blur() {
        this.root.shadowRoot.querySelector("textarea").blur();
      }
    }, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        * {
          box-sizing: border-box;
        }

        :host {
          display: block;
          position: relative;
          width: 100%;
          height: fit-content;
        }

        textarea {
          resize: none;
          width: 100%;
          display: block;
          margin: 0;
          padding: var(--ui-spacing) calc(var(--ui-spacing) * 2);
          border: none !important;
          border-radius: inherit;
          outline: none !important;
          font-size: 0.9rem;
          font-family: var(--ui-fontFamily);
          font-variation-settings: var(--ui-input-fontVariation);
          accent-color: var(--ui-primary-bgColor);
          background-color: transparent !important;
        }

        .container {
          width: 100%;
          height: 100%;
          border: none;
          border: 1px solid var(--ui-borderColor);
          border-radius: var(--ui-radius);
          transition: border-color 0.25s linear;
        }

        .container:has(textarea:focus) {
          border-color: var(--ui-primary-bgColor);
        }

        :host([invalid]) .container {
          border-color: var(--ui-destructive-bgColor);
        }

        ::slotted([slot="title"]) {
          display: block;
          padding: 0 var(--ui-spacing);
          user-select: none;
          transform: translateY(calc(var(--ui-spacing) / 2));
        }
      </style>

      <div class="container">
        <slot name="title"></slot>
        <textarea></textarea>
      </div>
    `, this.ui.textarea = this.shadowRoot.querySelector("textarea"), this.ui.textarea.oninput = () => {
      this.ui.events.dispatch("input", this.ui.textarea.value);
    }, this.ui.textarea.onchange = () => {
      this.ui.events.dispatch("change", this.ui.textarea.value);
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "title":
        this.ui.title = i;
        break;
      case "value":
        this.ui.value = i;
        break;
      case "placeholder":
        this.ui.placeholder = i;
        break;
      case "invalid":
        this.ui.textarea.ariaInvalid = i !== null ? "" : null;
        break;
      case "rows":
        this.ui.rows = i !== null ? parseFloat(i) : null;
        break;
      case "cols":
        this.ui.cols = i !== null ? parseFloat(i) : null;
        break;
    }
  }
};
r(E, "register", () => {
  customElements.get("ui-textarea") || customElements.define("ui-textarea", E);
}), r(E, "observedAttributes", [
  "title",
  "value",
  "placeholder",
  "invalid",
  "rows",
  "cols"
]);
let dt = E;
const A = class A extends HTMLElement {
  constructor() {
    super(), this.ui = {
      root: this,
      /**
       * @type {{
       *  [key: string]: {
       *      [key: string]: string;
       *  };
       * }}
       */
      data: {},
      /**
       * @type {Events<{ "change": import(".").UILangType}>}
       */
      events: new c(),
      get current() {
        return this.root.getAttribute("current");
      },
      set current(t) {
        this.root.setCurrent(t || "");
      },
      /** @returns {import(".").UILangType} */
      fallback() {
        return this.root.querySelector("ui-lang-type[fallback]");
      },
      /**
       * @param {string} group
       * @param {string} key
       */
      get(t, e) {
        var i, s;
        return ((s = (i = this.data) == null ? void 0 : i[t]) == null ? void 0 : s[e]) || null;
      }
    }, this.shadowRender();
  }
  shadowRender() {
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "current":
        this.ui.current = i;
        break;
    }
  }
  /**
   * @private
   * @param {string} name
   */
  async setCurrent(t) {
    const e = this.querySelector(`ui-lang-type[name="${t}"]`) || this.ui.fallback();
    if (e) {
      if (!e.ui.href) throw "Missing href attribute!";
      try {
        this.data = (await fetch(e.ui.href)).json();
      } catch (i) {
        console.error(i);
      }
      this.ui.events.dispatch("change", e);
    }
  }
};
r(A, "register", () => {
  customElements.get("ui-lang") || customElements.define("ui-lang", A);
}), r(A, "observedAttributes", ["current"]);
let ht = A;
const P = class P extends HTMLElement {
  constructor() {
    super(), this.ui = {
      root: this,
      get name() {
        return this.root.getAttribute("name");
      },
      set name(t) {
        if (!t) {
          this.root.removeAttribute("name");
          return;
        }
        this.root.setAttribute("name", t);
      },
      get href() {
        return this.root.getAttribute("href");
      },
      set href(t) {
        if (!t) {
          this.root.removeAttribute("href");
          return;
        }
        this.root.setAttribute("href", t);
      },
      get fallback() {
        return this.root.hasAttribute("fallback");
      },
      set fallback(t) {
        if (!t) {
          this.root.removeAttribute("fallback");
          return;
        }
        this.root.setAttribute("fallback", "");
      }
    }, this.shadowRender();
  }
  shadowRender() {
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
};
r(P, "register", () => {
  customElements.get("ui-lang-type") || customElements.define("ui-lang-type", P);
});
let ut = P;
const L = class L extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.ui = {
      root: this,
      get nobg() {
        return this.root.hasAttribute("nobg");
      },
      set nobg(t) {
        const e = this.root.shadowRoot.querySelector(".background");
        if (!t) {
          e.style.display = null;
          return;
        }
        e.style.display = "none";
      }
    }, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        :host {
          position: absolute;
          top: 0;
          right: 0;
          bottom: 0;
          left: 0;
        }

        .background {
          z-index: 999;
          position: absolute;
          top: 0;
          right: 0;
          bottom: 0;
          left: 0;
          background-color: var(--ui-backdrop-bgColor);
          -webkit-backdrop-filter: var(--ui-backdropFilter);
          backdrop-filter: var(--ui-backdropFilter);
        }

        .spinner {
          z-index: 1000;
          content: "";
          box-sizing: border-box;
          position: absolute;
          top: 50%;
          left: 50%;
          width: 2.5rem;
          height: 2.5rem;
          margin-top: -1.25rem;
          margin-left: -1.25rem;
          border-radius: 50%;
          border: 2px solid var(--ui-borderColor);
          border-top-color: var(--ui-primary-bgColor);
          animation: spinner 0.6s linear infinite;
        }

        @keyframes spinner {
          to {
            transform: rotate(360deg);
          }
        }
      </style>

      <div class="background"></div>
      <div class="spinner"></div>
    `;
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "nobg":
        this.ui.nobg = i !== null;
        break;
    }
  }
};
r(L, "register", () => {
  customElements.get("ui-spinner") || customElements.define("ui-spinner", L);
}), r(L, "observedAttributes", ["nobg"]);
let pt = L;
const S = class S extends HTMLElement {
  /**
   * @param {string} name
   */
  constructor(t) {
    super(), this.attachShadow({ mode: "open" }), this._name = t, this.ui = {
      root: this,
      get name() {
        return this.root._name;
      },
      set name(e) {
        this.name = e || "";
      }
    }, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        :host {
          display: block !important;
          position: absolute !important;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          opacity: 0;
          animation: fade-in 0.5s;
          transition: opacity 0.5s ease;
        }

        :host(:last-child) {
          opacity: 1;
        }

        @keyframes fade-in {
          0% {
            opacity: 0;
          }
          100% {
            opacity: 1;
          }
        }
      </style>

      <slot></slot>
    `;
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} n
   * @param {string | null} _oV
   * @param {string | null} nV
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "name":
        this.ui.name = i;
        break;
    }
  }
};
r(S, "register", () => {
  customElements.get("ui-stack-layout-page") || customElements.define("ui-stack-layout-page", S);
}), r(S, "observedAttributes", ["name"]);
let gt = S;
const Y = class Y extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.pages = {}, this.stack = [], this.onpopstate = () => this.goBack(), this.ui = {
      root: this,
      /**
       * @type {Events<{
       *  "change": {
       *      oldPage: UIStackLayoutPage | null,
       *      newPage: UIStackLayoutPage | null
       *  }
       * }>}
       */
      events: new c(),
      lock: !1,
      size() {
        return this.root.stack.length;
      },
      clear() {
        for (; this.size() > 0; )
          this.root.removeChild(this.root.stack.pop());
      },
      goBack() {
        if (!(!this.size() || this.lock)) {
          if (this.root.onpopstate !== null) {
            history.back();
            return;
          }
          this.root.goBack();
        }
      },
      /**
       * @param {string} pageName
       * @param {() => (UIStackLayoutPage)} cb
       */
      register(t, e) {
        this.root.pages[t] = e;
      },
      /**
       * @param {string} pageName
       */
      unregister(t) {
        delete this.root.pages[t];
      },
      /**
       * @param {string} pageName
       * @param {((page: UIStackLayoutPage) => void|Promise<void>) | null} [cb]
       * @param {boolean} [keepOldPage]
       */
      set(t, e = null, i = !1) {
        if (this.lock) return;
        const s = this.root.pages[t]();
        this.root.stack.push(this.root.appendChild(s)), typeof e == "function" && setTimeout(() => e(s));
        let a = null;
        this.size() > 1 && !i && (a = this.root.stack[this.root.stack.length - 2], a.parentElement.removeChild(a)), this.root.dispatchChangeEvent(a), this.root.onpopstate !== null && history.pushState(null, document.title, location.href);
      }
    }, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        :host {
          display: block !important;
          position: relative !important;
          width: 100%;
          height: 100%;
        }
      </style>

      <slot></slot>
    `;
  }
  connectedCallback() {
    window.addEventListener("popstate", this.onpopstate);
  }
  disconnectedCallback() {
    window.removeEventListener("popstate", this.onpopstate);
  }
  goBack() {
    const t = this.removeChild(this.stack.pop());
    this.stack.length > 0 && (this.stack[this.stack.length - 1].parentElement || this.appendChild(this.stack[this.stack.length - 1])), this.dispatchChangeEvent(t);
  }
  /**
   * @param {UIStackLayoutPage} oldChild
   */
  async dispatchChangeEvent(t) {
    this.ui.events.dispatch("change", {
      newPage: this.stack[this.stack.length - 1] || null,
      oldPage: t || this.stack[this.stack.length - 2] || null
    });
  }
};
r(Y, "register", () => {
  customElements.get("ui-stack-layout") || customElements.define("ui-stack-layout", Y);
});
let bt = Y;
const J = class J extends HTMLElement {
  constructor() {
    super(), this.stores = {}, this.ui = {
      root: this,
      /**
       * @type {Events<T>}
       */
      events: new c(),
      get storage() {
        return this.root.hasAttribute("storage");
      },
      set storage(t) {
        if (!t) {
          this.root.removeAttribute("storage");
          return;
        }
        this.root.setAttribute("storage", "");
      },
      get storageprefix() {
        return this.root.getAttribute("storageprefix");
      },
      set storageprefix(t) {
        if (!t) {
          this.root.removeAttribute("storageprefix");
          return;
        }
        this.root.setAttribute("storageprefix", t);
      },
      /**
       * @template {keyof T} K
       * @param {K} key
       * @returns {T[K]}
       */
      get(t) {
        return this.root.stores[t];
      },
      /**
       * @template {keyof T} K
       * @param {K} key
       * @param {T[K]} data
       * @param {boolean} [useDataAsFallback] Use data as fallback, if nothing found in the browsers `localStorage`
       * `this.enableLocalStorage` flag needs to be set to `true` for this to work
       */
      set(t, e, i = !1) {
        if (i && this.storageprefix) {
          const s = JSON.parse(
            localStorage.getItem((this.storageprefix || "") + t.toString()) || "null"
          );
          this.root.stores[t] = s ?? e;
        } else
          this.root.stores[t] = e;
        this.storage && localStorage.setItem(
          (this.storageprefix || "") + t.toString(),
          JSON.stringify(this.root.stores[t])
        ), this.events.dispatch(t, this.root.stores[t]);
      },
      /**
       * @template {keyof T} K
       * @param {K} key
       * @param {(data: T[K]) => any} callback
       */
      update(t, e) {
        if (typeof e != "function")
          throw "callback is not a function";
        this.set(t, e(this.root.stores[t]));
      },
      /**
       * @template {keyof T} K
       * @param {K} key
       * @param {(data: T[K]) => void|Promise<void>} callback
       * @param {boolean} [trigger] - this will run the callback first
       * @returns {() => void} clean up function
       */
      on(t, e, i = !1) {
        if (typeof e != "function")
          throw "callback is not a function";
        return i && e(this.get(t)), this.events.on(t, e);
      }
    }, this.shadowRender();
  }
  shadowRender() {
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
};
r(J, "register", () => {
  customElements.get("ui-store") || customElements.define("ui-store", J);
});
let mt = J;
const T = class T extends HTMLElement {
  constructor() {
    super(), this.mediaHandler = null, this.themes = {}, this.currentTheme = null, this.mode = "", this.ui = {
      root: this,
      get auto() {
        return !!this.root.media;
      },
      set auto(t) {
        this.root.setAuto(t);
      },
      get mode() {
        return this.root.mode;
      },
      set mode(t) {
        this.root.setMode(t);
      },
      /**
       * @param {string} themeName
       * @param {string} href
       */
      add(t, e) {
        this.root.themes[t] = e;
      },
      /**
       * @param {string} themeName
       */
      set(t) {
        var i;
        if (!this.root.themes[t])
          throw `theme "${t}" is missing in this.themes`;
        if (((i = this.root.currentTheme) == null ? void 0 : i.name) == t)
          return;
        {
          const s = document.getElementById("theme");
          s && (document.head.removeChild(s), this.root.currentTheme = null);
        }
        const e = document.createElement("link");
        e.id = "theme", e.rel = "stylesheet", e.href = this.root.themes[t], document.head.appendChild(e), this.root.currentTheme = {
          name: t,
          href: this.root.themes[t]
        };
      }
    }, this.shadowRender();
  }
  shadowRender() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "auto":
        this.ui.auto = i !== null;
        break;
      case "mode":
        this.ui.mode = i;
        break;
    }
  }
  /**
   * @param {boolean} state
   * @param {HTMLElement} target
   */
  setAuto(t, e = document.body) {
    if (!t) {
      if (!this.media) return;
      this.media.removeEventListener("change", this.mediaHandler), this.media = null, this.mediaHandler = null;
      return;
    }
    if (this.setMode(null, e), this.media) {
      this.mediaHandler(this.media);
      return;
    }
    this.mediaHandler = (i) => {
      i.matches ? e.setAttribute("data-theme", "dark") : e.setAttribute("data-theme", "light");
    }, this.media = window.matchMedia("(prefers-color-scheme: dark)"), this.media.addEventListener("change", this.mediaHandler), this.mediaHandler(this.media);
  }
  /**
   * @param {string | null} value
   * @param {HTMLElement} target
   */
  setMode(t, e = document.body) {
    this.mode = t, this.mode ? e.setAttribute("data-theme", t) : e.removeAttribute("data-theme");
  }
};
r(T, "register", () => {
  customElements.get("ui-theme-handler") || customElements.define("ui-theme-handler", T);
}), r(T, "observedAttributes", ["auto", "mode"]);
let ft = T;
const Z = class Z extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.ui = {}, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = n`
      <style>
        :host {
          display: block;
          width: 100%;
          height: 100%;
          color: inherit;
        }

        svg {
          width: 100%;
          height: 100%;
        }
      </style>

      <slot></slot>
    `;
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
};
r(Z, "register", () => {
  customElements.get("ui-svg") || customElements.define("ui-svg", Z);
});
let vt = Z;
function Ft() {
  Q.register(), K.register(), W.register(), N.register(), G.register(), _.register(), tt.register(), I.register(), U.register(), et.register(), it.register(), ot.register(), rt.register(), at.register(), lt.register(), M.register(), ct.register(), dt.register(), ut.register(), ht.register(), pt.register(), bt.register(), gt.register(), mt.register(), vt.register(), st.register(), nt.register(), p.register(), ft.register();
}
export {
  K as UIAppBar,
  Q as UIAppBarItem,
  W as UIButton,
  rt as UICheck,
  G as UIContainer,
  _ as UIDialog,
  U as UIDrawer,
  I as UIDrawerGroup,
  tt as UIDrawerGroupItem,
  ot as UIFlexGrid,
  et as UIFlexGridItem,
  it as UIFlexGridRow,
  N as UIIconButton,
  at as UIInput,
  st as UILabel,
  ht as UILang,
  ut as UILangType,
  nt as UIPrimary,
  lt as UISearch,
  p as UISecondary,
  ct as UISelect,
  M as UISelectOption,
  pt as UISpinner,
  bt as UIStackLayout,
  gt as UIStackLayoutPage,
  mt as UIStore,
  ft as UIThemeHandler,
  $t as js,
  Ft as register
};
