var Ct = Object.defineProperty;
var mt = (s) => {
  throw TypeError(s);
};
var xt = (s, e, t) => e in s ? Ct(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t;
var i = (s, e, t) => xt(s, typeof e != "symbol" ? e + "" : e, t), At = (s, e, t) => e.has(s) || mt("Cannot " + t);
var b = (s, e, t) => (At(s, e, "read from private field"), t ? t.call(s) : e.get(s)), ft = (s, e, t) => e.has(s) ? mt("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(s) : e.set(s, t);
const vt = {
  onDragStart: null,
  onDragging: null,
  onDragEnd: null
};
function St(s, e = {}) {
  e = {
    ...vt,
    ...e
  };
  const t = () => {
    const n = [...s.parentNode.children].indexOf(s);
    s.draggable = !0, s.ondragstart = (l) => {
      l.dataTransfer.effectAllowed = "move", l.dataTransfer.dropEffect = "move", l.dataTransfer.setData(
        "text/plain",
        n.toString()
      ), e.onDragStart && e.onDragStart(n);
    }, s.ondragover = (l) => (l.preventDefault(), !1), s.ondragenter = (l) => {
      l.preventDefault(), e.onDragging && e.onDragging(n);
    }, s.ondrop = (l) => {
      l.preventDefault(), l.dataTransfer.dropEffect = "move";
      const Z = parseInt(
        l.dataTransfer.getData("text/plain"),
        10
      );
      e.onDragEnd && e.onDragEnd(Z, n);
    };
  }, r = () => {
    s.draggable = !1, s.ondragstart = null, s.ondragover = null, s.ondragenter = null, s.ondrop = null;
  };
  return t(), {
    /**
     * @param {DraggableOptions} _options
     */
    update(o) {
      e = {
        ...vt,
        ...o
      }, r(), t();
    },
    destroy: r
  };
}
var p;
class g {
  constructor() {
    /**
     * @type {any}
     */
    ft(this, p, {});
  }
  /**
   * @template {keyof T} K
   * @param {K} key
   * @param {((data: T[K]) => void|Promise<void>) | null} listener
   * @returns {() => void} clean up function
   */
  on(e, t) {
    if (typeof t != "function")
      throw `invalid event listener passed for "${e.toString()}" event!`;
    return b(this, p)[e] || (b(this, p)[e] = []), b(this, p)[e].push(t), () => {
      this.off(e, t);
    };
  }
  // }}}
  /**
   * @template {keyof T} K
   * @param {K} key
   * @param {((data: T[K]) => void|Promise<void>)} listener
   */
  off(e, t) {
    if (!b(this, p)[e])
      throw `no listeners found for ${e.toString()}, there is nothing to delete`;
    let r = !1, o = 0;
    for (const n of b(this, p)[e])
      n === t && (b(this, p)[e].splice(o, 1), r = !0), o++;
    if (!r)
      throw `listener not found for ${e.toString()}, there is nothing to delete`;
    return this;
  }
  // }}}
  /**
   * @template {keyof T} K
   * @param {K} key
   * @param {T[K]} data
   */
  dispatch(e, t) {
    if (t === void 0) throw "data is undefined!";
    if (b(this, p)[e])
      for (const r of b(this, p)[e])
        r(t);
    return this;
  }
  // }}}
}
p = new WeakMap();
function wt(s, e) {
  const t = document.createElement("div");
  t.classList.add("ripple"), t.style.position = "absolute", t.style.color = "inherit", t.style.borderRadius = "50%", t.style.pointerEvents = "none", t.style.width = "100px", t.style.height = "100px", t.style.marginTop = "-50px", t.style.marginLeft = "-50px", t.style.opacity = `${e.opacity}`, t.style.backgroundColor = e.color, t.style.transform = "scale(0) translate(0, 0)", t.style.transition = `transform ${e.spreadDuration} ${e.spreadTiming} 0s,opacity ${e.clearDuration} ${e.clearTiming} 0s`, s.currentTarget.appendChild(t);
  const r = s.currentTarget.getBoundingClientRect();
  e.centered ? (t.style.top = `${r.height / 2}px`, t.style.left = `${r.width / 2}px`) : (t.style.top = `${s.clientY - r.top}px`, t.style.left = `${s.clientX - r.left}px`);
  const o = Math.max(r.width, r.height) * 0.02;
  return t.style.transform = `scale(${o}) translate(0, 0)`, t;
}
function yt(s) {
  s && (s.addEventListener("transitionend", (e) => {
    e.propertyName === "opacity" && s.remove();
  }), s.style.opacity = "0");
}
const kt = {
  color: "var(--ui-ripple-color, currentColor)",
  opacity: "var(--ui-ripple-opacity, 0.2)",
  centered: !1,
  spreadDuration: ".4s",
  spreadTiming: "linear",
  clearDuration: "1s",
  clearTiming: "ease-in-out",
  useClick: !1
};
function J(s, e = {}) {
  e = { ...kt, ...e };
  let t;
  const r = (n) => {
    t = wt(n, e);
  }, o = () => {
    yt(t);
  };
  return s.classList.add("ripple-container"), s.style.overflow = "hidden", e.useClick === !0 ? s.addEventListener("click", (n) => {
    t = wt(n, e), yt(t);
  }) : (s.addEventListener("pointerdown", r), s.addEventListener("pointerup", o), s.addEventListener("pointerleave", o)), () => {
    s.classList.remove("ripple-container"), s.removeEventListener("pointerdown", r), s.removeEventListener("pointerup", o), s.removeEventListener("pointerleave", o);
  };
}
function Et() {
  return /(android)/i.test(navigator.userAgent);
}
const a = String.raw, h = String.raw;
class u {
  constructor() {
    this.callbacks = [];
  }
  /**
   * @param {(() => void|Promise<void>)[]} cb
   */
  add(...e) {
    this.callbacks.push(...e);
  }
  run() {
    for (let e = 0; e < this.callbacks.length; e++)
      if (this.callbacks[e] !== null)
        try {
          this.callbacks[e](), this.callbacks[e] = null;
        } catch (t) {
          console.error("cleanup error:", t);
        }
    this.callbacks = this.callbacks.filter((e) => e !== null);
  }
}
const Mt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CleanUp: u,
  Events: g,
  createDraggable: St,
  createRipple: J,
  css: h,
  defaultRippleOptions: kt,
  html: a,
  isAndroid: Et
}, Symbol.toStringTag, { value: "Module" })), y = class y extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.ui = {
      root: this,
      get leftSlot() {
        return [...this.root.querySelectorAll('[slot="left"]')];
      },
      get centerSlot() {
        return [...this.root.querySelectorAll('[slot="center"]')];
      },
      get rightSlot() {
        return [...this.root.querySelectorAll('[slot="right"]')];
      },
      get position() {
        return this.root.getAttribute("position");
      },
      set position(e) {
        if (e || (e = y.defaultAttributes.position), !e) {
          this.root.removeAttribute("position");
          return;
        }
        this.root.setAttribute("position", e);
      }
    }, this.shadowRender(), this.render();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = a`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host {
                    display: flex !important;
                    position: absolute !important;
                    z-index: 100;
                    background-color: var(--ui-backdrop-bgColor);
                    -webkit-backdrop-filter: var(--ui-backdropFilter);
                    backdrop-filter: var(--ui-backdropFilter);
                    overflow: hidden;
                    user-select: none;
                }

                :host([position="top"]) {
                    top: 0;
                    left: 0;
                    right: 0;
                    height: var(--ui-app-bar-height);
                    border-bottom: 1px solid var(--ui-borderColor);
                    padding-left: var(--ui-spacing);
                    padding-right: var(--ui-spacing);
                }

                :host > ui-flex-grid-row {
                    width: 100%;
                    height: 100%;
                    align-items: center;
                    justify-content: space-between;
                }

                :host > ui-flex-grid-row > * {
                    height: 100%;
                }

                :host > ui-flex-grid-row > *:nth-child(1),
                :host > ui-flex-grid-row > *:nth-child(3) {
                    width: fit-content;
                }

                :host > ui-flex-grid-row > [slot="left"] {
                    margin-left: 0 !important;
                }

                :host > ui-flex-grid-row > [slot="center"] {
                    width: 100%;
                }

                :host > ui-flex-grid-row > [slot="right"] {
                    margin-right: 0 !important;
                    justify-content: flex-end;
                }
            </style>

            <ui-flex-grid-row gap="0.25rem">
                <ui-flex-grid-row gap="0.25rem">
                    <slot name="left"></slot>
                </ui-flex-grid-row>

                <ui-flex-grid-row gap="0.25rem" style="overflow: hidden;">
                    <slot name="center"></slot>
                </ui-flex-grid-row>

                <ui-flex-grid-row gap="0.25rem">
                    <slot name="right"></slot>
                </ui-flex-grid-row>
            </ui-flex-grid-row>
        `;
    for (const [e, t] of Object.entries(y.defaultAttributes))
      !this.hasAttribute(e) && t !== null && this.setAttribute(e, t);
  }
  render() {
  }
};
i(y, "register", () => {
  customElements.get("ui-app-bar") || customElements.define("ui-app-bar", y);
}), i(y, "defaultAttributes", {
  /** @type {string | null} */
  position: "top"
});
let X = y;
const k = class k extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.ui = {
      root: this,
      /**
       * @returns {T}
       */
      get child() {
        return this.root.querySelector("*");
      },
      /**
       * @param {string | null} [value]
       */
      show(e = null) {
        this.root.style.display = e;
      },
      hide() {
        this.root.style.display = "none";
      }
    }, this.shadowRender(), this.render();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = a`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host {
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    flex: 1;
                }
            </style>

            <slot></slot>
        `;
    for (const [e, t] of Object.entries(k.defaultAttributes))
      !this.hasAttribute(e) && t !== null && this.setAttribute(e, t);
  }
  render() {
  }
};
i(k, "register", () => {
  customElements.get("ui-app-bar-item") || customElements.define("ui-app-bar-item", k);
}), i(k, "defaultAttributes", {});
let Q = k;
const d = class d extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.renderCleanUp = new u(), this.removeRippleCallback = null, this.ui = {
      root: this,
      /**
       * @type {Events<UIButtonEvents>}
       */
      events: new g(),
      get noRipple() {
        return this.root.hasAttribute("no-ripple");
      },
      set noRipple(e) {
        if (e || (e = d.defaultAttributes.noRipple !== null), !e) {
          this.root.removeAttribute("no-ripple");
          return;
        }
        this.root.setAttribute("no-ripple", "");
      },
      get color() {
        return this.root.getAttribute("color");
      },
      set color(e) {
        if (e || (e = d.defaultAttributes.color), !e) {
          this.root.removeAttribute("color");
          return;
        }
        this.root.setAttribute("color", e);
      },
      get variant() {
        return this.root.getAttribute("variant");
      },
      set variant(e) {
        if (e || (e = d.defaultAttributes.variant), !e) {
          this.root.removeAttribute("variant");
          return;
        }
        this.root.setAttribute("variant", e);
      },
      get disabled() {
        return this.root.hasAttribute("disabled");
      },
      set disabled(e) {
        if (e || (e = d.defaultAttributes.disabled !== null), !e) {
          this.root.removeAttribute("disabled");
          return;
        }
        this.root.setAttribute("disabled", "");
      }
    }, this.shadowRender(), this.render();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = a`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host {
                    display: flex !important;
                    align-items: center;
                    justify-content: center;
                    position: relative !important;
                    padding: var(--ui-spacing) calc(var(--ui-spacing) * 2.5);
                    border: 1px solid currentColor;
                    border-radius: var(--ui-radius);
                    overflow: hidden;
                    text-transform: capitalize;
                    cursor: pointer;
                    outline: none;
                    user-select: none;
                    font-size: 1.1rem;
                    font-weight: 450;
                    font-family: var(--ui-fontFamily);
                    font-variation-settings: var(--ui-button-fontVariation);
                }

                :host([variant="full"]) {
                    border: none;
                }

                :host([variant="full"][color="primary"]) {
                    background-color: var(--ui-primary-bgColor);
                    color: var(--ui-primary-color);
                }

                :host([variant="full"][color="secondary"]) {
                    background-color: var(--ui-secondary-bgColor);
                    color: var(--ui-secondary-color);
                }

                :host([variant="full"][color="destructive"]) {
                    background-color: var(--ui-destructive-bgColor);
                    color: var(--ui-destructive-color);
                }

                :host([variant="outline"]) {
                    border-color: currentColor;
                    background-color: transparent;
                }

                :host([variant="outline"][color="primary"]) {
                    color: var(--ui-primary-bgColor);
                }

                :host([variant="outline"][color="secondary"]) {
                    color: var(--ui-secondary-bgColor);
                }

                :host([variant="outline"][color="destructive"]) {
                    color: var(--ui-destructive-bgColor);
                }

                :host([variant="ghost"]) {
                    border-color: transparent;
                    background-color: transparent;
                    font-weight: 900;
                }

                :host([variant="ghost"][color="primary"]) {
                    color: var(--ui-primary-bgColor);
                }

                :host([variant="ghost"][color="secondary"]) {
                    color: var(--ui-secondary-bgColor);
                }

                :host([variant="ghost"][color="destructive"]) {
                    color: var(--ui-destructive-bgColor);
                }

                :host([disabled]),
                :host([disabled]:hover),
                :host([disabled]:active) {
                    background-color: transparent;
                    opacity: 0.25;
                    cursor: default;
                    pointer-events: none;
                }
            </style>

            <slot></slot>
        `;
    for (const [e, t] of Object.entries(d.defaultAttributes))
      !this.hasAttribute(e) && t !== null && this.setAttribute(e, t);
  }
  render() {
    this.renderCleanUp.run(), this.setAttribute("role", "button");
    const e = async () => this.ui.events.dispatch("click", this);
    this.renderCleanUp.add(
      () => this.removeEventListener("click", e)
    ), this.addEventListener("click", e);
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(e, t, r) {
    switch (e) {
      case "no-ripple":
        r !== null ? typeof this.removeRippleCallback == "function" && (this.removeRippleCallback(), this.removeRippleCallback = null) : typeof this.removeRippleCallback == "function" && (this.removeRippleCallback = J(
          this,
          { centered: !0 }
        ));
        break;
    }
  }
};
i(d, "register", () => {
  customElements.get("ui-button") || customElements.define("ui-button", d);
}), i(d, "observedAttributes", ["no-ripple"]), i(d, "defaultAttributes", {
  /** @type {string | null} */
  color: null,
  /** @type {string | null} */
  disabled: null,
  /** @type {string | null} */
  noRipple: null,
  /** @type {string | null} */
  variant: null
});
let W = d;
const c = class c extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.renderCleanUp = new u(), this.removeRippleCallback = null, this.ui = {
      root: this,
      /**
       * @type {Events<UIIconButtonEvents>}
       */
      events: new g(),
      get noRipple() {
        return this.root.hasAttribute("no-ripple");
      },
      set noRipple(e) {
        if (e || (e = c.defaultAttributes.noRipple !== null), !e) {
          this.root.removeAttribute("no-ripple");
          return;
        }
        this.root.setAttribute("no-ripple", "");
      },
      get color() {
        return this.root.getAttribute("color");
      },
      set color(e) {
        if (e || (e = c.defaultAttributes.color), !e) {
          this.root.removeAttribute("color");
          return;
        }
        this.root.setAttribute("color", e);
      },
      get ghost() {
        return this.root.hasAttribute("ghost");
      },
      set ghost(e) {
        if (e || (e = c.defaultAttributes.ghost !== null), !e) {
          this.root.removeAttribute("ghost");
          return;
        }
        this.root.setAttribute("ghost", "");
      },
      get disabled() {
        return this.root.hasAttribute("disabled");
      },
      set disabled(e) {
        if (e || (e = c.defaultAttributes.disabled !== null), !e) {
          this.root.removeAttribute("disabled");
          return;
        }
        this.root.setAttribute("disabled", "");
      }
    }, this.shadowRender(), this.render();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = a`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host {
                    display: flex !important;
                    align-items: center;
                    justify-content: center;
                    position: relative;
                    width: 2.5rem;
                    height: 2.5rem;
                    padding: calc(var(--ui-spacing) / 2);
                    border: 1px solid currentColor;
                    border-radius: var(--ui-radius);
                    outline: none;
                    overflow: hidden;
                    cursor: pointer;
                    user-select: none;
                    font-size: 1.1rem;
                    font-weight: 450;
                    font-family: var(--ui-fontFamily);
                    font-variation-settings: var(--ui-button-fontVariation);
                }

                :host([ghost]) {
                    border-color: transparent !important;
                    box-shadow: none;
                    font-weight: 900;
                }

                :host([color="primary"]) {
                    color: var(--ui-primary-bgColor);
                    border-color: var(--ui-primary-bgColor);
                }

                :host([color="secondary"]) {
                    color: var(--ui-secondary-bgColor);
                    border-color: var(--ui-secondary-bgColor);
                }

                :host([color="destructive"]) {
                    color: var(--ui-destructive-bgColor);
                    border-color: var(--ui-destructive-bgColor);
                }

                /* :disabled */

                :host([disabled]),
                :host([disabled]:hover),
                :host([disabled]:active) {
                    opacity: 0.25;
                    cursor: default;
                    pointer-events: none;
                }
            </style>

            <ui-svg>
                <slot></slot>
            </ui-svg>
        `;
    for (const [e, t] of Object.entries(c.defaultAttributes))
      !this.hasAttribute(e) && t !== null && this.setAttribute(e, t);
  }
  render() {
    this.renderCleanUp.run(), this.setAttribute("role", "button");
    const e = async () => this.ui.events.dispatch("click", this);
    this.renderCleanUp.add(
      () => this.removeEventListener("click", e)
    ), this.addEventListener("click", e);
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(e, t, r) {
    switch (e) {
      case "no-ripple":
        r !== null ? typeof this.removeRippleCallback == "function" && (this.removeRippleCallback(), this.removeRippleCallback = null) : typeof this.removeRippleCallback == "function" && (this.removeRippleCallback = J(
          this,
          { centered: !0 }
        ));
        break;
    }
  }
};
i(c, "register", () => {
  customElements.get("ui-icon-button") || customElements.define("ui-icon-button", c);
}), i(c, "observedAttributes", ["no-ripple"]), i(c, "defaultAttributes", {
  /** @type {string | null} */
  color: null,
  /** @type {string | null} */
  disabled: null,
  /** @type {string | null} */
  ghost: null,
  /** @type {string | null} */
  noRipple: null
});
let B = c;
const C = class C extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.ui = {}, this.shadowRender(), this.render();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = a`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host {
                    display: block;
                    width: 100%;
                    max-width: 65rem;
                    margin: 0 auto !important;
                    padding: var(--ui-spacing);
                }
            </style>

            <slot></slot>
        `;
    for (const [e, t] of Object.entries(C.defaultAttributes))
      !this.hasAttribute(e) && t !== null && this.setAttribute(e, t);
  }
  render() {
  }
};
i(C, "register", () => {
  customElements.get("ui-container") || customElements.define("ui-container", C);
}), i(C, "defaultAttributes", {});
let _ = C;
const Rt = a`
    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
        <g
            id="SVGRepo_tracerCarrier"
            stroke-linecap="round"
            stroke-linejoin="round"
        ></g>
        <g id="SVGRepo_iconCarrier">
            <rect width="24" height="24" fill="none"></rect>
            <path
                d="M7 17L16.8995 7.10051"
                stroke="currentColor"
                stroke-linecap="round"
                stroke-linejoin="round"
            ></path>
            <path
                d="M7 7.00001L16.8995 16.8995"
                stroke="currentColor"
                stroke-linecap="round"
                stroke-linejoin="round"
            ></path>
        </g>
    </svg>
`, m = class m extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRenderCleanUp = new u(), this.ui = {
      root: this,
      /** @type {Events<T>} */
      events: new g(),
      get title() {
        return this.root.getAttribute("title");
      },
      set title(e) {
        this.root.setAttribute(
          "title",
          e || m.defaultAttributes.title
        );
      },
      get fullscreen() {
        return this.root.hasAttribute("fullscreen");
      },
      set fullscreen(e) {
        if (e || (e = m.defaultAttributes.fullscreen !== null), !e) {
          this.root.removeAttribute("fullscreen");
          return;
        }
        this.root.setAttribute("fullscreen", "");
      },
      /**
       * @param {boolean} modal
       * @param {boolean} [inert] - This will prevent the autofocus on input elements (default: true)
       */
      open(e = !1, t = !0) {
        const r = this.root.shadowRoot.querySelector("dialog"), o = r.inert;
        r.inert = t, e ? r.showModal() : r.show(), this.events.dispatch("open", null), r.inert = o;
      },
      close() {
        this.events.dispatch("close", null), this.root.shadowRoot.querySelector("dialog").close();
      }
    }, this.shadowRender(), this.render();
  }
  shadowRender() {
    this.shadowRenderCleanUp.run(), this.shadowRoot.innerHTML = a`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host dialog * {
                    box-sizing: border-box;
                }

                dialog {
                    position: fixed !important;

                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);

                    max-width: 100%;
                    max-height: 100%;

                    margin: 0;
                    padding: 0;

                    border: none;
                    outline: none;

                    background-color: transparent;

                    -ms-overflow-style: none;
                    scrollbar-width: none;

                    z-index: 999;
                }

                dialog::-webkit-scrollbar {
                    display: none;
                }

                dialog::backdrop {
                    background-color: var(--ui-backdrop-bgColor);
                    backdrop-filter: var(--ui-backdropFilter);
                }

                dialog > .container {
                    background-color: var(--ui-bgColor);
                    color: var(--ui-color);

                    border: 1px solid var(--ui-borderColor);
                    border-radius: var(--ui-radius);

                    padding: var(--ui-spacing);

                    display: flex;
                    flex-direction: column;
                    justify-content: space-between;

                    position: relative;
                }

                :host([fullscreen]) dialog {
                    width: 100%;
                    height: 100%;
                }

                :host([fullscreen]) dialog > .container {
                    width: calc(100% - var(--ui-spacing) * 2);
                    height: calc(
                        100% -
                            (
                                env(safe-area-inset-top, 0) +
                                    env(safe-area-inset-bottom, 0) +
                                    (var(--ui-spacing) * 2)
                            )
                    );

                    margin: var(--ui-spacing);
                    margin-top: calc(env(safe-area-inset-top, 0) + var(--ui-spacing));
                    margin-bottom: calc(
                        env(safe-area-inset-bottom, 0) + var(--ui-spacing)
                    );
                }

                /*
                * Header Styles
                */

                .header {
                    display: flex;
                    align-items: center;
                    justify-content: space-between;

                    border-top-right-radius: var(--ui-radius);
                    border-top-left-radius: var(--ui-radius);

                    width: 100%;
                    height: var(--ui-dialog-header-height);
                }

                .header h4 {
                    margin: auto 0;
                }

                :host([fullscreen]) .header {
                    z-index: 15;
                    position: absolute;
                    top: var(--ui-spacing);
                    right: var(--ui-spacing);
                    left: var(--ui-spacing);
                    width: calc(100% - var(--ui-spacing) * 2);
                }

                /*
                * Content Styles
                */

                .content {
                    padding: var(--ui-spacing);
                    height: fit-content;
                    min-width: fit-content;
                    width: 100%;
                }

                :host([fullscreen]) .content {
                    z-index: 10;
                    position: absolute;
                    top: calc(var(--ui-dialog-header-height) + var(--ui-spacing));
                    bottom: calc(var(--ui-dialog-footer-height) + var(--ui-spacing));
                    right: var(--ui-spacing);
                    left: var(--ui-spacing);
                    padding: unset;
                    height: unset;
                    width: unset;
                    min-width: unset;
                }

                /*
                * Footer Styles
                */

                .footer {
                    margin-top: var(--ui-spacing);
                    border-bottom-right-radius: var(--ui-radius);
                    border-bottom-left-radius: var(--ui-radius);

                    width: 100%;
                    height: var(--ui-dialog-footer-height);
                }

                :host([fullscreen]) .footer {
                    z-index: 15;
                    position: absolute;
                    right: var(--ui-spacing);
                    bottom: var(--ui-spacing);
                    left: var(--ui-spacing);
                    width: calc(100% - var(--ui-spacing) * 2);
                }

                .footer ui-flex-grid-row {
                    height: 100%;
                    flex-wrap: nowrap;
                    justify-content: flex-end;
                    align-items: center;
                }
            </style>

            <dialog>
                <div class="container">
                    <div class="header">
                        <span style="white-space: nowrap;">
                            <h3 name="title"></h3>
                        </span>

                        <ui-icon-button
                            style="width: var(--ui-dialog-header-height); height: 100%;"
                            ghost
                        >
                            ${Rt}
                        </ui-icon-button>
                    </div>

                    <div class="content">
                        <slot></slot>
                    </div>

                    <div class="footer">
                        <ui-flex-grid-row gap="calc(var(--ui-spacing) / 2)">
                            <slot name="actions"></slot>
                        </ui-flex-grid-row>
                    </div>
                </div>
            </dialog>
        `;
    for (const [n, l] of Object.entries(m.defaultAttributes))
      !this.hasAttribute(n) && l !== null && this.setAttribute(n, l);
    const e = this.shadowRoot.querySelector(".header ui-icon-button"), t = () => this.ui.close();
    e.addEventListener("click", t);
    const r = this.shadowRoot.querySelector("dialog"), o = (n) => n.preventDefault();
    r.addEventListener("cancel", o), this.shadowRenderCleanUp.add(() => {
      e.removeEventListener("click", t), r.removeEventListener("cancel", o);
    });
  }
  render() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(e, t, r) {
    switch (e) {
      case "title":
        const o = this.shadowRoot.querySelector('[name="title"]');
        o.innerHTML = r || "";
        break;
    }
  }
};
i(m, "register", () => {
  customElements.get("ui-dialog") || customElements.define("ui-dialog", m);
}), i(m, "observedAttributes", ["title"]), i(m, "defaultAttributes", {
  /** @type {string | null} */
  title: "",
  /** @type {string | null} */
  fullscreen: null
});
let U = m;
const A = class A extends HTMLElement {
  constructor() {
    super();
    i(this, "shadowCSS", () => h`
            * {
                box-sizing: border-box;
            }

            :host {
                display: block;

                position: absolute !important;
                z-index: 150;
                top: 0;
                left: -100%;
                width: 100%;
                height: 100%;

                overflow: hidden;

                transition: left 0s ease 0.5s;
            }

            :host([open]) {
                background-color: var(--ui-backdrop-bgColor);
                -webkit-backdrop-filter: var(--ui-backdropFilter);
                backdrop-filter: var(--ui-backdropFilter);

                left: 0;

                transition: none;
            }

            aside {
                position: absolute;
                z-index: 150;
                top: 0;
                left: -100%;
                width: var(--ui-drawer-width, fit-content);
                max-width: 100%;
                height: 100%;

                overflow-x: hidden;
                overflow-y: auto;
                scroll-behavior: smooth;

                -ms-overflow-style: none;
                scrollbar-width: none;

                background-color: var(--ui-card-bgColor);
                color: var(--ui-card-color);

                /*
                background-color: var(--ui-backdrop-bgColor);
                -webkit-backdrop-filter: var(--ui-backdropFilter);
                backdrop-filter: var(--ui-backdropFilter);
                */

                border-right: 1px solid var(--ui-card-borderColor);

                transition: left 0.5s ease;
            }

            aside::-webkit-scrollbar {
                display: none;
            }

            :host([open]) aside {
                left: 0;
            }
        `);
    i(this, "shadowTemplate", () => a`
        <aside>
            <slot></slot>
        </aside>
    `);
    this.attachShadow({ mode: "open" }), this.ui = {
      /** @private */
      root: this,
      cleanup: new u(),
      /**
       * @type {Events<UIDrawerEvents>}
       */
      events: new g(),
      getOpen() {
        return this.root.hasAttribute("open");
      },
      /**
       * @param {boolean} state
       */
      setOpen(t) {
        t ? this.root.setAttribute("open", "") : this.root.removeAttribute("open");
      }
    }, this.shadowRender();
  }
  disconnectedCallback() {
    this.ui.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, r, o) {
    switch (t) {
      case "open":
        o !== null ? this.ui.events.dispatch("open", this) : this.ui.events.dispatch("close", this);
        break;
    }
  }
  shadowRender() {
    this.shadowRoot.innerHTML = `
            <style>${this.shadowCSS().trim()}</style>
            ${this.shadowTemplate().trim()}
        `;
    const t = this.shadowRoot.querySelector("aside");
    this.addEventListener("click", () => {
      this.ui.setOpen(!1);
    }), t.addEventListener("click", (r) => {
      r.stopPropagation();
    });
  }
};
i(A, "register", () => {
  customElements.get("ui-drawer") || customElements.define("ui-drawer", A);
}), i(A, "observedAttributes", ["open"]);
let I = A;
const S = class S extends HTMLElement {
  constructor() {
    super();
    i(this, "shadowCSS", () => h`
        * {
            box-sizing: border-box;
        }

        ul {
            list-style: none;
            padding: var(--ui-spacing);
            overflow: hidden;
        }

        ui-drawer-group-item:not(.visible) {
            display: none;
        }
    `);
    i(this, "shadowTemplate", () => a`
        <ul>
            <ui-drawer-group-item class="ui-drawer-group-title">
            </ui-drawer-group-item>

            <slot></slot>
        </ul>
    `);
    this.attachShadow({ mode: "open" }), this.ui = {
      /** @private */
      root: this,
      cleanup: new u(),
      getTitle() {
        return this.root.getAttribute("title") || null;
      },
      /**
       * @param {string} value
       */
      setTitle(t) {
        let r = this.root.shadowRoot.querySelector(
          ".ui-drawer-group-title"
        );
        r.classList.add("visible"), r.innerHTML = `
                    <span
                        style="
                            font-size: 1.5rem;
                            font-weight: 600;
                            font-variation-settings: var(--ui-heading-fontVariation);
                        "
                    >
                        ${t}
                    </span>
                `;
      },
      removeTitle() {
        this.root.shadowRoot.querySelector(
          ".ui-drawer-group-title"
        ).classList.remove("visible");
      }
    }, this.shadowRender();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.ui.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, r, o) {
    switch (t) {
      case "title":
        o === "" ? this.removeAttribute("title") : o !== null ? this.ui.setTitle(o) : this.ui.removeTitle();
        break;
    }
  }
  shadowRender() {
    this.shadowRoot.innerHTML = `
            <style>${this.shadowCSS().trim()}</style>
            ${this.shadowTemplate().trim()}
        `;
  }
};
i(S, "register", () => {
  customElements.get("ui-drawer-group") || customElements.define("ui-drawer-group", S);
}), i(S, "observedAttributes", ["title"]);
let tt = S;
const P = class P extends HTMLElement {
  constructor() {
    super();
    i(this, "shadowCSS", () => h`
        * {
            box-sizing: border-box;
        }

        li {
            padding: var(--ui-spacing) calc(var(--ui-spacing) * 1.5);
            display: flex;
            flex-direction: row;
            flex-wrap: nowrap;
        }

        ::slotted(*) {
            width: 100%;
        }
    `);
    i(this, "shadowTemplate", () => a`
        <li>
            <slot></slot>
        </li>
    `);
    this.attachShadow({ mode: "open" }), this.ui = {
      cleanup: new u()
    }, this.shadowRender();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.ui.cleanup.run();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = `
            <style>${this.shadowCSS().trim()}</style>
            ${this.shadowTemplate().trim()}
        `;
  }
};
i(P, "register", () => {
  customElements.get("ui-drawer-group-item") || customElements.define("ui-drawer-group-item", P);
});
let et = P;
const f = class f extends HTMLElement {
  constructor() {
    super();
    /**
     * @param {Object} options
     * @param {string} options.flex
     */
    i(this, "shadowCSS", ({ flex: t }) => h`
        :host {
            flex: ${t};
        }
    `);
    i(this, "shadowTemplate", () => a`<slot></slot>`);
    this.attachShadow({ mode: "open" }), this.ui = {
      /** @private */
      root: this,
      cleanup: new u(),
      shadowAttr: {
        flex: f.defaultFlex
      },
      getFlex() {
        return this.shadowAttr.flex;
      },
      /**
       * @param {string | null} value
       */
      setFlex(t) {
        this.shadowAttr.flex = t || f.defaultFlex, this.root.shadowRender({ ...this.shadowAttr });
      }
    }, this.shadowRender({ ...this.ui.shadowAttr });
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.ui.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, r, o) {
    switch (t) {
      case "flex":
        this.ui.setFlex(o);
        break;
    }
  }
  /**
   * @param {Object} options
   * @param {string} options.flex
   */
  shadowRender({ flex: t }) {
    this.shadowRoot.innerHTML = `
            <style>${this.shadowCSS({ flex: t }).trim()}</style>
            ${this.shadowTemplate().trim()}
        `;
  }
};
i(f, "register", () => {
  customElements.get("ui-flex-grid-item") || customElements.define("ui-flex-grid-item", f);
}), i(f, "observedAttributes", ["flex"]), i(f, "defaultFlex", "1");
let it = f;
const v = class v extends HTMLElement {
  constructor() {
    super();
    /**
     * @param {Object} options
     * @param {string} options.gap
     */
    i(this, "shadowCSS", ({ gap: t }) => h`
        :host {
            display: flex !important;
            flex-flow: row nowrap;
            position: relative !important;
            width: 100%;
        }

        :host > ::slotted(*) {
            margin: 0 ${t} !important;
        }

        :host > ::slotted(*:first-child) {
            margin-left: 0 !important;
        }

        :host > ::slotted(*:last-child) {
            margin-right: 0 !important;
        }
    `);
    i(this, "shadowTemplate", () => a`<slot></slot>`);
    this.attachShadow({ mode: "open" }), this.ui = {
      /** @private */
      root: this,
      cleanup: new u(),
      shadowAttr: {
        gap: v.defaultGap
      },
      getGap() {
        return this.shadowAttr.gap;
      },
      /**
       * @param {string | null} value
       */
      setGap(t) {
        this.shadowAttr.gap = t || v.defaultGap, this.root.shadowRender({ ...this.shadowAttr });
      }
    }, this.shadowRender({ ...this.ui.shadowAttr });
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.ui.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, r, o) {
    switch (t) {
      case "gap":
        this.ui.setGap(o);
        break;
    }
  }
  /**
   * @param {Object} options
   * @param {string} options.gap
   */
  shadowRender({ gap: t }) {
    this.shadowRoot.innerHTML = `
            <style>${this.shadowCSS({ gap: t }).trim()}</style>
            ${this.shadowTemplate().trim()}
        `;
  }
};
i(v, "register", () => {
  customElements.get("ui-flex-grid-row") || customElements.define("ui-flex-grid-row", v);
}), i(v, "observedAttributes", ["gap"]), i(v, "defaultGap", "0");
let rt = v;
const w = class w extends HTMLElement {
  constructor() {
    super();
    /**
     * @param {Object} options
     * @param {string} options.gap
     */
    i(this, "shadowCSS", ({ gap: t }) => h`
        :host {
            display: flex !important;
            flex-flow: column nowrap;
            position: relative !important;
            width: 100%;
            height: fit-content;
        }

        :host > ::slotted(*) {
            margin: ${t} 0 !important;
        }

        :host > ::slotted(*:first-child) {
            margin-top: 0 !important;
        }

        :host > ::slotted(*:last-child) {
            margin-bottom: 0 !important;
        }
    `);
    i(this, "shadowTemplate", () => a`<slot></slot>`);
    this.attachShadow({ mode: "open" }), this.ui = {
      /**
       * @private
       */
      root: this,
      cleanup: new u(),
      shadowAttr: {
        gap: w.defaultGap
      },
      getGap() {
        return this.shadowAttr.gap;
      },
      /**
       * @param {string | null} value
       */
      setGap(t) {
        this.shadowAttr.gap = t || w.defaultGap, this.root.shadowRender({ ...this.shadowAttr });
      }
    }, this.shadowRender({ ...this.ui.shadowAttr });
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.ui.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, r, o) {
    switch (t) {
      case "gap":
        this.ui.setGap(o);
        break;
    }
  }
  /**
   * @param {Object} options
   * @param {string} options.gap
   */
  shadowRender({ gap: t }) {
    this.shadowRoot.innerHTML = `
            <style>${this.shadowCSS({ gap: t }).trim()}</style>
            ${this.shadowTemplate().trim()}
        `;
  }
};
i(w, "register", () => {
  customElements.get("ui-flex-grid") || customElements.define("ui-flex-grid", w);
}), i(w, "observedAttributes", ["gap"]), i(w, "defaultGap", "0");
let ot = w;
const V = class V extends HTMLElement {
  constructor() {
    super();
    i(this, "shadowCSS", () => h`
        :host {
            font-size: 1.1rem;
            font-family: var(--ui-fontFamily);
            font-variation-settings: var(--ui-text-primary-fontVariation);
        }
    `);
    i(this, "shadowTemplate", () => a`<slot></slot>`);
    this.attachShadow({ mode: "open" }), this.ui = {
      cleanup: new u()
    }, this.shadowRender();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.ui.cleanup.run();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = `
            <style>${this.shadowCSS().trim()}</style>
            ${this.shadowTemplate().trim()}
        `;
  }
};
i(V, "register", () => {
  customElements.get("ui-primary") || customElements.define("ui-primary", V);
});
let q = V;
const F = class F extends HTMLElement {
  constructor() {
    super();
    i(this, "shadowCSS", () => h`
        :host {
            font-size: 0.9rem;
            font-family: var(--ui-fontFamily);
            font-variation-settings: var(--ui-text-secondary-fontVariation);
        }
    `);
    i(this, "shadowTemplate", () => a`<slot></slot>`);
    this.attachShadow({ mode: "open" }), this.ui = {
      cleanup: new u()
    }, this.shadowRender();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.ui.cleanup.run();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = `
            <style>${this.shadowCSS().trim()}</style>
            ${this.shadowTemplate().trim()}
        `;
  }
};
i(F, "register", () => {
  customElements.get("ui-secondary") || customElements.define("ui-secondary", F);
});
let x = F;
const E = class E extends HTMLElement {
  constructor() {
    super();
    i(this, "shadowCSS", () => h`
        * {
            box-sizing: border-box;
        }

        :host {
            position: relative !important;
            display: flex !important;
            flex-direction: row;
            width: 100%;
            padding: var(--ui-spacing);
            border-radius: var(--ui-radius);
        }

        :host > .text {
            display: flex;
            flex: 1;
            flex-direction: column;
            justify-content: center;
            margin-right: var(--ui-spacing);
        }

        :host > .input {
            display: flex;
            align-items: center;
            justify-content: flex-end;
        }
    `);
    i(this, "shadowTemplate", () => a`
        <span class="text">
            <ui-primary></ui-primary>
            <ui-secondary></ui-secondary>
        </span>

        <span class="input">
            <slot name="input"></slot>
            <slot></slot>
        </span>
    `);
    this.attachShadow({ mode: "open" }), this.ui = {
      /** @private */
      root: this,
      cleanup: new u(),
      /** @private */
      running: !1,
      /**
       * @private
       * @type {(() => void|Promise<void>) | null}
       */
      removeRipple: null,
      /** @private */
      onClick: async () => {
        this.ui.getInputSlot().forEach((t) => t.click());
      },
      /** @private */
      onInputClick: async (t) => {
        t.stopPropagation();
      },
      getPrimary() {
        return this.root.getAttribute("primary");
      },
      /**
       * @param {string | null} value
       */
      setPrimary(t) {
        if (t === null) {
          this.root.removeAttribute("primary");
          return;
        }
        this.root.setAttribute("primary", t);
      },
      getSecondary() {
        return this.root.getAttribute("secondary");
      },
      /**
       * @param {string | null} value
       */
      setSecondary(t) {
        if (t === null) {
          this.root.removeAttribute("secondary");
          return;
        }
        this.root.setAttribute("secondary", t);
      },
      /**
       * @returns {HTMLElement[]}
       */
      getInputSlot() {
        return [...this.root.querySelectorAll('[slot="input"]')];
      },
      enableRipple() {
        this.removeRipple || (this.removeRipple = J(this.root), this.root.style.cursor = "pointer", this.startInputHandling());
      },
      disableRipple() {
        this.removeRipple && this.removeRipple(), this.stopInputHandling();
      },
      /** @private */
      startInputHandling() {
        this.running || (this.root.addEventListener("click", this.onClick), this.getInputSlot().forEach((t) => {
          t.addEventListener("click", this.onInputClick);
        }), this.running = !0);
      },
      /**
       * @private
       */
      stopInputHandling() {
        this.root.removeEventListener("click", this.onClick), this.getInputSlot().forEach((t) => {
          t.removeEventListener("click", this.onInputClick);
        }), this.running = !1;
      }
    }, this.shadowRender();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.ui.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, r, o) {
    switch (t) {
      case "ripple":
        o !== null ? this.ui.enableRipple() : this.ui.disableRipple();
        break;
      case "primary":
        this.shadowRoot.querySelector("ui-primary").innerHTML = o || "";
        break;
      case "secondary":
        this.shadowRoot.querySelector("ui-secondary").innerHTML = o || "";
        break;
    }
  }
  shadowRender() {
    this.shadowRoot.innerHTML = `
            <style>${this.shadowCSS().trim()}</style>
            ${this.shadowTemplate().trim()}
        `;
  }
};
i(E, "register", () => {
  q.register(), x.register(), customElements.get("ui-label") || customElements.define("ui-label", E);
}), i(E, "observedAttributes", ["ripple", "secondary", "primary"]);
let st = E;
const R = class R extends HTMLElement {
  constructor() {
    super();
    i(this, "shadowCSS", () => h`
        * {
            box-sizing: border-box;
        }

        :host {
            display: block;
            position: relative;
            width: 100%;
            height: fit-content;
        }

        input {
            width: 100%;
            display: block;
            margin: 0;
            padding: var(--ui-spacing) calc(var(--ui-spacing) * 2);
            border: none !important;
            border-radius: inherit;
            outline: none !important;
            font-size: 0.9rem;
            font-family: var(--ui-fontFamily);
            font-variation-settings: var(--ui-input-fontVariation);
            accent-color: var(--ui-primary-bgColor);
            background-color: transparent !important;
        }

        .container {
            width: 100%;
            border: none;
            border: 1px solid var(--ui-borderColor);
            border-radius: var(--ui-radius);
            transition: border-color 0.25s linear;
        }

        .container:has(input:focus) {
            border-color: var(--ui-primary-bgColor);
        }

        :host([invalid]) .container {
            border-color: var(--ui-destructive-bgColor);
        }

        ::slotted([slot="title"]) {
            display: block;
            padding: 0 var(--ui-spacing);
            user-select: none;
            transform: translateY(calc(var(--ui-spacing) / 2));
        }
    `);
    i(this, "shadowTemplate", () => a`
        <div class="container">
            <slot name="title"></slot>
            <input />
        </div>
    `);
    this.attachShadow({ mode: "open" }), this.ui = {
      /** @private */
      root: this,
      cleanup: new u(),
      /** @type {HTMLInputElement | null} */
      input: null,
      /**
       * @type {Events<E>}
       */
      events: new g(),
      /**
       * @param {string | null} v
       */
      setTitle(t) {
        if (t === null) {
          this.root.removeAttribute("title");
          return;
        }
        this.root.setAttribute("title", t);
      },
      getTitle() {
        return this.root.getAttribute("title");
      },
      /**
       * @param {UIInputTypes | null} value
       */
      setType(t) {
        if (t === null) {
          this.root.removeAttribute("type");
          return;
        }
        this.root.setAttribute("type", t);
      },
      /**
       * @returns {UIInputTypes}
       */
      getType() {
        return this.root.getAttribute("type") || "text";
      },
      /**
       * @param {UIInputTypeValues[T] | null} value
       */
      setValue(t) {
        this.input.value = (t || "").toString();
      },
      /**
       * @returns {UIInputTypeValues[T]}
       */
      getValue() {
        const t = this.input.value;
        switch (this.getType()) {
          case "number":
            return t ? parseFloat(t) : NaN;
          default:
            return t;
        }
      },
      /**
       * @param {string | null} value
       */
      setPlaceholder(t) {
        if (t === null) {
          this.root.removeAttribute("placeholder");
          return;
        }
        this.root.setAttribute("placeholder", t);
      },
      /**
       * @returns {string}
       */
      getPlaceholder() {
        return this.root.getAttribute("placeholder");
      },
      /**
       * @param {boolean} state
       */
      setInvalid(t) {
        if (t === null || t === !1) {
          this.root.removeAttribute("invalid");
          return;
        }
        this.root.setAttribute("invalid", "");
      },
      /**
       * @returns {boolean}
       */
      getInvalid() {
        return this.root.hasAttribute("invalid");
      },
      /**
       * @param {UIInputTypeValues[T] | null} n
       */
      setMin(t) {
        if (t === null) {
          this.root.removeAttribute("min");
          return;
        }
        this.root.setAttribute("min", t.toString());
      },
      /**
       * @returns {UIInputTypeValues[T]}
       */
      getMin() {
        const t = this.root.getAttribute("min");
        switch (this.input.type) {
          case "number":
            return t ? parseFloat(t) : NaN;
          default:
            return t;
        }
      },
      /**
       * @param {UIInputTypeValues[T] | null} n
       */
      setMax(t) {
        t === null && this.root.removeAttribute("max"), this.root.setAttribute("max", t.toString());
      },
      /**
       * @returns {UIInputTypeValues[T]}
       */
      getMax() {
        const t = this.root.getAttribute("max");
        switch (this.input.type) {
          case "number":
            return t ? parseFloat(t) : NaN;
          default:
            return t;
        }
      }
    }, this.shadowRender();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.ui.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, r, o) {
    switch (t) {
      case "title":
        let n = this.querySelector('[slot="title"]');
        if (o === null && n && (this.removeChild(n), n = null), o === null)
          return;
        n || (n = new x(), n.slot = "title", this.appendChild(n)), n.innerHTML = o;
        break;
      case "type":
        this.ui.input.type = o || "text";
        break;
      case "value":
        this.ui.setValue(o);
        break;
      case "placeholder":
        this.ui.input.placeholder = o || "";
        break;
      case "invalid":
        this.ui.input.ariaInvalid = o;
        break;
      case "min":
        this.ui.input.min = o || "";
        break;
      case "max":
        this.ui.input.max = o || "";
        break;
    }
  }
  shadowRender() {
    this.shadowRoot.innerHTML = `
            <style>${this.shadowCSS().trim()}</style>
            ${this.shadowTemplate().trim()}
        `, this.ui.input = this.shadowRoot.querySelector("input"), this.ui.input.type = this.getAttribute("type") || "text", this.ui.input.oninput = () => this.ui.events.dispatch("input", this.ui.getValue()), this.ui.input.onchange = () => this.ui.events.dispatch("change", this.ui.getValue());
  }
  /**
   * @param {FocusOptions | null} [options]
   */
  focus(t = null) {
    this.shadowRoot.querySelector("input").focus(t);
  }
  blur() {
    this.shadowRoot.querySelector("input").blur();
  }
};
i(R, "register", () => {
  customElements.get("ui-input") || customElements.define("ui-input", R);
}), i(R, "observedAttributes", [
  "title",
  "type",
  "value",
  "placeholder",
  "invalid",
  "min",
  "max"
]);
let nt = R;
const Tt = a`
    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
        <g
            id="SVGRepo_tracerCarrier"
            stroke-linecap="round"
            stroke-linejoin="round"
        ></g>
        <g id="SVGRepo_iconCarrier">
            <rect width="24" height="24" fill="none"></rect>
            <path
                d="M17 9.5L12 14.5L7 9.5"
                stroke="currentColor"
                stroke-linecap="round"
                stroke-linejoin="round"
            ></path>
        </g>
    </svg>
`, O = class O extends HTMLElement {
  constructor() {
    super();
    i(this, "shadowCSS", () => h`
        :host {
            display: none;
            align-items: center;

            padding: var(--ui-spacing);
            padding-right: 2.5rem;

            height: calc(1em * var(--ui-lineHeight) + var(--ui-spacing) * 2);

            white-space: nowrap;
            text-overflow: ellipsis;

            transition:
                background-color 0.25s linear,
                color 0.25s linear;

            overflow: hidden;
        }
    `);
    i(this, "shadowTemplate", () => a`<slot></slot>`);
    this.attachShadow({ mode: "open" }), this.setAttribute("role", "button"), this.ui = {
      /** @private */
      root: this,
      getValue() {
        return this.root.getAttribute("value");
      },
      /**
       * @param {string | null} value
       */
      setValue(t) {
        if (t === null) {
          this.root.removeAttribute("value");
          return;
        }
        this.root.setAttribute("value", t);
      },
      getSelected() {
        return this.root.hasAttribute("selected");
      },
      /**
       * @param {boolean} state
       */
      setSelected(t) {
        if (!t) {
          this.root.removeAttribute("selected");
          return;
        }
        this.root.setAttribute("selected", "");
      }
    }, this.shadowRender();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = `
            <style>${this.shadowCSS().trim()}</style>
            ${this.shadowTemplate().trim()}
        `;
  }
};
i(O, "register", () => {
  customElements.get("ui-select-option") || customElements.define("ui-select-option", O);
});
let z = O;
const N = class N extends HTMLElement {
  constructor() {
    super();
    i(this, "shadowCSS", () => h`
        * {
            box-sizing: border-box;
        }

        :host {
            --ui-bgColor: "transparent";
            --items-length: 0;

            position: relative !important;
            display: block !important;

            width: 100%;
            height: calc(1em * var(--ui-lineHeight) + var(--ui-spacing) * 2);
            transition: height 0.25s ease;

            background-color: var(--ui-bgColor);
            color: var(--ui-color);

            border: 1px solid var(--ui-borderColor);
            border-radius: var(--ui-radius);

            line-height: 1.15;

            overflow: hidden;

            font-size: 0.9rem;
            font-family: var(--ui-fontFamily);
            font-variation-settings: var(--ui-select-fontVariation);
        }

        .options {
            cursor: pointer;
            display: none;
            display: flex;
            flex-direction: column;
            min-height: 100%;
        }

        .icon {
            display: flex;
            justify-content: center;
            align-items: center;
            position: absolute;
            top: 0;
            right: 0;
            width: 2.5rem;
            height: 100%;
            color: var(--ui-primary-bgColor);
        }

        ::slotted(ui-select-option) {
            display: flex;
        }

        :host(.open) {
            height: calc(
                (1em * var(--ui-lineHeight) + var(--ui-spacing) * 2) *
                    var(--items-length)
            );
        }

        :host(.open) .options {
            display: block;
        }

        :host(.open) .icon {
            display: none;
        }

        :host(.open) ::slotted(ui-select-option[selected]) {
            background-color: var(--ui-primary-bgColor);
            color: var(--ui-primary-color);
        }

        :host(.open) ::slotted(ui-select-option:not([selected]):hover) {
            background-color: hsla(var(--ui-color-hsl), 0.1);
        }

        :host(:not(.open))
            .options:has(> ::slotted(ui-select-option[selected])) {
            display: block;
        }

        :host(:not(.open)) ::slotted(ui-select-option:not([selected])) {
            display: none;
        }
    `);
    i(this, "shadowTemplate", () => a`
        <div class="options">
            <div class="icon"><ui-svg>${Tt}</ui-svg></div>

            <slot></slot>
        </div>
    `);
    this.attachShadow({ mode: "open" }), this.ui = {
      /**
       * @private
       */
      root: this,
      cleanup: new u(),
      /**
       *  @type {Events<UISelectEvents>}
       */
      events: new g(),
      isOpen() {
        this.root.hasAttribute("open");
      },
      open() {
        this.root.setAttribute("open", "");
      },
      close() {
        this.root.removeAttribute("open");
      },
      /**
       * @returns {UISelectOption[]}
       */
      getOptions() {
        return [...this.root.children].filter(
          (t) => t instanceof z
        );
      },
      /**
       * @returns {UISelectOption | null}
       */
      getSelectedOption() {
        try {
          return this.getOptions().find(
            (t) => !!t.ui.getSelected()
          ) || null;
        } catch {
          return null;
        }
      }
    }, this.cleanup = new u(), this.shadowRender();
  }
  connectedCallback() {
    const t = this.shadowRoot.querySelector(".options"), r = async (n) => {
      (n.composedPath() || []).forEach((l) => {
        l instanceof z && ([...this.querySelectorAll("ui-select-option")].forEach(
          (Z) => Z.removeAttribute("selected")
        ), l.setAttribute("selected", ""), this.ui.events.dispatch("change", l));
      });
    }, o = (n) => {
      this.classList.toggle("open") ? (n.stopPropagation(), this.addEventListener("click", r)) : setTimeout(
        () => this.removeEventListener("click", r)
      );
    };
    t.addEventListener("click", o), this.cleanup.add(() => {
      this.removeEventListener("click", o), t.removeEventListener("click", o);
    }), this.style.setProperty(
      "--items-length",
      this.querySelectorAll("ui-select-option").length.toString()
    );
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = `
            <style>${this.shadowCSS().trim()}</style>
            ${this.shadowTemplate().trim()}
        `;
  }
};
i(N, "register", () => {
  customElements.get("ui-select") || customElements.define("ui-select", N);
});
let at = N;
const Lt = a`
    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
        <g
            id="SVGRepo_tracerCarrier"
            stroke-linecap="round"
            stroke-linejoin="round"
        ></g>
        <g id="SVGRepo_iconCarrier">
            <g clip-path="url(#clip0_15_152)">
                <rect width="24" height="24" fill="none"></rect>
                <circle
                    cx="10.5"
                    cy="10.5"
                    r="6.5"
                    stroke="currentColor"
                    stroke-linejoin="round"
                ></circle>
                <path
                    d="M19.6464 20.3536C19.8417 20.5488 20.1583 20.5488 20.3536 20.3536C20.5488 20.1583 20.5488 19.8417 20.3536 19.6464L19.6464 20.3536ZM20.3536 19.6464L15.3536 14.6464L14.6464 15.3536L19.6464 20.3536L20.3536 19.6464Z"
                    fill="currentColor"
                ></path>
            </g>
            <defs>
                <clipPath id="clip0_15_152">
                    <rect width="24" height="24" fill="none"></rect>
                </clipPath>
            </defs>
        </g>
    </svg>
`, T = class T extends HTMLElement {
  constructor() {
    super();
    i(this, "shadowCSS", () => h`
        * {
            box-sizing: border-box;
        }

        :host {
            display: block;
            position: relative;
            width: 100%;
            height: fit-content;
        }

        input {
            width: 100%;
            display: block;
            margin: 0;
            padding: var(--ui-spacing) calc(var(--ui-spacing) * 2);
            border: none !important;
            border-radius: inherit;
            outline: none !important;
            font-size: 0.9rem;
            font-family: var(--ui-fontFamily);
            font-variation-settings: var(--ui-input-fontVariation);
            accent-color: var(--ui-primary-bgColor);
            background-color: transparent !important;
        }

        :host(:not([no-submit])) input {
            width: calc(100% - 2rem);
        }

        .container {
            position: relative;
            width: 100%;
            border: none;
            border: 1px solid var(--ui-borderColor);
            border-radius: var(--ui-radius);
            transition: border-color 0.25s linear;
            background-color: var(--ui-backdrop-bgColor);
            -webkit-backdrop-filter: var(--ui-backdropFilter);
            backdrop-filter: var(--ui-backdropFilter);
        }

        .container:has(input:focus) {
            border-color: var(--ui-primary-bgColor);
        }

        :host([invalid]) .container {
            border-color: var(--ui-destructive-bgColor);
        }

        ::slotted([slot="title"]) {
            display: block;
            padding: 0 var(--ui-spacing);
            user-select: none;
            transform: translateY(calc(var(--ui-spacing) / 2));
        }

        ui-icon-button {
            position: absolute;
            top: 0;
            right: 0;
            height: 100%;
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }
    `);
    i(this, "shadowTemplate", () => a`
        <div class="container">
            <slot name="title"></slot>
            <input type="search" />
            <ui-icon-button ghost>${Lt}</ui-icon-button>
        </div>
    `);
    this.attachShadow({ mode: "open" }), this.ui = {
      /** @private */
      root: this,
      cleanup: new u(),
      /**
       * @type {boolean}
       */
      useStorage: !1,
      /**
       * @type {string | null}
       */
      storagePrefix: null,
      /** @type {UIIconButton | null} */
      submit: null,
      /** @type {HTMLInputElement | null} */
      input: null,
      /** @type {Events<E>} */
      events: new g(),
      /**
       * Used as storage key, if enabled
       *
       *  @param {string | null} value
       */
      setKey(t) {
        if (t === null) {
          this.root.removeAttribute("key"), this.setValue("");
          return;
        }
        this.root.setAttribute("key", t), this.setValue(
          localStorage.getItem(this.storagePrefix + this.getKey())
        );
      },
      getKey() {
        return this.root.getAttribute("key") || "";
      },
      hasSubmit() {
        return !!this.submit.parentElement;
      },
      disableSubmit() {
        this.hasSubmit() && this.submit.parentElement.removeChild(this.submit);
      },
      enableSubmit() {
        if (!this.hasSubmit()) return;
        this.root.shadowRoot.querySelector(".container").appendChild(this.submit);
      },
      /**
       * @param {string | null} value
       */
      setTitle(t) {
        t === null ? this.root.removeAttribute("title") : this.root.setAttribute("title", t);
      },
      getTitle() {
        return this.root.getAttribute("title");
      },
      /**
       * @param {string | null} value
       */
      setValue(t) {
        this.input.value = t || "";
      },
      getValue() {
        return this.input.value;
      },
      /**
       * @param {string | null} value
       */
      setPlaceholder(t) {
        if (t === null) {
          this.root.removeAttribute("placeholder");
          return;
        }
        this.root.setAttribute("placeholder", t);
      },
      /**
       * @returns {string}
       */
      getPlaceholder() {
        return this.root.getAttribute("placeholder");
      },
      /**
       * @param {boolean} state
       */
      setInvalid(t) {
        if (t === null || t === !1) {
          this.root.setAttribute("invalid", "");
          return;
        }
        this.root.removeAttribute("invalid");
      },
      /**
       * @returns {boolean}
       */
      getInvalid() {
        return this.root.hasAttribute("invalid");
      }
    }, this.shadowRender();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.ui.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, r, o) {
    switch (t) {
      case "title":
        let n = this.querySelector('[slot="title"]');
        o === null && n && (this.removeChild(n), n = null), n || (n = new x(), n.slot = "title", this.appendChild(n)), n.innerHTML = o || "";
        break;
      case "value":
        this.ui.setValue(o);
        break;
      case "placeholder":
        this.ui.input.placeholder = o || "";
        break;
      case "invalid":
        this.ui.input.ariaInvalid = o !== null ? "" : null;
        break;
      case "no-submit":
        o !== null ? this.ui.disableSubmit() : this.ui.enableSubmit();
        break;
      case "use-storage":
        this.ui.useStorage = o !== null;
        break;
      case "storage-prefix":
        this.ui.storagePrefix = o;
        break;
    }
  }
  shadowRender() {
    this.shadowRoot.innerHTML = `
            <style>${this.shadowCSS().trim()}</style>
            ${this.shadowTemplate().trim()}
        `, this.ui.submit = this.shadowRoot.querySelector("ui-icon-button"), this.ui.submit.ui.events.on("click", () => {
      this.ui.events.dispatch("submit", this.ui.getValue());
    });
    {
      this.ui.input = this.shadowRoot.querySelector("input"), this.ui.input.type = "text", this.ui.input.onkeydown = async (r) => {
        this.ui.hasSubmit() && r.key === "Enter" && this.ui.submit.click();
      }, this.ui.input.oninput = async () => {
        this.ui.useStorage && (t !== null && clearTimeout(t), t = setTimeout(() => {
          localStorage.setItem(
            (this.ui.storagePrefix || "") + this.ui.getKey(),
            this.ui.input.value
          ), t = null;
        }, 250)), this.ui.events.dispatch("input", this.ui.input.value);
      };
      let t = null;
      this.ui.input.onchange = async () => this.ui.events.dispatch("change", this.ui.input.value);
    }
  }
  /**
   * @param {FocusOptions | null} [options]
   */
  focus(t = null) {
    this.shadowRoot.querySelector("input").focus(t);
  }
  blur() {
    this.shadowRoot.querySelector("input").blur();
  }
};
i(T, "register", () => {
  customElements.get("ui-search") || customElements.define("ui-search", T);
}), i(T, "observedAttributes", [
  "title",
  "value",
  "placeholder",
  "invalid",
  "no-submit",
  "use-storage",
  "storage-prefix"
]);
let lt = T;
const D = class D extends HTMLElement {
  constructor() {
    super(), this.ui = {
      /** @private */
      root: this,
      getName() {
        return this.root.getAttribute("name");
      },
      /**
       * @param {string | null} value
       */
      setName(e) {
        if (e === null) {
          this.root.removeAttribute("name");
          return;
        }
        this.root.setAttribute("name", e);
      },
      getHref() {
        return this.root.getAttribute("href");
      },
      /**
       * @param {string | null} value
       */
      setHref(e) {
        if (e === null) {
          this.root.removeAttribute("href");
          return;
        }
        this.root.setAttribute("href", e);
      },
      getFallback() {
        return this.root.hasAttribute("fallback");
      },
      /**
       * @param {boolean} state
       */
      setFallback(e) {
        if (!e) {
          this.root.removeAttribute("fallback");
          return;
        }
        this.root.setAttribute("fallback", "");
      }
    };
  }
};
i(D, "register", () => {
  customElements.get("ui-lang-type") || customElements.define("ui-lang-type", D);
});
let ut = D;
const L = class L extends HTMLElement {
  constructor() {
    super(), this.ui = {
      /** @private */
      root: this,
      /**
       * @private
       * @type {Events<{ "change": UILangType}>}
       */
      events: new g(),
      /**
       * @type {{
       *  [key: string]: {
       *      [key: string]: string;
       *  };
       * }}
       */
      data: {},
      /**
       *@type {UILangType | null}
       */
      langType: null,
      getCurrent() {
        return this.root.getAttribute("current");
      },
      /**
       * @param {string | null} v
       */
      setCurrent(e) {
        if (e === null) {
          this.root.removeAttribute("current");
          return;
        }
        this.root.setAttribute("current", e);
      },
      /**
       * @returns {UILangType}
       */
      getFallbackElement() {
        return this.root.querySelector("ui-lang-type[fallback]");
      },
      /**
       * @param {UILangType} langType
       * @param {{
       *  [key: string]: {
       *      [key: string]: string;
       *  };
       * }} data
       */
      new(e, t) {
        this.langType = e, this.data = t, this.events.dispatch("change", this.langType);
      },
      /**
       * @param {string} group
       * @param {string} key
       */
      get(e, t) {
        var r, o;
        return ((o = (r = this.data) == null ? void 0 : r[e]) == null ? void 0 : o[t]) || null;
      },
      /**
       * @param {"change"} key
       * @param {(langType: UILangType | null) => void|Promise<void>} callback
       * @param {boolean} [trigger] - this will run the callback first
       * @returns {() => void} clean up function
       */
      on(e, t, r = !1) {
        if (typeof t != "function")
          throw "callback is not a function";
        return r && t(this.langType), this.events.on(e, t);
      }
    };
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(e, t, r) {
    switch (e) {
      case "current":
        r !== null && this.loadLanguage(r);
        break;
    }
  }
  /**
   * @private
   * @param {string} name
   */
  async loadLanguage(e) {
    const t = this.querySelector(`ui-lang-type[name="${e}"]`) || this.ui.getFallbackElement();
    if (!t) return;
    if (!t.ui.getHref()) throw "Missing href attribute!";
    const r = await fetch(t.ui.getHref());
    this.ui.new(t, await r.json());
  }
};
i(L, "register", () => {
  customElements.get("ui-lang") || customElements.define("ui-lang", L);
}), i(L, "observedAttributes", ["current"]);
let ht = L;
const G = class G extends HTMLElement {
  constructor() {
    super();
    i(this, "shadowCSS", () => h`
        :host {
            position: absolute;
            width: 100%;
            height: 100%;
        }

        .background {
            z-index: 999;
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            background-color: var(--ui-backdrop-bgColor);
            -webkit-backdrop-filter: var(--ui-backdropFilter);
            backdrop-filter: var(--ui-backdropFilter);
        }

        .spinner {
            z-index: 1000;
            content: "";
            box-sizing: border-box;
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2.5rem;
            height: 2.5rem;
            margin-top: -1.25rem;
            margin-left: -1.25rem;
            border-radius: 50%;
            border: 2px solid var(--ui-borderColor);
            border-top-color: var(--ui-primary-bgColor);
            animation: spinner 0.6s linear infinite;
        }

        @keyframes spinner {
            to {
                transform: rotate(360deg);
            }
        }
    `);
    i(this, "shadowTemplate", () => a`
        <div class="background"></div>
        <div class="spinner"></div>
    `);
    this.attachShadow({ mode: "open" }), this.ui = {
      cleanup: new u()
    }, this.shadowRender();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.ui.cleanup.run();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = `
            <style>${this.shadowCSS().trim()}</style>
            ${this.shadowTemplate().trim()}
        `;
  }
};
i(G, "register", () => {
  customElements.get("ui-spinner") || customElements.define("ui-spinner", G);
});
let dt = G;
const K = class K extends HTMLElement {
  constructor() {
    super();
    i(this, "shadowCSS", () => h`
        :host {
            display: block !important;
            position: absolute !important;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            animation: fade-in 0.5s;
            transition: opacity 0.5s ease;
        }

        :host(:last-child) {
            opacity: 1;
        }

        @keyframes fade-in {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }
    `);
    i(this, "shadowTemplate", () => a`<slot></slot>`);
    this.attachShadow({ mode: "open" }), this.ui = {
      /** @private */
      root: this,
      cleanup: new u(),
      getName() {
        return this.root.getAttribute("name");
      },
      /**
       * @param {string | null} value
       */
      setName(t) {
        t === null && this.root.removeAttribute("name"), this.root.setAttribute("name", t);
      }
    }, this.shadowRender();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.ui.cleanup.run();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = `
            <style>${this.shadowCSS().trim()}</style>
            ${this.shadowTemplate().trim()}
        `;
  }
};
i(K, "register", () => {
  customElements.get("ui-stack-layout-page") || customElements.define("ui-stack-layout-page", K);
});
let j = K;
const H = class H extends HTMLElement {
  constructor() {
    super();
    i(this, "shadowCSS", () => h`
        :host {
            display: block !important;
            position: relative !important;
            width: 100%;
            height: 100%;
        }
    `);
    i(this, "shadowTemplate", () => a`<slot></slot>`);
    this.attachShadow({ mode: "open" }), this.ui = {
      /** @private */
      root: this,
      cleanup: new u(),
      /**
       * @private
       * @type {Pages}
       */
      pages: {},
      /**
       * @private
       * @type {UIStackLayoutPage[]}
       */
      stack: [],
      /**
       * @type {((ev: PopStateEvent) => void|Promise<void>) | null}
       */
      onpopstate: null,
      /**
       * @type {Events<{ "change": { oldPage: UIStackLayoutPage | null, newPage: UIStackLayoutPage | null } }>}
       */
      events: new g(),
      lock: !1,
      enableHistory() {
        this.onpopstate === null && (this.onpopstate = async () => {
          this._goBack();
        }, window.addEventListener("popstate", this.onpopstate));
      },
      disableHistory() {
        this.onpopstate === null && window.removeEventListener("popstate", this.onpopstate);
      },
      usesHistory() {
        return this.onpopstate !== null;
      },
      /**
       * @param {string} name
       * @param {() => (UIStackLayoutPage)} cb
       */
      registerPage(t, r) {
        this.pages[t] = r;
      },
      /**
       * @param {string} name
       */
      unregisterPage(t) {
        delete this.pages[t];
      },
      clearStack() {
        for (; this.stackSize() > 0; )
          this.root.removeChild(this.stack.pop());
      },
      stackSize() {
        return this.stack.length;
      },
      goBack() {
        if (!(!this.stack.length || this.lock)) {
          if (this.onpopstate !== null) {
            history.back();
            return;
          }
          this._goBack();
        }
      },
      /**
       * @private
       */
      _goBack() {
        const t = this.root.removeChild(this.stack.pop());
        this.stack.length > 0 && (this.stack[this.stack.length - 1].parentElement || this.root.appendChild(
          this.stack[this.stack.length - 1]
        )), this.dispatchChangeEvent(t);
      },
      /**
       * @param {string} name
       * @param {((page: UIStackLayoutPage) => void|Promise<void>) | null} [cb]
       * @param {boolean} [keepOldPage]
       */
      setPage(t, r = null, o = !1) {
        if (this.lock) return;
        const n = this.pages[t]();
        this.stack.push(this.root.appendChild(n)), typeof r == "function" && setTimeout(() => r(n));
        let l = null;
        this.stack.length > 1 && !o && (l = this.stack[this.stack.length - 2], l.parentElement.removeChild(l)), this.dispatchChangeEvent(l), this.onpopstate !== null && history.pushState(null, document.title, location.href);
      },
      /**
       * @param {UIStackLayoutPage} oldChild
       */
      async dispatchChangeEvent(t) {
        this.events.dispatch("change", {
          newPage: this.stack[this.stack.length - 1] || null,
          oldPage: t || this.stack[this.stack.length - 2] || null
        });
      }
    }, this.shadowRender();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.ui.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, r, o) {
    switch (t) {
      case "use-history":
        o !== null ? this.ui.enableHistory() : this.ui.disableHistory();
        break;
    }
  }
  shadowRender() {
    this.shadowRoot.innerHTML = `
            <style>${this.shadowCSS().trim()}</style>
            ${this.shadowTemplate().trim()}
        `;
  }
};
i(H, "register", () => {
  j.register(), customElements.get("ui-stack-layout") || customElements.define("ui-stack-layout", H);
}), i(H, "observedAttributes", ["use-history"]);
let ct = H;
const M = class M extends HTMLElement {
  constructor() {
    super(), this.ui = {
      /** @private */
      root: this,
      /**
       * @type {boolean}
       */
      useStorage: !1,
      /**
       * @type {string | null}
       */
      storagePrefix: null,
      /**
       * @type {any}
       */
      stores: {},
      /**
       * @type {Events<T>}
       */
      events: new g(),
      /**
       * @template {keyof T} K
       * @param {K} key
       * @returns {T[K]}
       */
      get(e) {
        return this.stores[e];
      },
      /**
       * @template {keyof T} K
       * @param {K} key
       * @param {T[K]} data
       * @param {boolean} [useDataAsFallback] Use data as fallback, if nothing found in the browsers `localStorage`
       * `this.enableLocalStorage` flag needs to be set to `true` for this to work
       */
      set(e, t, r = !1) {
        if (r && this.storagePrefix) {
          const o = JSON.parse(
            localStorage.getItem(
              (this.storagePrefix || "") + e.toString()
            ) || "null"
          );
          this.stores[e] = o ?? t;
        } else
          this.stores[e] = t;
        this.useStorage && localStorage.setItem(
          (this.storagePrefix || "") + e.toString(),
          JSON.stringify(this.stores[e])
        ), this.events.dispatch(e, this.stores[e]);
      },
      /**
       * @template {keyof T} K
       * @param {K} key
       * @param {(data: T[K]) => any} callback
       */
      update(e, t) {
        if (typeof t != "function")
          throw "callback is not a function";
        this.set(e, t(this.stores[e]));
      },
      /**
       * @template {keyof T} K
       * @param {K} key
       * @param {(data: T[K]) => void|Promise<void>} callback
       * @param {boolean} [trigger] - this will run the callback first
       * @returns {() => void} clean up function
       */
      on(e, t, r = !1) {
        if (typeof t != "function")
          throw "callback is not a function";
        return r && t(this.get(e)), this.events.on(e, t);
      }
    };
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(e, t, r) {
    switch (e) {
      case "use-storage":
        this.ui.useStorage = r !== null;
        break;
      case "storage-prefix":
        this.ui.storagePrefix = r;
        break;
    }
  }
};
i(M, "register", () => {
  customElements.get("ui-store") || customElements.define("ui-store", M);
}), i(M, "observedAttributes", ["use-storage", "storage-prefix"]);
let pt = M;
const $ = class $ extends HTMLElement {
  constructor() {
    super(), this.ui = {
      /**
       * @private
       * @type {MediaQueryList | null}
       */
      media: null,
      /**
       * @type {{ name: string; href: string } | null}
       */
      currentTheme: null,
      /**
       * @type {{ [key: string]: string }}
       */
      themes: {},
      /**
       * @param {HTMLElement} [element]
       */
      getMode(e = document.body) {
        return e.getAttribute("data-theme");
      },
      /**
       * @param {UIThemeHandlerMode} mode
       * @param {HTMLElement} [element]
       */
      setMode(e, t = document.body) {
        switch (e) {
          case "dark":
            t.setAttribute("data-theme", e);
            break;
          case "light":
            t.setAttribute("data-theme", e);
            break;
          default:
            t.removeAttribute("data-theme");
        }
      },
      /**
       * @private
       * @param {MediaQueryListEvent | MediaQueryList} ev
       */
      mediaChangeHandler: (e) => {
        e.matches ? document.body.setAttribute("data-theme", "dark") : document.body.setAttribute("data-theme", "light");
      },
      getAuto() {
        return !!this.media;
      },
      /**
       * @param {boolean} state
       * @param {HTMLElement} [element]
       */
      setAuto(e, t = document.body) {
        if (!e) {
          if (!this.media) return;
          this.media.removeEventListener(
            "change",
            this.mediaChangeHandler
          ), this.media = null;
          return;
        }
        if (this.setMode(null, t), this.media) {
          this.mediaChangeHandler(this.media);
          return;
        }
        this.media = window.matchMedia("(prefers-color-scheme: dark)"), this.media.addEventListener("change", this.mediaChangeHandler), this.mediaChangeHandler(this.media);
      },
      /**
       * @param {string} name
       * @param {string} href
       */
      addTheme(e, t) {
        this.themes[e] = t;
      },
      /**
       * @param {string} name
       */
      setTheme(e) {
        var r;
        if (!this.themes[e])
          throw `theme "${e}" is missing in this.themes`;
        if (((r = this.currentTheme) == null ? void 0 : r.name) == e)
          return;
        {
          const o = document.getElementById("theme");
          o && (document.head.removeChild(o), this.currentTheme = null);
        }
        const t = document.createElement("link");
        t.id = "theme", t.rel = "stylesheet", t.href = this.themes[e], document.head.appendChild(t), this.currentTheme = { name: e, href: this.themes[e] };
      }
    };
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(e, t, r) {
    switch (e) {
      case "auto":
        this.ui.setAuto(r !== null);
        break;
      case "mode":
        this.ui.setMode(r);
        break;
    }
  }
};
i($, "register", () => {
  customElements.get("ui-theme-handler") || customElements.define("ui-theme-handler", $);
}), i($, "observedAttributes", ["auto", "mode"]);
let gt = $;
const Y = class Y extends HTMLElement {
  constructor() {
    super();
    i(this, "shadowCSS", () => h`
        :host {
            width: 100%;
            height: 100%;
            color: inherit;
        }

        svg {
            width: 100%;
            height: 100%;
        }
    `);
    i(this, "shadowTemplate", () => a`<slot></slot>`);
    this.attachShadow({ mode: "open" }), this.ui = {
      cleanup: new u()
    }, this.shadowRender();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.ui.cleanup.run();
  }
  shadowRender() {
    this.shadowRoot.innerHTML = `
            <style>${this.shadowCSS().trim()}</style>
            ${this.shadowTemplate().trim()}
        `;
  }
};
i(Y, "register", () => {
  customElements.get("ui-svg") || customElements.define("ui-svg", Y);
});
let bt = Y;
function $t() {
  Q.register(), X.register(), W.register(), B.register(), _.register(), U.register(), et.register(), tt.register(), I.register(), it.register(), rt.register(), ot.register(), nt.register(), lt.register(), z.register(), at.register(), ut.register(), ht.register(), dt.register(), ct.register(), j.register(), pt.register(), bt.register(), st.register(), q.register(), x.register(), gt.register();
}
export {
  X as UIAppBar,
  Q as UIAppBarItem,
  W as UIButton,
  _ as UIContainer,
  U as UIDialog,
  I as UIDrawer,
  tt as UIDrawerGroup,
  et as UIDrawerGroupItem,
  ot as UIFlexGrid,
  it as UIFlexGridItem,
  rt as UIFlexGridRow,
  B as UIIconButton,
  nt as UIInput,
  st as UILabel,
  ht as UILang,
  ut as UILangType,
  q as UIPrimary,
  lt as UISearch,
  x as UISecondary,
  at as UISelect,
  z as UISelectOption,
  dt as UISpinner,
  ct as UIStackLayout,
  j as UIStackLayoutPage,
  pt as UIStore,
  gt as UIThemeHandler,
  Mt as js,
  $t as register
};
