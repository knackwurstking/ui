var ni = Object.defineProperty;
var Le = (o) => {
  throw TypeError(o);
};
var ai = (o, e, t) => e in o ? ni(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
var s = (o, e, t) => ai(o, typeof e != "symbol" ? e + "" : e, t), Gt = (o, e, t) => e.has(o) || Le("Cannot " + t);
var p = (o, e, t) => (Gt(o, e, "read from private field"), t ? t.call(o) : e.get(o)), n = (o, e, t) => e.has(o) ? Le("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(o) : e.set(o, t), E = (o, e, t, i) => (Gt(o, e, "write to private field"), i ? i.call(o, t) : e.set(o, t), t), l = (o, e, t) => (Gt(o, e, "access private method"), t);
class bi {
  constructor() {
    this.callbacks = [];
  }
  /**
   * @param {(() => void|Promise<void>)[]} cb
   */
  add(...e) {
    this.callbacks.push(...e);
  }
  run() {
    for (let e = 0; e < this.callbacks.length; e++)
      if (this.callbacks[e] !== null)
        try {
          this.callbacks[e](), this.callbacks[e] = null;
        } catch (t) {
          console.error("cleanup error:", t);
        }
    this.callbacks = this.callbacks.filter((e) => e !== null);
  }
}
function li(o, e, { onDragStart: t = null, onDragging: i = null, onDragEnd: r = null } = {}) {
  const c = () => {
    const g = [...o.children].indexOf(e);
    e.draggable = !0, e.ondragstart = (b) => {
      b.dataTransfer.effectAllowed = "move", b.dataTransfer.dropEffect = "move", t && t(g);
    }, e.ondragover = (b) => (b.preventDefault(), !1), e.ondragenter = (b) => {
      b.preventDefault(), [...o.children].forEach(
        (k, rt) => {
          if (rt === g) {
            k.style.background = "var(--ui-primary)", k.style.color = "var(--ui-primary-fg)";
            return;
          }
          k.style.background = "inherit", k.style.color = "inherit";
        }
      ), i && i(g);
    }, e.ondrop = (b) => {
      b.preventDefault(), b.dataTransfer.dropEffect = "move", r && r(g), [...o.children].forEach((k) => {
        k.style.background = "inherit", k.style.color = "inherit";
      });
    };
  }, d = () => {
    e.draggable = !1, e.ondragstart = null, e.ondragover = null, e.ondragenter = null, e.ondrop = null;
  };
  return c(), {
    /**
     * @param {DraggableNative_Options} options
     */
    update(h) {
      Object.hasOwn(h, "onDragStart") && (t = h.onDragStart), Object.hasOwn(h, "onDragging") && (i = h.onDragStart), Object.hasOwn(h, "onDragEnd") && (r = h.onDragEnd);
    },
    destroy: d
  };
}
function ci(o, { onDragEnd: e = null, onDragStart: t = null } = {}) {
  let i = null, r = null, c = null, d = null, h = null, g = !1, b = null, k = null;
  const rt = (a) => {
    !i && Array.from(a.currentTarget.classList).includes("draggable") && (c = a.clientX, d = a.clientY, r = (/* @__PURE__ */ new Date()).getTime(), i = a.currentTarget, h || clearTimeout(h), h = setTimeout(() => {
      b = i.style.color, k = i.style.backgroundColor, i.style.color = "var(--ui-primary-fg)", i.style.backgroundColor = "var(--ui-primary)", o.classList.add("dragging"), g = !0, t && t();
    }, 200));
  }, Ee = (a) => {
    if (!r || !i) return;
    if (!g && (/* @__PURE__ */ new Date()).getTime() - r < 200) {
      const Ae = Math.abs(c - a.clientX), Se = Math.abs(d - a.clientY);
      if ((Ae > Se ? Ae : Se) < 24)
        return;
      Zt();
      return;
    }
    a.preventDefault(), g || (g = !0, t && t());
    const w = !!a.targetTouches && a.targetTouches[0] || a;
    let m = document.elementFromPoint(w.clientX, w.clientY);
    for (; !m.classList.contains("draggable") && m.parentElement; )
      m = m.parentElement;
    m.classList.contains("draggable") && oi(i, m);
  }, Zt = () => {
    h !== null && (clearTimeout(h), h = null), i && (i.style.color = b, i.style.backgroundColor = k, i = null), r = null, o.classList.remove("dragging"), g && (e && e(), g = !1);
  };
  function oi(a, w) {
    si(a, w) ? o.insertBefore(a, w) : o.insertBefore(a, w.nextElementSibling);
  }
  function si(a, w) {
    let m = a.previousElementSibling;
    for (; m; ) {
      if (m === w)
        return !0;
      m = m.previousElementSibling;
    }
    return !1;
  }
  return (() => {
    Array.from(o.children).forEach(
      (a) => {
        a.classList.add("draggable"), a.onmousedown = rt, a.ontouchstart = rt, a.onmousemove = Ee, a.ontouchmove = Ee, a.onmouseup = Zt, a.ontouchend = Zt;
      }
    );
  })(), {
    /** @param {DraggableMobile_Options} options */
    update: (a) => {
      Object.hasOwn(a, "onDragStart") && (t = a.onDragStart), Object.hasOwn(a, "onDragEnd") && (e = a.onDragEnd);
    },
    destroy: () => {
      Array.from(o.children).forEach(
        (a) => {
          a.classList.remove("draggable"), a.onmousedown = null, a.ontouchstart = null, a.onmousemove = null, a.ontouchmove = null, a.onmouseup = null, a.ontouchend = null;
        }
      );
    }
  };
}
const fi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createMobile: ci,
  createNative: li
}, Symbol.toStringTag, { value: "Module" }));
var v;
class f {
  constructor() {
    /**
     * @type {any}
     */
    n(this, v, {});
  }
  /**
   * @template {keyof T} K
   * @param {K} key
   * @param {((data: T[K]) => void|Promise<void>) | null} listener
   * @returns {() => void} clean up function
   */
  on(e, t) {
    if (typeof t != "function")
      throw `invalid event listener passed for "${e.toString()}" event!`;
    return p(this, v)[e] || (p(this, v)[e] = []), p(this, v)[e].push(t), () => {
      this.off(e, t);
    };
  }
  /**
   * @template {keyof T} K
   * @param {K} key
   * @param {((data: T[K]) => void|Promise<void>)} listener
   */
  off(e, t) {
    if (!p(this, v)[e])
      throw `no listeners found for ${e.toString()}, there is nothing to delete`;
    let i = !1, r = 0;
    for (const c of p(this, v)[e])
      c === t && (p(this, v)[e].splice(r, 1), i = !0), r++;
    if (!i)
      throw `listener not found for ${e.toString()}, there is nothing to delete`;
    return this;
  }
  /**
   * @template {keyof T} K
   * @param {K} key
   * @param {T[K]} data
   */
  dispatch(e, t) {
    if (t === void 0) throw "data is undefined!";
    if (p(this, v)[e])
      for (const i of p(this, v)[e])
        i(t);
    return this;
  }
}
v = new WeakMap();
const Te = {
  color: "var(--ui-ripple-fg, currentColor)",
  opacity: "var(--ui-ripple-opacity, 0.2)",
  centered: !1,
  spreadDuration: ".4s",
  spreadTiming: "linear",
  clearDuration: "1s",
  clearTiming: "ease-in-out",
  useClick: !0
};
function C(o, e = {}) {
  e = { ...Te, ...e };
  let t;
  const i = (g) => {
    t = Kt(g, e);
  }, r = () => {
    Qt(t);
  }, c = (g) => {
    t = Kt(g, e), Qt(t);
  }, d = () => {
    o.classList.add("ripple-container"), o.style.overflow = "hidden", e.useClick === !0 ? o.addEventListener("click", c) : (o.addEventListener("pointerdown", i), o.addEventListener("pointerup", r), o.addEventListener("pointerleave", r));
  }, h = () => {
    o.classList.remove("ripple-container"), e.useClick === !0 ? o.removeEventListener("click", c) : (o.removeEventListener("pointerdown", i), o.removeEventListener("pointerup", r), o.removeEventListener("pointerleave", r));
  };
  return d(), {
    update: (g) => {
      e = {
        ...e,
        ...g
      }, h(), d();
    },
    destroy: h
  };
}
function Kt(o, e) {
  const t = document.createElement("div");
  t.classList.add("ripple"), t.style.position = "absolute", t.style.color = "inherit", t.style.borderRadius = "50%", t.style.pointerEvents = "none", t.style.width = "100px", t.style.height = "100px", t.style.marginTop = "-50px", t.style.marginLeft = "-50px", t.style.opacity = `${e.opacity}`, t.style.backgroundColor = e.color, t.style.transform = "scale(0) translate(0, 0)", t.style.transition = `transform ${e.spreadDuration} ${e.spreadTiming} 0s,opacity ${e.clearDuration} ${e.clearTiming} 0s`, o.currentTarget.appendChild(t);
  const i = o.currentTarget.getBoundingClientRect();
  if (e.centered)
    t.style.top = `${i.height / 2}px`, t.style.left = `${i.width / 2}px`;
  else {
    const c = !!o.targetTouches && o.targetTouches[0] || o;
    t.style.top = `${c.clientY - i.top}px`, t.style.left = `${c.clientX - i.left}px`;
  }
  const r = Math.max(i.width, i.height) * 0.02;
  return t.style.transform = `scale(${r}) translate(0, 0)`, t;
}
function Qt(o) {
  o && (o.addEventListener("transitionend", (e) => {
    e.propertyName === "opacity" && o.remove();
  }), o.style.opacity = "0");
}
const mi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  create: C,
  defaultOptions: Te,
  start: Kt,
  stop: Qt
}, Symbol.toStringTag, { value: "Module" }));
function vi() {
  return /(android)/i.test(navigator.userAgent);
}
const u = String.raw, A = String.raw;
function yi(o) {
  return Object.entries(o).map(
    ([e, t]) => `${e.replace(/[A-Z]/g, (i) => `-${i.toLowerCase()}`)}:${t}`
  ).join(";") + ";";
}
var st, Me;
const nt = class nt extends HTMLElement {
  constructor() {
    super();
    n(this, st);
    this.ui = {
      root: this,
      /**
       * @param {import("./ui-alert").UIAlert} alert
       */
      add(t) {
        return this.root.shadowRoot.querySelector(".alerts-container").append(t), () => this.remove(t);
      },
      /**
       * @param {import("./ui-alert").UIAlert} alert
       */
      remove(t) {
        this.root.shadowRoot.querySelector(".alerts-container").removeChild(t);
      }
    }, l(this, st, Me).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
};
st = new WeakSet(), Me = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                :host {
                    display: block;
                    position: fixed !important;
                    z-index: 999;

                    background: none !important;

                    overflow: auto;
                    -ms-overflow-style: none;
                    scrollbar-width: none;
                    scroll-behavior: smooth;
                }

                :host(::-webkit-scrollbar) {
                    display: none;
                }

                ui-flex-grid {
                    padding: 0;
                }

                ui-flex-grid:has(> *) {
                    padding: var(--ui-spacing);
                }
            </style>

            <style class="position">
                :host {
                    right: 0;
                    bottom: 0;
                }
            </style>

            <style class="size">
                :host {
                    width: fit-content;
                    max-width: 100%;
                    height: fit-content;
                    max-height: 100%;
                }
            </style>

            <ui-flex-grid class="alerts-container" gap="0.25rem">
            </ui-flex-grid>
        `;
}, s(nt, "register", () => {
  customElements.get("ui-alerts") || customElements.define("ui-alerts", nt);
});
let Wt = nt;
var at, Re;
const L = class L extends HTMLElement {
  constructor() {
    super();
    n(this, at);
    this.flex = "1", this.ui = {
      root: this,
      get flex() {
        return this.root.flex;
      },
      set flex(t) {
        this.root.flex = t || "1";
        const i = this.root.shadowRoot.querySelector('style[name="flex"]');
        i.textContent = A`
                    :host {
                        flex: ${this.root.flex};
                    }
                `;
      }
    }, l(this, at, Re).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, i, r) {
    switch (t) {
      case "flex":
        this.ui.flex = r;
        break;
    }
  }
};
at = new WeakSet(), Re = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host {
                    display: block;
                }
            </style>

            <style name="flex">
                :host {
                    flex: 1;
                }
            </style>

            <slot></slot>
        `;
}, s(L, "register", () => {
  customElements.get("ui-flex-grid-item") || customElements.define("ui-flex-grid-item", L);
}), s(L, "observedAttributes", ["flex"]);
let N = L;
var lt, He;
const T = class T extends HTMLElement {
  constructor() {
    super();
    n(this, lt);
    this.gap = "0", this.ui = {
      root: this,
      get gap() {
        return this.root.gap;
      },
      set gap(t) {
        this.root.gap = t || "0";
        const i = this.root.shadowRoot.querySelector('style[name="gap"]');
        i.textContent = A`
                    :host > ::slotted(*) {
                        margin: 0 ${this.root.gap} !important;
                    }
                `;
      },
      get justify() {
        return this.root.style.justifyContent;
      },
      set justify(t) {
        this.root.style.justifyContent = t;
      },
      get align() {
        return this.root.style.alignItems;
      },
      set align(t) {
        this.root.style.alignItems = t;
      }
    }, l(this, lt, He).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, i, r) {
    switch (t) {
      case "gap":
        this.ui.gap = r;
        break;
      case "justify":
        this.ui.justify = r;
        break;
      case "align":
        this.ui.align = r;
        break;
    }
  }
};
lt = new WeakSet(), He = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host {
                    display: flex !important;
                    flex-flow: row nowrap;
                    position: relative !important;
                    width: 100%;
                }
            </style>

            <style name="gap">
                :host > ::slotted(*) {
                    margin: 0 0 !important;
                }
            </style>

            <style>
                :host > ::slotted(*:first-child) {
                    margin-left: 0 !important;
                }

                :host > ::slotted(*:last-child) {
                    margin-right: 0 !important;
                }
            </style>

            <slot></slot>
        `;
}, s(T, "register", () => {
  customElements.get("ui-flex-grid-row") || customElements.define("ui-flex-grid-row", T);
}), s(T, "observedAttributes", ["gap", "justify", "align"]);
let _t = T;
var ct, ze;
const M = class M extends HTMLElement {
  constructor() {
    super();
    n(this, ct);
    this.gap = "0", this.ui = {
      root: this,
      get gap() {
        return this.root.gap;
      },
      set gap(t) {
        this.root.gap = t || "0";
        const i = this.root.shadowRoot.querySelector('style[name="gap"]');
        i.textContent = A`
                    :host > ::slotted(*) {
                        margin: ${this.root.gap} 0 !important;
                    }
                `;
      }
    }, l(this, ct, ze).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, i, r) {
    switch (t) {
      case "gap":
        this.ui.gap = r;
        break;
    }
  }
};
ct = new WeakSet(), ze = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host {
                    display: flex !important;
                    flex-flow: column nowrap;
                    position: relative !important;
                    width: 100%;
                    height: fit-content;
                }
            </style>

            <style name="gap">
                :host > ::slotted(*) {
                    margin: 0 0 !important;
                }
            </style>

            <style>
                :host > ::slotted(*:first-child) {
                    margin-top: 0 !important;
                }

                :host > ::slotted(*:last-child) {
                    margin-bottom: 0 !important;
                }
            </style>

            <slot></slot>
        `;
}, s(M, "register", () => {
  customElements.get("ui-flex-grid") || customElements.define("ui-flex-grid", M);
}), s(M, "observedAttributes", ["gap"]);
let It = M;
var ut, qe;
const ht = class ht extends N {
  /**
   * @param {UIAlert_Options} [options]
   */
  constructor(t = null) {
    super();
    n(this, ut);
    this.styleVariants = {
      info: A`
                :host {
                    color: var(--ui-card-fg);
                    background-color: var(--ui-card);
                }
            `,
      error: A`
                :host {
                    color: var(--ui-destructive-fg);
                    background-color: var(--ui-destructive);
                }
            `
    }, this.ui = {
      root: this,
      ...this.ui,
      /**
       * @param {UIAlert_Options | null} options
       */
      set(i) {
        i && (this.message = i.message, this.variant = i.variant);
      },
      get message() {
        return this.root.shadowRoot.querySelector("ui-primary").innerHTML;
      },
      /**
       * @param {string} value
       */
      set message(i) {
        const r = this.root.shadowRoot.querySelector("ui-primary");
        r.innerHTML = i || "";
      },
      get variant() {
        return this.root.getAttribute("variant");
      },
      /**
       * @param {UIAlert_Variants} value
       */
      set variant(i) {
        if (!i) {
          this.root.removeAttribute("variant");
          return;
        }
        this.root.setAttribute("variant", i);
      }
    }, l(this, ut, qe).call(this), t && this.ui.set(t);
  }
  static get observedAttributes() {
    return ["message", "variant", ...super.observedAttributes];
  }
  connectedCallback() {
    super.connectedCallback();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, i, r) {
    switch (super.attributeChangedCallback(t, i, r), t) {
      case "message":
        this.ui.message = r;
        break;
      case "variant":
        this.shadowRoot.querySelector("style.variant").innerHTML = // @ts-ignore
        this.styleVariants[r] || "";
    }
  }
};
ut = new WeakSet(), qe = function() {
  this.shadowRoot.removeChild(this.shadowRoot.querySelector("slot")), this.shadowRoot.innerHTML += u`
            <style>
                :host {
                    position: relative !important;
                    padding: var(--ui-spacing);
                    border-radius: var(--ui-radius);
                    border: 1px solid var(--ui-borderColor);
                    padding: var(--ui-spacing);

                    width: 28rem;
                    max-width: calc(100% - var(--ui-spacing) * 4);
                }
            </style>

            <style class="variant"></style>

            <ui-primary style="font-size: 0.9rem;"></ui-primary>
        `;
}, s(ht, "register", () => {
  customElements.get("ui-alert") || customElements.define("ui-alert", ht);
});
let Ut = ht;
var dt, je;
const pt = class pt extends HTMLElement {
  constructor() {
    super();
    n(this, dt);
    this.ui = {
      root: this,
      get leftSlot() {
        return [...this.root.querySelectorAll('[slot="left"]')];
      },
      get centerSlot() {
        return [...this.root.querySelectorAll('[slot="center"]')];
      },
      get rightSlot() {
        return [...this.root.querySelectorAll('[slot="right"]')];
      },
      get position() {
        return this.root.getAttribute("position");
      },
      set position(t) {
        if (!t) {
          this.root.removeAttribute("position");
          return;
        }
        this.root.setAttribute("position", t);
      }
    }, l(this, dt, je).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
};
dt = new WeakSet(), je = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host {
                    display: flex !important;
                    position: absolute !important;
                    z-index: 100;
                    background-color: var(--ui-backdrop);
                    -webkit-backdrop-filter: var(--ui-backdropFilter);
                    backdrop-filter: var(--ui-backdropFilter);
                    overflow: hidden;
                    user-select: none;
                }

                :host([position="top"]) {
                    top: 0;
                    left: 0;
                    right: 0;
                    height: var(--ui-app-bar-height);
                    border-bottom: 1px solid var(--ui-borderColor);
                    padding-left: var(--ui-spacing);
                    padding-right: var(--ui-spacing);
                }

                :host > ui-flex-grid-row {
                    width: 100%;
                    height: 100%;
                    align-items: center;
                    justify-content: space-between;
                }

                :host > ui-flex-grid-row > * {
                    height: 100%;
                }

                :host > ui-flex-grid-row > *:nth-child(1),
                :host > ui-flex-grid-row > *:nth-child(3) {
                    width: fit-content;
                }

                :host > ui-flex-grid-row > [slot="left"] {
                    margin-left: 0 !important;
                }

                :host > ui-flex-grid-row > [slot="center"] {
                    width: 100%;
                }

                :host > ui-flex-grid-row > [slot="right"] {
                    margin-right: 0 !important;
                    justify-content: flex-end;
                }
            </style>

            <ui-flex-grid-row gap="0.25rem">
                <ui-flex-grid-row gap="0.25rem">
                    <slot name="left"></slot>
                </ui-flex-grid-row>

                <ui-flex-grid-row gap="0.25rem" style="overflow: hidden;">
                    <slot name="center"></slot>
                </ui-flex-grid-row>

                <ui-flex-grid-row gap="0.25rem">
                    <slot name="right"></slot>
                </ui-flex-grid-row>
            </ui-flex-grid-row>
        `;
}, s(pt, "register", () => {
  customElements.get("ui-app-bar") || customElements.define("ui-app-bar", pt);
});
let te = pt;
var gt, $e;
const bt = class bt extends HTMLElement {
  constructor() {
    super();
    n(this, gt);
    this.ui = {
      root: this,
      /**
       * @returns {T}
       */
      get child() {
        return this.root.querySelector("*");
      },
      /**
       * @param {string | null} [value]
       */
      show(t = null) {
        this.root.style.display = t;
      },
      hide() {
        this.root.style.display = "none";
      }
    }, l(this, gt, $e).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
};
gt = new WeakSet(), $e = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host {
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    flex: 1;
                }
            </style>

            <slot></slot>
        `;
}, s(bt, "register", () => {
  customElements.get("ui-app-bar-item") || customElements.define("ui-app-bar-item", bt);
});
let ee = bt;
var ft, Oe;
const R = class R extends HTMLElement {
  constructor() {
    super();
    n(this, ft);
    this.ripple = null, this.ui = {
      root: this,
      /**
       * @type {Events<UIButton_Events>}
       */
      events: new f(),
      get noripple() {
        return !this.root.ripple;
      },
      set noripple(t) {
        if (!t) {
          this.root.ripple && this.root.ripple.destroy(), this.root.ripple = C(this.root);
          return;
        }
        this.root.ripple && (this.root.ripple.destroy(), this.root.ripple = null);
      },
      get color() {
        return this.root.getAttribute("color");
      },
      set color(t) {
        if (!t) {
          this.root.removeAttribute("color");
          return;
        }
        this.root.setAttribute("color", t);
      },
      get variant() {
        return this.root.getAttribute("variant");
      },
      set variant(t) {
        if (!t) {
          this.root.removeAttribute("variant");
          return;
        }
        this.root.setAttribute("variant", t);
      },
      get disabled() {
        return this.root.hasAttribute("disabled");
      },
      set disabled(t) {
        if (!t) {
          this.root.removeAttribute("disabled");
          return;
        }
        this.root.setAttribute("disabled", "");
      }
    }, l(this, ft, Oe).call(this);
  }
  connectedCallback() {
    this.setAttribute("role", "button");
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, i, r) {
    switch (t) {
      case "noripple":
        this.ui.noripple = r !== null;
        break;
    }
  }
};
ft = new WeakSet(), Oe = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host {
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    position: relative !important;
                    padding: var(--ui-spacing) calc(var(--ui-spacing) * 2.5);
                    border: 1px solid currentColor;
                    border-radius: var(--ui-radius);
                    overflow: hidden;
                    text-transform: capitalize;
                    cursor: pointer;
                    outline: none;
                    user-select: none;
                    font-size: 1.1rem;
                    font-weight: 450;
                    font-family: var(--ui-fontFamily);
                    font-variation-settings: var(--ui-button-fontVariation);
                }

                :host([variant="full"]) {
                    border: none;
                }

                :host([variant="full"][color="primary"]) {
                    background-color: var(--ui-primary);
                    color: var(--ui-primary-fg);
                }

                :host([variant="full"][color="secondary"]) {
                    background-color: var(--ui-secondary);
                    color: var(--ui-secondary-fg);
                }

                :host([variant="full"][color="destructive"]) {
                    background-color: var(--ui-destructive);
                    color: var(--ui-destructive-fg);
                }

                :host([variant="outline"]) {
                    border-color: currentColor;
                    background-color: transparent;
                }

                :host([variant="outline"][color="primary"]) {
                    color: var(--ui-primary);
                }

                :host([variant="outline"][color="secondary"]) {
                    color: var(--ui-secondary);
                }

                :host([variant="outline"][color="destructive"]) {
                    color: var(--ui-destructive);
                }

                :host([variant="ghost"]) {
                    border-color: transparent;
                    background-color: transparent;
                    font-weight: 900;
                }

                :host([variant="ghost"][color="primary"]) {
                    color: var(--ui-primary);
                }

                :host([variant="ghost"][color="secondary"]) {
                    color: var(--ui-secondary);
                }

                :host([variant="ghost"][color="destructive"]) {
                    color: var(--ui-destructive);
                }

                :host([disabled]),
                :host([disabled]:hover),
                :host([disabled]:active) {
                    background-color: transparent;
                    opacity: 0.25;
                    cursor: default;
                    pointer-events: none;
                }
            </style>

            <slot></slot>
        `, typeof this.ripple != "function" && (this.ripple = C(this)), this.addEventListener("click", () => {
    this.ui.events.dispatch("click", this);
  });
}, s(R, "register", () => {
  customElements.get("ui-button") || customElements.define("ui-button", R);
}), s(R, "observedAttributes", ["noripple"]);
let ie = R;
var mt, Fe;
const H = class H extends HTMLElement {
  constructor() {
    super();
    n(this, mt);
    this.ripple = null, this.ui = {
      root: this,
      /**
       * @type {Events<UIIconButton_Events>}
       */
      events: new f(),
      get noripple() {
        return !this.root.ripple;
      },
      set noripple(t) {
        if (!t) {
          this.root.ripple && this.root.ripple.destroy(), this.root.ripple = C(this.root);
          return;
        }
        this.root.ripple && (this.root.ripple.destroy(), this.root.ripple = null);
      },
      get color() {
        return this.root.getAttribute("color");
      },
      set color(t) {
        if (!t) {
          this.root.removeAttribute("color");
          return;
        }
        this.root.setAttribute("color", t);
      },
      get ghost() {
        return this.root.hasAttribute("ghost");
      },
      set ghost(t) {
        if (!t) {
          this.root.removeAttribute("ghost");
          return;
        }
        this.root.setAttribute("ghost", "");
      },
      get disabled() {
        return this.root.hasAttribute("disabled");
      },
      set disabled(t) {
        if (!t) {
          this.root.removeAttribute("disabled");
          return;
        }
        this.root.setAttribute("disabled", "");
      }
    }, l(this, mt, Fe).call(this);
  }
  connectedCallback() {
    this.setAttribute("role", "button");
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, i, r) {
    switch (t) {
      case "noripple":
        this.ui.noripple = r !== null;
        break;
    }
  }
};
mt = new WeakSet(), Fe = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host {
                    display: block;
                    position: relative;
                    width: 2.5rem;
                    height: 2.5rem;
                    padding: calc(var(--ui-spacing) / 2);
                    border: 1px solid currentColor;
                    border-radius: var(--ui-radius);
                    outline: none;
                    overflow: hidden;
                    cursor: pointer;
                    user-select: none;
                    font-size: 1.1rem;
                    font-weight: 450;
                    font-family: var(--ui-fontFamily);
                    font-variation-settings: var(--ui-button-fontVariation);
                    transition: color 0.5s linear;
                }

                :host([ghost]) {
                    border-color: transparent !important;
                    box-shadow: none;
                    font-weight: 900;
                }

                :host([color="primary"]) {
                    color: var(--ui-primary);
                    border-color: var(--ui-primary);
                }

                :host([color="secondary"]) {
                    color: var(--ui-secondary);
                    border-color: var(--ui-secondary);
                }

                :host([color="destructive"]) {
                    color: var(--ui-destructive);
                    border-color: var(--ui-destructive);
                }

                /* :disabled */

                :host([disabled]),
                :host([disabled]:hover),
                :host([disabled]:active) {
                    opacity: 0.25;
                    cursor: default;
                    pointer-events: none;
                }

                ui-svg {
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }
            </style>

            <ui-svg>
                <slot></slot>
            </ui-svg>
        `, typeof this.ripple != "function" && (this.ripple = C(this, { centered: !0 })), this.addEventListener("click", () => {
    this.ui.events.dispatch("click", this);
  });
}, s(H, "register", () => {
  customElements.get("ui-icon-button") || customElements.define("ui-icon-button", H);
}), s(H, "observedAttributes", ["noripple"]);
let re = H;
var vt, Ye;
const yt = class yt extends HTMLElement {
  constructor() {
    super();
    n(this, vt);
    this.ui = {}, l(this, vt, Ye).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
};
vt = new WeakSet(), Ye = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host {
                    display: block;
                    width: 100%;
                    max-width: 65rem;
                    margin: 0 auto !important;
                    padding: var(--ui-spacing);
                }
            </style>

            <slot></slot>
        `;
}, s(yt, "register", () => {
  customElements.get("ui-container") || customElements.define("ui-container", yt);
});
let oe = yt;
const ui = u`
  <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
    <g
      id="SVGRepo_tracerCarrier"
      stroke-linecap="round"
      stroke-linejoin="round"
    ></g>
    <g id="SVGRepo_iconCarrier">
      <rect width="24" height="24" fill="none"></rect>
      <path
        d="M7 17L16.8995 7.10051"
        stroke="currentColor"
        stroke-linecap="round"
        stroke-linejoin="round"
      ></path>
      <path
        d="M7 7.00001L16.8995 16.8995"
        stroke="currentColor"
        stroke-linecap="round"
        stroke-linejoin="round"
      ></path>
    </g>
  </svg>
`;
var kt, Be;
const z = class z extends HTMLElement {
  /**
   * @param {string} title
   */
  constructor(t) {
    super();
    n(this, kt);
    this._title = t || "", this.ui = {
      root: this,
      /** @type {Events<T>} */
      events: new f(),
      get title() {
        return this.root.shadowRoot.querySelector('[name="title"]').innerHTML;
      },
      set title(i) {
        const r = this.root.shadowRoot.querySelector('[name="title"]');
        this.root._title = r.innerHTML = i || "";
      },
      get fullscreen() {
        return this.root.hasAttribute("fullscreen");
      },
      set fullscreen(i) {
        if (!i) {
          this.root.removeAttribute("fullscreen");
          return;
        }
        this.root.setAttribute("fullscreen", "");
      },
      get nofooter() {
        return this.root.hasAttribute("nofooter");
      },
      set nofooter(i) {
        if (!i) {
          this.root.removeAttribute("nofooter");
          return;
        }
        this.root.setAttribute("nofooter", "");
      },
      /**
       * @param {boolean} modal
       * @param {boolean} [inert] - This will prevent the autofocus on input elements (default: true)
       */
      open(i = !1, r = !0) {
        const c = this.root.shadowRoot.querySelector("dialog"), d = c.inert;
        c.inert = r, i ? c.showModal() : c.show(), this.events.dispatch("open", null), c.inert = d;
      },
      close() {
        this.events.dispatch("close", null), this.root.shadowRoot.querySelector("dialog").close();
      }
    }, l(this, kt, Be).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, i, r) {
    switch (t) {
      case "title":
        this.ui.title = r;
        break;
    }
  }
  /**
   * @param {object} options
   * @param {string} [options.variant]
   * @param {string} [options.color]
   * @param {string} [options.flex]
   * @param {(() => void|Promise<void>) | null} [options.onClick]
   */
  static createAction({
    variant: t = "full",
    color: i = "primary",
    flex: r = "0",
    onClick: c = null
  }) {
    const d = new N();
    d.ui.flex = r, d.slot = "actions", d.innerHTML = u`
            <ui-button variant="${t}" color="${i}"></ui-button>
        `;
    let h;
    return c && (h = d.querySelector("ui-button"), h.ui.events.on("click", c)), {
      container: d,
      action: h
    };
  }
};
kt = new WeakSet(), Be = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host dialog * {
                    box-sizing: border-box;
                }

                dialog {
                    position: fixed !important;

                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);

                    max-width: 100%;
                    max-height: 100%;

                    margin: 0;
                    padding: 0;

                    border: none;
                    outline: none;

                    background-color: transparent;

                    -ms-overflow-style: none;
                    scrollbar-width: none;

                    z-index: 999;
                }

                dialog::-webkit-scrollbar {
                    display: none;
                }

                dialog::backdrop {
                    background-color: var(--ui-backdrop);
                    -webkit-backdrop-filter: var(--ui-backdropFilter);
                    backdrop-filter: var(--ui-backdropFilter);
                }

                dialog > .container {
                    background-color: var(--ui-bg);
                    color: var(--ui-color);

                    border: 1px solid var(--ui-borderColor);
                    border-radius: var(--ui-radius);

                    padding: var(--ui-spacing);

                    display: flex;
                    flex-direction: column;
                    justify-content: space-between;

                    position: relative;
                }

                :host([fullscreen]) dialog {
                    width: 100%;
                    height: 100%;
                }

                :host([fullscreen]) dialog > .container {
                    width: calc(100% - var(--ui-spacing) * 2);
                    height: calc(
                        100% -
                            (
                                env(safe-area-inset-top, 0) +
                                    env(safe-area-inset-bottom, 0) +
                                    (var(--ui-spacing) * 2)
                            )
                    );

                    margin: var(--ui-spacing);
                    margin-top: calc(
                        env(safe-area-inset-top, 0) + var(--ui-spacing)
                    );
                    margin-bottom: calc(
                        env(safe-area-inset-bottom, 0) + var(--ui-spacing)
                    );
                }

                /*
                 * Header Styles
                 */

                .header {
                    display: flex;
                    align-items: center;
                    justify-content: space-between;

                    border-top-right-radius: var(--ui-radius);
                    border-top-left-radius: var(--ui-radius);

                    width: 100%;
                    height: var(--ui-dialog-header-height);
                }

                .header [name="title"] {
                    margin: auto 0;
                }

                :host([fullscreen]) .header {
                    z-index: 15;
                    position: absolute;
                    top: var(--ui-spacing);
                    right: var(--ui-spacing);
                    left: var(--ui-spacing);
                    width: calc(100% - var(--ui-spacing) * 2);
                }

                /*
                 * Content Styles
                 */

                .content {
                    padding: var(--ui-spacing);
                    height: fit-content;
                    min-width: fit-content;
                    width: 100%;
                }

                :host([fullscreen]) .content {
                    z-index: 10;
                    position: absolute;
                    top: calc(
                        var(--ui-dialog-header-height) + var(--ui-spacing)
                    );
                    bottom: calc(
                        var(--ui-dialog-footer-height) + var(--ui-spacing)
                    );
                    right: var(--ui-spacing);
                    left: var(--ui-spacing);
                    padding: unset;
                    height: unset;
                    width: unset;
                    min-width: unset;
                }

                :host([nofooter]) .content {
                    bottom: var(--ui-spacing);
                }

                /*
                 * Footer Styles
                 */

                .footer {
                    margin-top: var(--ui-spacing);
                    border-bottom-right-radius: var(--ui-radius);
                    border-bottom-left-radius: var(--ui-radius);

                    width: 100%;
                    height: var(--ui-dialog-footer-height);
                }

                :host([fullscreen]) .footer {
                    z-index: 15;
                    position: absolute;
                    right: var(--ui-spacing);
                    bottom: var(--ui-spacing);
                    left: var(--ui-spacing);
                    width: calc(100% - var(--ui-spacing) * 2);
                }

                .footer ui-flex-grid-row {
                    height: 100%;
                    flex-wrap: nowrap;
                    justify-content: flex-end;
                    align-items: center;
                }

                :host([nofooter]) .footer {
                    display: none;
                }
            </style>

            <dialog>
                <div class="container">
                    <div class="header">
                        <span style="white-space: nowrap;">
                            <h3 name="title"></h3>
                        </span>

                        <ui-icon-button
                            style="width: var(--ui-dialog-header-height); height: 100%;"
                            ghost
                        >
                            ${ui}
                        </ui-icon-button>
                    </div>

                    <div class="content">
                        <slot></slot>
                    </div>

                    <div class="footer">
                        <ui-flex-grid-row gap="calc(var(--ui-spacing) / 2)">
                            <slot name="actions"></slot>
                        </ui-flex-grid-row>
                    </div>
                </div>
            </dialog>
        `, this.ui.title = this._title;
  const t = this.shadowRoot.querySelector(".header ui-icon-button"), i = () => this.ui.close();
  t.addEventListener("click", i);
  const r = this.shadowRoot.querySelector("dialog"), c = (d) => d.preventDefault();
  r.addEventListener("cancel", c);
}, s(z, "register", () => {
  customElements.get("ui-dialog") || customElements.define("ui-dialog", z);
}), s(z, "observedAttributes", ["title"]);
let se = z;
var wt, Pe;
const xt = class xt extends HTMLElement {
  constructor() {
    super();
    n(this, wt);
    this.ui = {
      root: this,
      /**
       * @type {Events<UIDrawer_Events>}
       */
      events: new f(),
      get open() {
        return this.root.hasAttribute("open");
      },
      set open(t) {
        if (!t) {
          this.root.removeAttribute("open"), this.events.dispatch("close", this.root);
          return;
        }
        this.root.setAttribute("open", ""), this.events.dispatch("open", this.root);
      }
    }, l(this, wt, Pe).call(this);
  }
  connectedCallback() {
    this.setAttribute("role", "button");
  }
  disconnectedCallback() {
  }
};
wt = new WeakSet(), Pe = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host {
                    display: block;

                    position: absolute !important;
                    z-index: 150;
                    top: 0;
                    left: -100%;
                    width: 100%;
                    height: 100%;

                    overflow: hidden;

                    transition: left 0s ease 0.5s;
                }

                :host([open]) {
                    background-color: var(--ui-backdrop);
                    -webkit-backdrop-filter: var(--ui-backdropFilter);
                    backdrop-filter: var(--ui-backdropFilter);

                    left: 0;

                    transition: none;
                }

                aside {
                    position: absolute;
                    z-index: 150;
                    top: 0;
                    left: -100%;
                    width: var(--ui-drawer-width, fit-content);
                    max-width: 100%;
                    height: 100%;

                    overflow-x: hidden;
                    overflow-y: auto;
                    scroll-behavior: smooth;

                    -ms-overflow-style: none;
                    scrollbar-width: none;

                    background-color: var(--ui-card);
                    color: var(--ui-card-fg);

                    /*
                    background-color: var(--ui-backdrop);
                    -webkit-backdrop-filter: var(--ui-backdropFilter);
                    backdrop-filter: var(--ui-backdropFilter);
                    */

                    border-right: 1px solid var(--ui-card-borderColor);

                    transition: left 0.5s ease;
                }

                aside::-webkit-scrollbar {
                    display: none;
                }

                :host([open]) aside {
                    left: 0;
                }
            </style>

            <aside>
                <slot></slot>
            </aside>
        `, this.shadowRoot.querySelector("aside").addEventListener("click", (t) => t.stopPropagation()), this.addEventListener("click", () => this.ui.open = !1);
}, s(xt, "register", () => {
  customElements.get("ui-drawer") || customElements.define("ui-drawer", xt);
});
let ne = xt;
const Ve = u`
  <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
    <g
      id="SVGRepo_tracerCarrier"
      stroke-linecap="round"
      stroke-linejoin="round"
    ></g>
    <g id="SVGRepo_iconCarrier">
      <rect width="24" height="24" fill="none"></rect>
      <path
        d="M17 9.5L12 14.5L7 9.5"
        stroke="currentColor"
        stroke-linecap="round"
        stroke-linejoin="round"
      ></path>
    </g>
  </svg>
`;
var Ct, Xe;
const q = class q extends HTMLElement {
  constructor() {
    super();
    n(this, Ct);
    this.ui = {
      root: this,
      get title() {
        return this.root.shadowRoot.querySelector(".title").innerHTML;
      },
      set title(t) {
        let i = this.root.shadowRoot.querySelector(".title");
        if (!t) {
          i.classList.remove("visible");
          return;
        }
        i.classList.add("visible"), i.innerHTML = u` <h3>${t}</h3> `;
      },
      get fold() {
        return this.root.hasAttribute("fold");
      },
      set fold(t) {
        if (!t) {
          this.root.removeAttribute("fold");
          return;
        }
        this.root.setAttribute("fold", "");
      },
      get nofold() {
        return this.root.hasAttribute("nofold");
      },
      set nofold(t) {
        if (!t) {
          this.root.removeAttribute("nofold");
          return;
        }
        this.root.setAttribute("nofold", "");
      }
    }, l(this, Ct, Xe).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, i, r) {
    switch (t) {
      case "title":
        this.ui.title = r;
        break;
    }
  }
};
Ct = new WeakSet(), Xe = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                * {
                    box-sizing: border-box;
                }

                ul {
                    margin: 0;
                    list-style: none;
                    padding: var(--ui-spacing);
                    overflow: hidden;
                }

                ui-drawer-group-item {
                    display: flex;
                    cursor: pointer;
                }

                .title:not(.visible) {
                    display: none;
                }

                .icon {
                    transition: transform 0.25s ease;
                }

                :host([fold]) .icon {
                    transform: rotate(-90deg);
                }

                :host([fold]):host(:not([nofold])) ::slotted(*) {
                    display: none !important;
                }

                :host([nofold]) ui-drawer-group-item:nth-child(1) {
                    display: none;
                }
            </style>

            <ul>
                <ui-drawer-group-item
                    style="position: relative; border-radius: var(--ui-radius);"
                    role="button"
                >
                    <ui-flex-grid-row>
                        <ui-flex-grid-item class="title"></ui-flex-grid-item>

                        <ui-flex-grid-item class="icon" flex="0">
                            <ui-svg style="width: 2.5rem; height: 2.5rem;">
                                ${Ve}
                            </ui-svg>
                        </ui-flex-grid-item>
                    </ui-flex-grid-row>
                </ui-drawer-group-item>

                <slot></slot>
            </ul>
        `;
  const t = this.shadowRoot.querySelector("ui-drawer-group-item");
  t.addEventListener("click", () => {
    this.ui.fold = !this.ui.fold;
  }), C(t);
}, s(q, "register", () => {
  customElements.get("ui-drawer-group") || customElements.define("ui-drawer-group", q);
}), s(q, "observedAttributes", ["title"]);
let ae = q;
var Et, De;
const At = class At extends HTMLElement {
  constructor() {
    super();
    n(this, Et);
    this.ui = {}, l(this, Et, De).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
};
Et = new WeakSet(), De = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host {
                    display: block;
                    width: 100%;
                }

                li {
                    padding: var(--ui-spacing) calc(var(--ui-spacing) * 1.5);
                    display: flex;
                    flex-direction: row;
                    flex-wrap: nowrap;
                    width: 100%;
                }

                ::slotted(*) {
                    width: 100%;
                }
            </style>

            <li>
                <slot></slot>
            </li>
        `;
}, s(At, "register", () => {
  customElements.get("ui-drawer-group-item") || customElements.define("ui-drawer-group-item", At);
});
let le = At;
var St, Je;
const j = class j extends HTMLElement {
  constructor() {
    super();
    n(this, St);
    this.ui = {
      /** @type {Events<E>} */
      events: new f(),
      /**
       * @type {HTMLInputElement | null}
       */
      input: null,
      get checked() {
        return this.input.checked;
      },
      set checked(t) {
        this.input.checked = t;
      }
    }, l(this, St, Je).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oV
   * @param {string | null} nV
   */
  attributeChangedCallback(t, i, r) {
    switch (t) {
      case "checked":
        this.ui.checked = r !== null;
        break;
    }
  }
  click() {
    this.ui.input.click();
  }
};
St = new WeakSet(), Je = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                input {
                    --ui-bg: "transparent";

                    display: inline-block;
                    height: 1.5rem;
                    width: 1.5rem;
                    border: 1px solid var(--ui-primary);
                    border-radius: var(--ui-radius);
                    transition: border-color 0.25s linear;
                    background-color: var(--ui-bg);
                    color: var(--ui-fg);
                    box-shadow: none;
                    outline: none;
                    padding: var(--ui-spacing) calc(var(--ui-spacing) * 2);
                    accent-color: var(--ui-primary);
                    cursor: pointer;
                    accent-color: var(--ui-primary);
                }

                input:disabled {
                    cursor: default;
                    user-select: none;
                }
            </style>

            <input slot="input" type="checkbox"></input>
        `, this.ui.input = this.shadowRoot.querySelector("input"), this.ui.input.onchange = () => {
    this.ui.events.dispatch("change", this.ui.checked);
  }, this.ui.input.oninput = () => {
    this.ui.events.dispatch("input", this.ui.checked);
  };
}, s(j, "register", () => {
  customElements.get("ui-check") || customElements.define("ui-check", j);
}), s(j, "observedAttributes", ["checked"]);
let ce = j;
var G, K, Q, W, _, I, U, tt, et, it, y, Ne, x;
const $ = class $ extends HTMLElement {
  constructor() {
    super();
    n(this, y);
    n(this, G, 1);
    n(this, K, p(this, G));
    n(this, Q, 0);
    n(this, W, p(this, Q));
    n(this, _, 0);
    n(this, I, p(this, _));
    n(this, U, "var(--ui-fontSize)");
    n(this, tt, p(this, U));
    n(this, et, "var(--ui-fontFamily)");
    n(this, it, p(this, et));
    this.ui = {
      root: this,
      get casl() {
        return p(this.root, K);
      },
      set casl(t) {
        var i;
        t === null && (t = p(this.root, G)), E(this.root, K, t), l(i = this.root, y, x).call(i);
      },
      get mono() {
        return p(this.root, W);
      },
      set mono(t) {
        var i;
        t === null && (t = p(this.root, Q)), E(this.root, W, t), l(i = this.root, y, x).call(i);
      },
      get slnt() {
        return p(this.root, I);
      },
      set slnt(t) {
        var i;
        t === null && (t = p(this.root, _)), E(this.root, I, t), l(i = this.root, y, x).call(i);
      },
      get size() {
        return p(this.root, tt);
      },
      set size(t) {
        var i;
        t === null && (t = p(this.root, U)), E(this.root, tt, t), l(i = this.root, y, x).call(i);
      },
      get family() {
        return p(this.root, it);
      },
      set family(t) {
        var i;
        t === null && (t = p(this.root, et)), E(this.root, it, t), l(i = this.root, y, x).call(i);
      }
    }, l(this, y, Ne).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, i, r) {
    switch (t) {
      case "casl":
        this.ui.casl = parseInt(r, 10);
        break;
      case "mono":
        this.ui.mono = parseInt(r, 10);
        break;
      case "slnt":
        this.ui.slnt = parseInt(r, 10);
        break;
      case "size":
        this.ui.size = r;
        break;
      case "family":
        this.ui.family = r;
        break;
    }
  }
};
G = new WeakMap(), K = new WeakMap(), Q = new WeakMap(), W = new WeakMap(), _ = new WeakMap(), I = new WeakMap(), U = new WeakMap(), tt = new WeakMap(), et = new WeakMap(), it = new WeakMap(), y = new WeakSet(), Ne = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                :host {
                    display: inline-block;
                    overflow-wrap: anywhere;
                }
            </style>

            <style class="custom"></style>

            <slot></slot>
        `, l(this, y, x).call(this);
}, x = function() {
  const t = this.shadowRoot.querySelector("style.custom");
  t.innerHTML = A`
            :host {
                font-size: ${this.ui.size};
                font-family: ${this.ui.family};
                font-variation-settings:
                    "CASL" ${this.ui.casl},
                    "MONO" ${this.ui.mono},
                    "slnt" ${this.ui.slnt};
            }
        `;
}, s($, "register", () => {
  customElements.get("ui-text") || customElements.define("ui-text", $);
}), s($, "observedAttributes", ["casl", "mono", "slnt", "size", "family"]);
let ot = $;
var Lt, Ze;
const O = class O extends HTMLElement {
  constructor() {
    super();
    n(this, Lt);
    this.ripple = null, this.running = !1, this.onClick = async () => {
      this.ui.inputSlot.forEach(
        (t) => t.click()
      );
    }, this.onInputClick = async (t) => {
      t.stopPropagation();
    }, this.ui = {
      root: this,
      get ripple() {
        return this.root.running;
      },
      set ripple(t) {
        if (!t) {
          this.root.disableRipple();
          return;
        }
        this.root.enableRipple();
      },
      get primary() {
        return this.root.shadowRoot.querySelector("ui-primary").innerHTML;
      },
      set primary(t) {
        this.root.shadowRoot.querySelector("ui-primary").innerHTML = t || "";
      },
      get secondary() {
        return this.root.shadowRoot.querySelector("ui-secondary").innerHTML;
      },
      set secondary(t) {
        this.root.shadowRoot.querySelector("ui-secondary").innerHTML = t || "";
      },
      get inputSlot() {
        return [...this.root.querySelectorAll('[slot="input"]')];
      }
    }, l(this, Lt, Ze).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, i, r) {
    switch (t) {
      case "ripple":
        this.ui.ripple = r !== null;
        break;
      case "primary":
        this.ui.primary = r;
        break;
      case "secondary":
        this.ui.secondary = r;
        break;
    }
  }
  enableRipple() {
    if (this.ripple || (this.ripple = C(this), this.style.cursor = "pointer", this.running)) return;
    this.addEventListener("click", this.onClick), [...this.querySelectorAll('[slot="input"]')].forEach((i) => {
      i.addEventListener("click", this.onInputClick);
    }), this.running = !0;
  }
  disableRipple() {
    this.running && (this.ripple && this.ripple.destroy(), this.removeEventListener("click", this.onClick), this.ui.inputSlot.forEach((t) => {
      t.removeEventListener("click", this.onInputClick);
    }), this.running = !1);
  }
};
Lt = new WeakSet(), Ze = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host {
                    position: relative !important;
                    display: flex !important;
                    flex-direction: row;
                    width: 100%;
                    padding: var(--ui-spacing);
                    border-radius: var(--ui-radius);
                }

                :host > .text {
                    display: flex;
                    flex: 1;
                    flex-direction: column;
                    justify-content: center;
                    margin-right: var(--ui-spacing);
                }

                :host > .input {
                    display: flex;
                    align-items: center;
                    justify-content: flex-end;
                }
            </style>

            <span class="text">
                <ui-primary></ui-primary>
                <ui-secondary></ui-secondary>
            </span>

            <span class="input">
                <slot name="input"></slot>
                <slot></slot>
            </span>
        `;
}, s(O, "register", () => {
  customElements.get("ui-label") || customElements.define("ui-label", O);
}), s(O, "observedAttributes", ["ripple", "secondary", "primary"]);
let ue = O;
var Tt, Ge;
const Mt = class Mt extends ot {
  constructor() {
    super();
    n(this, Tt);
    this.ui = {
      ...this.ui
    }, l(this, Tt, Ge).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
};
Tt = new WeakSet(), Ge = function() {
  this.ui.size = "1.1rem", this.ui.casl = 1, this.ui.mono = 0, this.ui.slnt = 0;
}, s(Mt, "register", () => {
  customElements.get("ui-primary") || customElements.define("ui-primary", Mt);
});
let he = Mt;
var Rt, Ke;
const Ht = class Ht extends ot {
  constructor() {
    super();
    n(this, Rt);
    this.ui = {
      ...this.ui
    }, l(this, Rt, Ke).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
};
Rt = new WeakSet(), Ke = function() {
  this.ui.size = "0.9rem", this.ui.casl = 1, this.ui.mono = 0, this.ui.slnt = -15;
}, s(Ht, "register", () => {
  customElements.get("ui-secondary") || customElements.define("ui-secondary", Ht);
});
let S = Ht;
var zt, Qe;
const F = class F extends HTMLElement {
  constructor() {
    super();
    n(this, zt);
    this.ui = {
      root: this,
      /** @type {Events<E>} */
      events: new f(),
      /** @type {HTMLInputElement | null} */
      input: null,
      get title() {
        return this.root.getAttribute("title");
      },
      set title(t) {
        let i = this.root.querySelector('[slot="title"]');
        !t && i && this.root.removeChild(i), t && (i || (i = new S(), i.slot = "title", this.root.appendChild(i)), i.innerHTML = t);
      },
      get type() {
        return this.input.type;
      },
      set type(t) {
        this.input.type = t || "";
      },
      get value() {
        return this.input.value;
      },
      set value(t) {
        this.input.value = t;
      },
      get placeholder() {
        return this.input.placeholder;
      },
      set placeholder(t) {
        this.input.placeholder = t || "";
      },
      get invalid() {
        return this.root.hasAttribute("invalid");
      },
      set invalid(t) {
        if (!t) {
          this.root.removeAttribute("invalid");
          return;
        }
        this.root.setAttribute("invalid", "");
      },
      get min() {
        return this.input.min;
      },
      set min(t) {
        this.input.min = t;
      },
      get max() {
        return this.input.max;
      },
      set max(t) {
        this.input.max = t;
      },
      /**
       * @param {FocusOptions | null} [options]
       */
      focus(t = null) {
        this.root.shadowRoot.querySelector("input").focus(t);
      },
      blur() {
        this.root.shadowRoot.querySelector("input").blur();
      }
    }, l(this, zt, Qe).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, i, r) {
    switch (t) {
      case "title":
        this.ui.title = r;
        break;
      case "type":
        this.ui.type = r;
        break;
      case "value":
        this.ui.value = r;
        break;
      case "placeholder":
        this.ui.placeholder = r;
        break;
      case "invalid":
        this.ui.input.ariaInvalid = r !== null ? "" : null;
        break;
      case "min":
        this.ui.min = r;
        break;
      case "max":
        this.ui.max = r;
        break;
    }
  }
};
zt = new WeakSet(), Qe = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host {
                    display: block;
                    position: relative;
                    width: 100%;
                    height: fit-content;
                }

                input {
                    width: 100%;
                    display: block;
                    margin: 0;
                    padding: var(--ui-spacing) calc(var(--ui-spacing) * 2);
                    border: none !important;
                    border-radius: inherit;
                    outline: none !important;
                    font-size: 0.9rem;
                    font-family: var(--ui-fontFamily);
                    font-variation-settings: var(--ui-input-fontVariation);
                    accent-color: var(--ui-primary);
                    background-color: transparent !important;
                }

                .container {
                    width: 100%;
                    border: none;
                    border: 1px solid var(--ui-borderColor);
                    border-radius: var(--ui-radius);
                    transition: border-color 0.25s linear;
                }

                .container:has(input:focus) {
                    border-color: var(--ui-primary);
                }

                :host([invalid]) .container {
                    border-color: var(--ui-destructive);
                }

                ::slotted([slot="title"]) {
                    display: block;
                    padding: 0 var(--ui-spacing);
                    user-select: none;
                    transform: translateY(calc(var(--ui-spacing) / 2));
                }
            </style>

            <div class="container">
                <slot name="title"></slot>
                <input />
            </div>
        `, this.ui.input = this.shadowRoot.querySelector("input"), this.ui.input.type = this.getAttribute("type") || "text", this.ui.input.oninput = () => {
    this.ui.events.dispatch("input", this.ui.input.value);
  }, this.ui.input.onchange = () => {
    this.ui.events.dispatch("change", this.ui.input.value);
  };
}, s(F, "register", () => {
  customElements.get("ui-input") || customElements.define("ui-input", F);
}), s(F, "observedAttributes", [
  "title",
  "type",
  "value",
  "placeholder",
  "invalid",
  "min",
  "max"
]);
let de = F;
const hi = u`
  <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
    <g
      id="SVGRepo_tracerCarrier"
      stroke-linecap="round"
      stroke-linejoin="round"
    ></g>
    <g id="SVGRepo_iconCarrier">
      <g clip-path="url(#clip0_15_152)">
        <rect width="24" height="24" fill="none"></rect>
        <circle
          cx="10.5"
          cy="10.5"
          r="6.5"
          stroke="currentColor"
          stroke-linejoin="round"
        ></circle>
        <path
          d="M19.6464 20.3536C19.8417 20.5488 20.1583 20.5488 20.3536 20.3536C20.5488 20.1583 20.5488 19.8417 20.3536 19.6464L19.6464 20.3536ZM20.3536 19.6464L15.3536 14.6464L14.6464 15.3536L19.6464 20.3536L20.3536 19.6464Z"
          fill="currentColor"
        ></path>
      </g>
      <defs>
        <clipPath id="clip0_15_152">
          <rect width="24" height="24" fill="none"></rect>
        </clipPath>
      </defs>
    </g>
  </svg>
`;
var qt, We;
const Y = class Y extends HTMLElement {
  constructor() {
    super();
    n(this, qt);
    this.storagekey = "", this.ui = {
      root: this,
      /** @type {Events<E>} */
      events: new f(),
      /** @type {HTMLInputElement | null} */
      input: null,
      /** @type {import("../ui-button").UIIconButton} */
      submit: this.querySelector('[name="submit"]'),
      get title() {
        return this.root.querySelector('[slot="title"]').innerHTML;
      },
      set title(t) {
        let i = this.root.querySelector('[slot="title"]');
        !t && i && this.root.removeChild(i), t && (i || (i = new S(), i.slot = "title", this.root.appendChild(i)), i.innerHTML = t);
      },
      get value() {
        return this.input.value;
      },
      set value(t) {
        this.input.value = t;
      },
      get placeholder() {
        return this.input.placeholder;
      },
      set placeholder(t) {
        this.input.placeholder = t || "";
      },
      get invalid() {
        return this.root.hasAttribute("invalid");
      },
      set invalid(t) {
        if (!t) {
          this.root.removeAttribute("invalid");
          return;
        }
        this.root.setAttribute("invalid", "");
      },
      get nosubmit() {
        return this.submit.style.display === "none";
      },
      set nosubmit(t) {
        if (!t) {
          this.submit.style.display = null;
          return;
        }
        this.submit.style.display = "none";
      },
      get storage() {
        return this.root.hasAttribute("storage");
      },
      set storage(t) {
        if (!t) {
          this.root.removeAttribute("storage");
          return;
        }
        this.root.setAttribute("storage", "");
      },
      get storageprefix() {
        return this.root.getAttribute("storageprefix");
      },
      set storageprefix(t) {
        if (!t) {
          this.root.removeAttribute("storageprefix");
          return;
        }
        this.root.setAttribute("storageprefix", t);
      },
      get storagekey() {
        return this.root.storagekey;
      },
      set storagekey(t) {
        this.root.storagekey = t, this.storage && (this.value = localStorage.getItem(
          this.storageprefix + this.root.storagekey
        ) || "", this.events.dispatch("storage", this.value));
      },
      /**
       * @param {FocusOptions | null} [options]
       */
      focus(t = null) {
        this.root.shadowRoot.querySelector("input").focus(t);
      },
      blur() {
        this.root.shadowRoot.querySelector("input").blur();
      }
    }, l(this, qt, We).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, i, r) {
    switch (t) {
      case "title":
        this.ui.title = r;
        break;
      case "value":
        this.ui.value = r;
        break;
      case "placeholder":
        this.ui.placeholder = r;
        break;
      case "invalid":
        this.ui.input.ariaInvalid = r !== null ? "" : null;
        break;
      case "nosubmit":
        this.ui.nosubmit = r !== null;
        break;
      case "storagekey":
        this.ui.storagekey = r;
        break;
    }
  }
};
qt = new WeakSet(), We = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host {
                    display: block;
                    position: relative;
                    width: 100%;
                    height: fit-content;
                }

                input {
                    width: 100%;
                    display: block;
                    margin: 0;
                    padding: var(--ui-spacing) calc(var(--ui-spacing) * 2);
                    border: none !important;
                    border-radius: inherit;
                    outline: none !important;
                    font-size: 0.9rem;
                    font-family: var(--ui-fontFamily);
                    font-variation-settings: var(--ui-input-fontVariation);
                    accent-color: var(--ui-primary);
                    background-color: transparent !important;
                }

                :host(:not([nosubmit])) input {
                    width: calc(100% - 2rem);
                }

                .container {
                    position: relative;
                    width: 100%;
                    border: none;
                    border: 1px solid var(--ui-borderColor);
                    border-radius: var(--ui-radius);
                    transition: border-color 0.25s linear;
                    background-color: var(--ui-backdrop);
                    -webkit-backdrop-filter: var(--ui-backdropFilter);
                    backdrop-filter: var(--ui-backdropFilter);
                }

                .container:has(input:focus) {
                    border-color: var(--ui-primary);
                }

                :host([invalid]) .container {
                    border-color: var(--ui-destructive);
                }

                ::slotted([slot="title"]) {
                    display: block;
                    padding: 0 var(--ui-spacing);
                    user-select: none;
                    transform: translateY(calc(var(--ui-spacing) / 2));
                }

                ui-icon-button {
                    position: absolute;
                    top: 0;
                    right: 0;
                    height: 100%;
                    border-top-left-radius: 0;
                    border-bottom-left-radius: 0;
                }
            </style>

            <div class="container">
                <slot name="title"></slot>
                <input type="search" />
                <ui-icon-button name="submit" ghost
                    >${hi}</ui-icon-button
                >
            </div>
        `, this.ui.submit = this.shadowRoot.querySelector('[name="submit"]'), this.ui.input = this.shadowRoot.querySelector("input"), this.ui.input.type = "search", this.ui.input.addEventListener("keydown", async (i) => {
    this.ui.nosubmit || i.key === "Enter" && this.ui.submit.click();
  });
  let t = null;
  this.ui.input.addEventListener("input", async () => {
    this.ui.storage && (t !== null && clearTimeout(t), t = setTimeout(() => {
      localStorage.setItem(
        this.ui.storageprefix + this.ui.storagekey,
        this.ui.input.value
      ), t = null;
    }, 250)), this.ui.events.dispatch("input", this.ui.input.value);
  }), this.shadowRoot.querySelector("ui-icon-button").addEventListener("click", () => {
    this.ui.events.dispatch("submit", this.ui.input.value);
  });
}, s(Y, "register", () => {
  customElements.get("ui-search") || customElements.define("ui-search", Y);
}), s(Y, "observedAttributes", [
  "title",
  "value",
  "placeholder",
  "invalid",
  "nosubmit",
  "storagekey"
]);
let pe = Y;
var jt, _e;
const $t = class $t extends HTMLElement {
  constructor() {
    super();
    n(this, jt);
    this.ui = {
      root: this,
      get value() {
        return this.root.getAttribute("value");
      },
      set value(t) {
        if (!t) {
          this.root.removeAttribute("value");
          return;
        }
        this.root.setAttribute("value", t);
      },
      get selected() {
        return this.root.hasAttribute("selected");
      },
      set selected(t) {
        if (!t) {
          this.root.removeAttribute("selected");
          return;
        }
        this.root.setAttribute("selected", "");
      }
    }, l(this, jt, _e).call(this);
  }
  connectedCallback() {
    this.setAttribute("role", "button");
  }
  disconnectedCallback() {
  }
};
jt = new WeakSet(), _e = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                :host {
                    display: none;
                    align-items: center;

                    padding: var(--ui-spacing);
                    padding-right: 2.5rem;

                    height: calc(
                        1em * var(--ui-lineHeight) + var(--ui-spacing) * 2
                    );

                    white-space: nowrap;
                    text-overflow: ellipsis;

                    transition:
                        background-color 0.25s linear,
                        color 0.25s linear;

                    overflow: hidden;
                }
            </style>

            <slot></slot>
        `;
}, s($t, "register", () => {
  customElements.get("ui-select-option") || customElements.define("ui-select-option", $t);
});
let Z = $t;
var Ot, Ie;
const B = class B extends HTMLElement {
  constructor() {
    super();
    n(this, Ot);
    this.open = !1, this.ui = {
      root: this,
      /**
       *  @type {Events<UISelect_Events>}
       */
      events: new f(),
      get open() {
        return this.root.open;
      },
      set open(t) {
        this.root.open = t, t ? this.root.setAttribute("open", "") : this.root.removeAttribute("open"), this.root.style.setProperty(
          "--items-length",
          `${this.root.children.length || 1}`
        );
      },
      /**
       * @returns {UISelectOption[]}
       */
      options() {
        return [...this.root.children].filter(
          (t) => t instanceof Z
        );
      },
      /**
       * @returns {UISelectOption | null}
       */
      selected() {
        try {
          return this.options().find(
            (t) => t.ui.selected
          ) || null;
        } catch {
          return null;
        }
      }
    }, l(this, Ot, Ie).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} n
   * @param {string | null} _oV
   * @param {string | null} nV
   */
  attributeChangedCallback(t, i, r) {
    switch (t) {
      case "open":
        const c = r !== null;
        c !== this.ui.open && (this.ui.open = c);
        break;
    }
  }
};
Ot = new WeakSet(), Ie = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host {
                    --ui-bg: "transparent";

                    position: relative !important;
                    display: block !important;

                    width: 100%;
                    height: calc(
                        1em * var(--ui-lineHeight) + var(--ui-spacing) * 2
                    );
                    transition: height 0.25s ease;

                    background-color: var(--ui-bg);
                    color: var(--ui-fg);

                    border: 1px solid var(--ui-borderColor);
                    border-radius: var(--ui-radius);

                    line-height: 1.15;

                    overflow: hidden;

                    font-size: 0.9rem;
                    font-family: var(--ui-fontFamily);
                    font-variation-settings: var(--ui-select-fontVariation);
                }

                .options {
                    cursor: pointer;
                    display: none;
                    display: flex;
                    flex-direction: column;
                    min-height: 100%;
                }

                .icon {
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    position: absolute;
                    top: 0;
                    right: 0;
                    width: 2.5rem;
                    height: 100%;
                    color: var(--ui-primary);
                }

                ::slotted(ui-select-option) {
                    display: flex;
                }

                :host([open]) {
                    height: calc(
                        (1em * var(--ui-lineHeight) + var(--ui-spacing) * 2) *
                            var(--items-length)
                    );
                }

                :host([open]) .options {
                    display: block;
                }

                :host([open]) .icon {
                    display: none;
                }

                :host([open]) ::slotted(ui-select-option[selected]) {
                    background-color: var(--ui-primary);
                    color: var(--ui-primary-fg);
                }

                :host([open])
                    ::slotted(ui-select-option:not([selected]):hover) {
                    background-color: hsla(
                        var(--ui-fg-h),
                        var(--ui-fg-s),
                        var(--ui-fg-l),
                        0.1
                    );
                }

                :host(:not([open]))
                    .options:has(> ::slotted(ui-select-option[selected])) {
                    display: block;
                }

                :host(:not([open]))
                    ::slotted(ui-select-option:not([selected])) {
                    display: none;
                }
            </style>

            <div class="options">
                <div class="icon"><ui-svg>${Ve}</ui-svg></div>

                <slot></slot>
            </div>
        `;
  const t = (r) => {
    const c = async (d) => {
      (d.composedPath() || []).forEach((h) => {
        h instanceof Z && ([...this.querySelectorAll("ui-select-option")].forEach(
          (g) => g.removeAttribute("selected")
        ), h.setAttribute("selected", ""), this.ui.events.dispatch("change", h));
      });
    };
    this.ui.open = !this.ui.open, this.ui.open ? (r.stopPropagation(), this.addEventListener("click", c)) : setTimeout(
      () => this.removeEventListener("click", c)
    );
  };
  this.shadowRoot.querySelector(".options").addEventListener("click", t);
}, s(B, "register", () => {
  customElements.get("ui-select") || customElements.define("ui-select", B);
}), s(B, "observedAttributes", ["open"]);
let ge = B;
var Ft, Ue;
const P = class P extends HTMLElement {
  constructor() {
    super();
    n(this, Ft);
    this.ui = {
      root: this,
      /** @type {Events<E>} */
      events: new f(),
      /** @type {HTMLTextAreaElement | null} */
      textarea: null,
      get title() {
        return this.root.getAttribute("title");
      },
      set title(t) {
        let i = this.root.querySelector('[slot="title"]');
        !t && i && this.root.removeChild(i), t && (i || (i = new S(), i.slot = "title", this.root.appendChild(i)), i.innerHTML = t);
      },
      get value() {
        return this.textarea.value;
      },
      set value(t) {
        this.textarea.value = t;
      },
      get placeholder() {
        return this.textarea.placeholder;
      },
      set placeholder(t) {
        this.textarea.placeholder = t || "";
      },
      get invalid() {
        return this.root.hasAttribute("invalid");
      },
      set invalid(t) {
        if (!t) {
          this.root.removeAttribute("invalid");
          return;
        }
        this.root.setAttribute("invalid", "");
      },
      get rows() {
        return this.textarea.rows;
      },
      set rows(t) {
        this.textarea.rows = t;
      },
      get cols() {
        return this.textarea.cols;
      },
      set cols(t) {
        this.textarea.cols = t;
      },
      /**
       * @param {FocusOptions | null} [options]
       */
      focus(t = null) {
        this.root.shadowRoot.querySelector("textarea").focus(t);
      },
      blur() {
        this.root.shadowRoot.querySelector("textarea").blur();
      }
    }, l(this, Ft, Ue).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, i, r) {
    switch (t) {
      case "title":
        this.ui.title = r;
        break;
      case "value":
        this.ui.value = r;
        break;
      case "placeholder":
        this.ui.placeholder = r;
        break;
      case "invalid":
        this.ui.textarea.ariaInvalid = r !== null ? "" : null;
        break;
      case "rows":
        this.ui.rows = r !== null ? parseFloat(r) : null;
        break;
      case "cols":
        this.ui.cols = r !== null ? parseFloat(r) : null;
        break;
    }
  }
};
Ft = new WeakSet(), Ue = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                * {
                    box-sizing: border-box;
                }

                :host {
                    display: block;
                    position: relative;
                    width: 100%;
                    height: fit-content;
                }

                textarea {
                    resize: none;
                    width: 100%;
                    display: block;
                    margin: 0;
                    padding: var(--ui-spacing) calc(var(--ui-spacing) * 2);
                    border: none !important;
                    border-radius: inherit;
                    outline: none !important;
                    font-size: 0.9rem;
                    font-family: var(--ui-fontFamily);
                    font-variation-settings: var(--ui-input-fontVariation);
                    accent-color: var(--ui-primary);
                    background-color: transparent !important;
                }

                .container {
                    width: 100%;
                    height: 100%;
                    border: none;
                    border: 1px solid var(--ui-borderColor);
                    border-radius: var(--ui-radius);
                    transition: border-color 0.25s linear;
                }

                .container:has(textarea:focus) {
                    border-color: var(--ui-primary);
                }

                :host([invalid]) .container {
                    border-color: var(--ui-destructive);
                }

                ::slotted([slot="title"]) {
                    display: block;
                    padding: 0 var(--ui-spacing);
                    user-select: none;
                    transform: translateY(calc(var(--ui-spacing) / 2));
                }
            </style>

            <div class="container">
                <slot name="title"></slot>
                <textarea></textarea>
            </div>
        `, this.ui.textarea = this.shadowRoot.querySelector("textarea"), this.ui.textarea.oninput = () => {
    this.ui.events.dispatch("input", this.ui.textarea.value);
  }, this.ui.textarea.onchange = () => {
    this.ui.events.dispatch("change", this.ui.textarea.value);
  };
}, s(P, "register", () => {
  customElements.get("ui-textarea") || customElements.define("ui-textarea", P);
}), s(P, "observedAttributes", [
  "title",
  "value",
  "placeholder",
  "invalid",
  "rows",
  "cols"
]);
let be = P;
const V = class V extends HTMLElement {
  constructor() {
    super(), this.ui = {
      root: this,
      /**
       * @type {{
       *  [key: string]: {
       *      [key: string]: string;
       *  };
       * }}
       */
      data: {},
      /**
       * @type {Events<{ "change": import(".").UILangType}>}
       */
      events: new f(),
      get current() {
        return this.root.getAttribute("current");
      },
      set current(e) {
        this.root.setCurrent(e || "");
      },
      /** @returns {import(".").UILangType} */
      fallback() {
        return this.root.querySelector("ui-lang-type[fallback]");
      },
      /**
       * @param {string} group
       * @param {string} key
       */
      get(e, t) {
        var i, r;
        return ((r = (i = this.data) == null ? void 0 : i[e]) == null ? void 0 : r[t]) || null;
      }
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(e, t, i) {
    switch (e) {
      case "current":
        this.ui.current = i;
        break;
    }
  }
  /**
   * @private
   * @param {string} name
   */
  async setCurrent(e) {
    const t = this.querySelector(`ui-lang-type[name="${e}"]`) || this.ui.fallback();
    if (t) {
      if (!t.ui.href) throw "Missing href attribute!";
      try {
        this.ui.data = await (await fetch(t.ui.href)).json();
      } catch (i) {
        console.error(i);
      }
      this.ui.events.dispatch("change", t);
    }
  }
};
s(V, "register", () => {
  customElements.get("ui-lang") || customElements.define("ui-lang", V);
}), s(V, "observedAttributes", ["current"]);
let fe = V;
const Yt = class Yt extends HTMLElement {
  constructor() {
    super(), this.ui = {
      root: this,
      get name() {
        return this.root.getAttribute("name");
      },
      set name(e) {
        if (!e) {
          this.root.removeAttribute("name");
          return;
        }
        this.root.setAttribute("name", e);
      },
      get href() {
        return this.root.getAttribute("href");
      },
      set href(e) {
        if (!e) {
          this.root.removeAttribute("href");
          return;
        }
        this.root.setAttribute("href", e);
      },
      get fallback() {
        return this.root.hasAttribute("fallback");
      },
      set fallback(e) {
        if (!e) {
          this.root.removeAttribute("fallback");
          return;
        }
        this.root.setAttribute("fallback", "");
      }
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
};
s(Yt, "register", () => {
  customElements.get("ui-lang-type") || customElements.define("ui-lang-type", Yt);
});
let me = Yt;
var Bt, ti;
const X = class X extends HTMLElement {
  constructor() {
    super();
    n(this, Bt);
    this.ui = {
      root: this,
      get nobg() {
        return this.root.hasAttribute("nobg");
      },
      set nobg(t) {
        const i = this.root.shadowRoot.querySelector(".background");
        if (!t) {
          i.style.display = null;
          return;
        }
        i.style.display = "none";
      }
    }, l(this, Bt, ti).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, i, r) {
    switch (t) {
      case "nobg":
        this.ui.nobg = r !== null;
        break;
    }
  }
};
Bt = new WeakSet(), ti = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                :host {
                    position: absolute !important;
                    top: 0;
                    right: 0;
                    bottom: 0;
                    left: 0;
                }

                .background {
                    z-index: 999;
                    position: absolute !important;
                    top: 0;
                    right: 0;
                    bottom: 0;
                    left: 0;
                    background-color: var(--ui-backdrop);
                    -webkit-backdrop-filter: var(--ui-backdropFilter);
                    backdrop-filter: var(--ui-backdropFilter);
                }

                .spinner {
                    z-index: 1000;
                    content: "";
                    box-sizing: border-box;
                    position: absolute !important;
                    top: 50%;
                    left: 50%;
                    width: 2.5rem;
                    height: 2.5rem;
                    margin-top: -1.25rem;
                    margin-left: -1.25rem;
                    border-radius: 50%;
                    border: 2px solid var(--ui-borderColor);
                    border-top-color: var(--ui-primary);
                    animation: spinner 0.6s linear infinite;
                }

                @keyframes spinner {
                    to {
                        transform: rotate(360deg);
                    }
                }
            </style>

            <div class="background"></div>
            <div class="spinner"></div>
        `;
}, s(X, "register", () => {
  customElements.get("ui-spinner") || customElements.define("ui-spinner", X);
}), s(X, "observedAttributes", ["nobg"]);
let ve = X;
var Pt, ei;
const D = class D extends HTMLElement {
  /**
   * @param {string} name
   */
  constructor(t) {
    super();
    n(this, Pt);
    this._name = t, this.ui = {
      root: this,
      get name() {
        return this.root._name;
      },
      set name(i) {
        this.name = i || "";
      }
    }, l(this, Pt, ei).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  /**
   * @param {string} n
   * @param {string | null} _oV
   * @param {string | null} nV
   */
  attributeChangedCallback(t, i, r) {
    switch (t) {
      case "name":
        this.ui.name = r;
        break;
    }
  }
};
Pt = new WeakSet(), ei = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                :host {
                    display: block !important;
                    position: absolute !important;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    opacity: 0;
                    animation: fade-in 0.5s;
                    transition: opacity 0.5s ease;
                }

                :host(:last-child) {
                    opacity: 1;
                }

                @keyframes fade-in {
                    0% {
                        opacity: 0;
                    }
                    100% {
                        opacity: 1;
                    }
                }
            </style>

            <slot></slot>
        `;
}, s(D, "register", () => {
  customElements.get("ui-stack-layout-page") || customElements.define("ui-stack-layout-page", D);
}), s(D, "observedAttributes", ["name"]);
let ye = D;
var Vt, ii;
const Xt = class Xt extends HTMLElement {
  constructor() {
    super();
    n(this, Vt);
    this.pages = {}, this.stack = [], this.onpopstate = () => this.goBack(), this.ui = {
      root: this,
      /**
       * @type {Events<{
       *  "change": {
       *      oldPage: UIStackLayoutPage | null,
       *      newPage: UIStackLayoutPage | null
       *  }
       * }>}
       */
      events: new f(),
      lock: !1,
      size() {
        return this.root.stack.length;
      },
      clear() {
        for (; this.size() > 0; )
          this.root.removeChild(this.root.stack.pop());
      },
      goBack() {
        if (!(!this.size() || this.lock)) {
          if (this.root.onpopstate !== null) {
            history.back();
            return;
          }
          this.root.goBack();
        }
      },
      /**
       * @param {T} pageName
       * @param {() => (UIStackLayoutPage)} cb
       */
      register(t, i) {
        this.root.pages[t] = i;
      },
      /**
       * @param {T} pageName
       */
      unregister(t) {
        delete this.root.pages[t];
      },
      /**
       * @param {T} pageName
       * @param {((page: UIStackLayoutPage) => void|Promise<void>) | null} [cb]
       * @param {boolean} [keepOldPage]
       */
      set(t, i = null, r = !1) {
        if (this.lock) return;
        const c = this.root.pages[t]();
        this.root.stack.push(this.root.appendChild(c)), typeof i == "function" && i(c);
        let d = null;
        this.size() > 1 && !r && (d = this.root.stack[this.root.stack.length - 2], d.parentElement.removeChild(d)), this.root.dispatchChangeEvent(d), this.root.onpopstate !== null && history.pushState(null, document.title, location.href);
      }
    }, l(this, Vt, ii).call(this);
  }
  connectedCallback() {
    window.addEventListener("popstate", this.onpopstate);
  }
  disconnectedCallback() {
    window.removeEventListener("popstate", this.onpopstate);
  }
  goBack() {
    const t = this.removeChild(this.stack.pop());
    this.stack.length > 0 && (this.stack[this.stack.length - 1].parentElement || this.appendChild(this.stack[this.stack.length - 1])), this.dispatchChangeEvent(t);
  }
  /**
   * @param {UIStackLayoutPage} oldChild
   */
  async dispatchChangeEvent(t) {
    this.ui.events.dispatch("change", {
      newPage: this.stack[this.stack.length - 1] || null,
      oldPage: t || this.stack[this.stack.length - 2] || null
    });
  }
};
Vt = new WeakSet(), ii = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                :host {
                    display: block !important;
                    position: relative !important;
                    width: 100%;
                    height: 100%;
                }
            </style>

            <slot></slot>
        `;
}, s(Xt, "register", () => {
  customElements.get("ui-stack-layout") || customElements.define("ui-stack-layout", Xt);
});
let ke = Xt;
const Dt = class Dt extends HTMLElement {
  constructor() {
    super(), this.stores = {}, this.ui = {
      root: this,
      /**
       * @type {Events<T>}
       */
      events: new f(),
      get storage() {
        return this.root.hasAttribute("storage");
      },
      set storage(e) {
        if (!e) {
          this.root.removeAttribute("storage");
          return;
        }
        this.root.setAttribute("storage", "");
      },
      get storageprefix() {
        return this.root.getAttribute("storageprefix");
      },
      set storageprefix(e) {
        if (!e) {
          this.root.removeAttribute("storageprefix");
          return;
        }
        this.root.setAttribute("storageprefix", e);
      },
      /**
       * @template {keyof T} K
       * @param {K} key
       * @returns {T[K]}
       */
      get(e) {
        if (this.storage) {
          const t = localStorage.getItem(
            (this.storageprefix || "") + e.toString()
          );
          if (t !== null)
            return JSON.parse(t);
        }
        return this.root.stores[e];
      },
      /**
       * @template {keyof T} K
       * @param {K} key
       * @param {T[K]} data
       * @param {boolean} [useDataAsFallback] Use data as fallback, if nothing found in the browsers `localStorage`
       * `this.enableLocalStorage` flag needs to be set to `true` for this to work
       */
      set(e, t, i = !1) {
        if (i && this.storage) {
          const r = JSON.parse(
            localStorage.getItem(
              (this.storageprefix || "") + e.toString()
            ) || "null"
          );
          this.root.stores[e] = r ?? t;
        } else
          this.root.stores[e] = t;
        this.storage && localStorage.setItem(
          (this.storageprefix || "") + e.toString(),
          JSON.stringify(this.root.stores[e])
        ), this.events.dispatch(e, this.root.stores[e]);
      },
      /**
       * @template {keyof T} K
       * @param {K} key
       * @param {(data: T[K]) => any} callback
       */
      update(e, t) {
        if (typeof t != "function")
          throw "callback is not a function";
        let i = null;
        if (this.storage) {
          const r = localStorage.getItem(
            (this.storageprefix || "") + e.toString()
          );
          r !== null && (i = JSON.parse(r));
        }
        i === null && (i = this.root.stores[e]), this.set(e, t(i));
      },
      /**
       * @template {keyof T} K
       * @param {K} key
       * @param {(data: T[K]) => void|Promise<void>} callback
       * @param {boolean} [trigger] - this will run the callback first
       * @returns {() => void} clean up function
       */
      on(e, t, i = !1) {
        if (typeof t != "function")
          throw "callback is not a function";
        return i && t(this.get(e)), this.events.on(e, t);
      }
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
};
s(Dt, "register", () => {
  customElements.get("ui-store") || customElements.define("ui-store", Dt);
});
let we = Dt;
const J = class J extends HTMLElement {
  constructor() {
    super(), this.mediaHandler = null, this.themes = {}, this.currentTheme = null, this.mode = "", this.ui = {
      root: this,
      get auto() {
        return !!this.root.media;
      },
      set auto(e) {
        this.root.setAuto(e);
      },
      get mode() {
        return this.root.mode;
      },
      set mode(e) {
        this.root.setMode(e);
      },
      /**
       * @param {string} themeName
       * @param {string} href
       */
      add(e, t) {
        this.root.themes[e] = t;
      },
      /**
       * @param {string} themeName
       */
      set(e) {
        var i;
        if (!this.root.themes[e])
          throw `theme "${e}" is missing in this.themes`;
        if (((i = this.root.currentTheme) == null ? void 0 : i.name) == e)
          return;
        {
          const r = document.getElementById("theme");
          r && (document.head.removeChild(r), this.root.currentTheme = null);
        }
        const t = document.createElement("link");
        t.id = "theme", t.rel = "stylesheet", t.href = this.root.themes[e], document.head.appendChild(t), this.root.currentTheme = {
          name: e,
          href: this.root.themes[e]
        };
      }
    };
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(e, t, i) {
    switch (e) {
      case "auto":
        this.ui.auto = i !== null;
        break;
      case "mode":
        this.ui.mode = i;
        break;
    }
  }
  /**
   * @param {boolean} state
   * @param {HTMLElement} target
   */
  setAuto(e, t = document.body) {
    if (!e) {
      if (!this.media) return;
      this.media.removeEventListener("change", this.mediaHandler), this.media = null, this.mediaHandler = null;
      return;
    }
    if (this.setMode(null, t), this.media) {
      this.mediaHandler(this.media);
      return;
    }
    this.mediaHandler = (i) => {
      i.matches ? t.setAttribute("data-theme", "dark") : t.setAttribute("data-theme", "light");
    }, this.media = window.matchMedia("(prefers-color-scheme: dark)"), this.media.addEventListener("change", this.mediaHandler), this.mediaHandler(this.media);
  }
  /**
   * @param {string | null} value
   * @param {HTMLElement} target
   */
  setMode(e, t = document.body) {
    this.mode = e, this.mode ? t.setAttribute("data-theme", e) : t.removeAttribute("data-theme");
  }
};
s(J, "register", () => {
  customElements.get("ui-theme-handler") || customElements.define("ui-theme-handler", J);
}), s(J, "observedAttributes", ["auto", "mode"]);
let xe = J;
var Jt, ri;
const Nt = class Nt extends HTMLElement {
  constructor() {
    super();
    n(this, Jt);
    this.ui = {}, l(this, Jt, ri).call(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
};
Jt = new WeakSet(), ri = function() {
  this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = u`
            <style>
                :host {
                    display: block;
                    width: 100%;
                    height: 100%;
                    color: inherit;
                }

                ::slotted(svg) {
                    width: 100%;
                    height: 100%;
                }
            </style>

            <slot></slot>
        `;
}, s(Nt, "register", () => {
  customElements.get("ui-svg") || customElements.define("ui-svg", Nt);
});
let Ce = Nt;
function ki() {
  Wt.register(), Ut.register(), ee.register(), te.register(), ie.register(), re.register(), oe.register(), se.register(), le.register(), ae.register(), ne.register(), N.register(), _t.register(), It.register(), ce.register(), de.register(), pe.register(), Z.register(), ge.register(), be.register(), me.register(), fe.register(), ve.register(), ke.register(), ye.register(), we.register(), Ce.register(), ue.register(), he.register(), S.register(), xe.register();
}
export {
  bi as CleanUp,
  f as Events,
  Ut as UIAlert,
  Wt as UIAlerts,
  te as UIAppBar,
  ee as UIAppBarItem,
  ie as UIButton,
  ce as UICheck,
  oe as UIContainer,
  se as UIDialog,
  ne as UIDrawer,
  ae as UIDrawerGroup,
  le as UIDrawerGroupItem,
  It as UIFlexGrid,
  N as UIFlexGridItem,
  _t as UIFlexGridRow,
  re as UIIconButton,
  de as UIInput,
  ue as UILabel,
  fe as UILang,
  me as UILangType,
  he as UIPrimary,
  pe as UISearch,
  S as UISecondary,
  ge as UISelect,
  Z as UISelectOption,
  ve as UISpinner,
  ke as UIStackLayout,
  ye as UIStackLayoutPage,
  we as UIStore,
  ot as UIText,
  be as UITextarea,
  xe as UIThemeHandler,
  A as css,
  fi as draggable,
  u as html,
  vi as isAndroid,
  ki as register,
  mi as ripple,
  yi as styles
};
