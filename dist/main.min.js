var Qt = Object.defineProperty;
var Wt = (s, t, e) => t in s ? Qt(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;
var o = (s, t, e) => (Wt(s, typeof t != "symbol" ? t + "" : t, e), e), Gt = (s, t, e) => {
  if (!t.has(s))
    throw TypeError("Cannot " + e);
};
var d = (s, t, e) => (Gt(s, t, "read from private field"), e ? e.call(s) : t.get(s)), dt = (s, t, e) => {
  if (t.has(s))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(s) : t.set(s, e);
};
const pt = {
  onDragStart: null,
  onDragging: null,
  onDragEnd: null
};
function It(s, t = {}) {
  t = {
    ...pt,
    ...t
  };
  const e = () => {
    const l = [...s.parentNode.children].indexOf(s);
    s.draggable = !0, s.ondragstart = (c) => {
      c.dataTransfer.effectAllowed = "move", c.dataTransfer.dropEffect = "move", c.dataTransfer.setData(
        "text/plain",
        l.toString()
      ), t.onDragStart && t.onDragStart(l);
    }, s.ondragover = (c) => (c.preventDefault(), !1), s.ondragenter = (c) => {
      c.preventDefault(), t.onDragging && t.onDragging(l);
    }, s.ondrop = (c) => {
      c.preventDefault(), c.dataTransfer.dropEffect = "move";
      const Kt = parseInt(
        c.dataTransfer.getData("text/plain"),
        10
      );
      t.onDragEnd && t.onDragEnd(Kt, l);
    };
  }, i = () => {
    s.draggable = !1, s.ondragstart = null, s.ondragover = null, s.ondragenter = null, s.ondrop = null;
  };
  return e(), {
    /**
     * @param {DraggableOptions} _options
     */
    update(r) {
      t = {
        ...pt,
        ...r
      }, i(), e();
    },
    destroy: i
  };
}
var h;
class u {
  constructor() {
    /**
     * @type {any}
     */
    dt(this, h, {});
  }
  /**
   * @template {keyof T} K
   * @param {K} key
   * @param {((data: T[K]) => void|Promise<void>) | null} listener
   * @returns {() => void} clean up function
   */
  on(t, e) {
    if (typeof e != "function")
      throw `invalid event listener passed for "${t.toString()}" event!`;
    return d(this, h)[t] || (d(this, h)[t] = []), d(this, h)[t].push(e), () => {
      this.off(t, e);
    };
  }
  // }}}
  /**
   * @template {keyof T} K
   * @param {K} key
   * @param {((data: T[K]) => void|Promise<void>)} listener
   */
  off(t, e) {
    if (!d(this, h)[t])
      throw `no listeners found for ${t.toString()}, there is nothing to delete`;
    let i = !1, r = 0;
    for (const l of d(this, h)[t])
      l === e && (d(this, h)[t].splice(r, 1), i = !0), r++;
    if (!i)
      throw `listener not found for ${t.toString()}, there is nothing to delete`;
    return this;
  }
  // }}}
  /**
   * @template {keyof T} K
   * @param {K} key
   * @param {T[K]} data
   */
  dispatch(t, e) {
    if (e === void 0)
      throw "data is undefined!";
    if (d(this, h)[t])
      for (const i of d(this, h)[t])
        i(e);
    return this;
  }
  // }}}
}
h = new WeakMap();
function gt(s, t) {
  const e = document.createElement("div");
  e.classList.add("ripple"), e.style.position = "absolute", e.style.color = "inherit", e.style.borderRadius = "50%", e.style.pointerEvents = "none", e.style.width = "100px", e.style.height = "100px", e.style.marginTop = "-50px", e.style.marginLeft = "-50px", e.style.opacity = `${t.opacity}`, e.style.backgroundColor = t.color, e.style.transform = "scale(0) translate(0, 0)", e.style.transition = `transform ${t.spreadDuration} ${t.spreadTiming} 0s,opacity ${t.clearDuration} ${t.clearTiming} 0s`, s.currentTarget.appendChild(e);
  const i = s.currentTarget.getBoundingClientRect();
  t.centered ? (e.style.top = `${i.height / 2}px`, e.style.left = `${i.width / 2}px`) : (e.style.top = `${s.clientY - i.top}px`, e.style.left = `${s.clientX - i.left}px`);
  const r = Math.max(i.width, i.height) * 0.02;
  return e.style.transform = `scale(${r}) translate(0, 0)`, e;
}
function mt(s) {
  s && (s.addEventListener("transitionend", (t) => {
    t.propertyName === "opacity" && s.remove();
  }), s.style.opacity = "0");
}
const Xt = {
  color: "var(--ui-ripple-color, currentColor)",
  opacity: "var(--ui-ripple-opacity, 0.2)",
  centered: !1,
  spreadDuration: ".4s",
  spreadTiming: "linear",
  clearDuration: "1s",
  clearTiming: "ease-in-out",
  useClick: !1
};
function ot(s, t = {}) {
  t = { ...Xt, ...t };
  let e;
  const i = (l) => {
    e = gt(l, t);
  }, r = () => {
    mt(e);
  };
  return s.classList.add("ripple-container"), s.style.overflow = "hidden", t.useClick === !0 ? s.addEventListener("click", (l) => {
    e = gt(l, t), mt(e);
  }) : (s.addEventListener("pointerdown", i), s.addEventListener("pointerup", r), s.addEventListener("pointerleave", r)), () => {
    s.classList.remove("ripple-container"), s.removeEventListener("pointerdown", i), s.removeEventListener("pointerup", r), s.removeEventListener("pointerleave", r);
  };
}
function Ut() {
  return /(android)/i.test(navigator.userAgent);
}
const n = String.raw, _t = String.raw;
class a {
  constructor() {
    this.callbacks = [];
  }
  /**
   * @param {(() => void|Promise<void>)} cb
   */
  add(t) {
    this.callbacks.push(t);
  }
  run() {
    for (let t = 0; t < this.callbacks.length; t++)
      if (this.callbacks[t] !== null)
        try {
          this.callbacks[t](), this.callbacks[t] = null;
        } catch (e) {
          console.error("cleanup error:", e);
        }
    this.callbacks = this.callbacks.filter((t) => t !== null);
  }
}
const Pe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CleanUp: a,
  Events: u,
  createDraggable: It,
  createRipple: ot,
  css: _t,
  defaultRippleOptions: Xt,
  html: n,
  isAndroid: Ut
}, Symbol.toStringTag, { value: "Module" })), st = "1", te = n`
    <style></style>
    <slot></slot>
`, g = class g extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = te, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      getFlex() {
        return this.root.hasAttribute("flex") ? this.root.getAttribute("flex") : st;
      },
      /**
       * @param {string | null} value
       */
      setFlex(t) {
        t === null ? this.root.removeAttribute("flex") : this.root.setAttribute("flex", t);
      }
    }, this.updateStyle();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "flex":
        this.updateStyle({ flex: i || st });
        break;
    }
  }
  /**
   * @private
   * @param {Object} attributes
   * @param {string} [attributes.flex]
   */
  updateStyle({ flex: t = st } = {}) {
    this.shadowRoot.querySelector("style").textContent = `
            :host {
                flex: ${t};
            }
        `;
  }
};
o(g, "register", () => {
  customElements.get("ui-flex-grid-item") || customElements.define("ui-flex-grid-item", g);
}), o(g, "observedAttributes", ["flex"]);
let bt = g;
const rt = "0", ee = `
    <style></style>
    <slot></slot>
`, m = class m extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ee, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      getGap() {
        return this.root.getAttribute("gap") || rt;
      },
      /**
       * @param {string | null} value
       */
      setGap(t) {
        t === null ? this.root.removeAttribute("gap") : this.root.setAttribute("gap", t);
      }
    }, this.updateStyle();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "gap":
        this.updateStyle({ gap: i || rt });
        break;
    }
  }
  /**
   * @private
   * @param {Object} attributes
   * @param {string} [attributes.gap]
   */
  updateStyle({ gap: t = rt } = {}) {
    this.shadowRoot.querySelector("style").textContent = `
            :host {
                display: flex !important;
                flex-flow: row nowrap;
                position: relative !important;
                width: 100%;
            }

            :host > ::slotted(*) {
                margin: 0 ${t} !important;
            }

            :host > ::slotted(*:first-child) {
                margin-left: 0 !important;
            }

            :host > ::slotted(*:last-child) {
                margin-right: 0 !important;
            }
        `;
  }
};
o(m, "register", () => {
  customElements.get("ui-flex-grid-row") || customElements.define("ui-flex-grid-row", m);
}), o(m, "observedAttributes", ["gap"]);
let M = m;
const nt = "0", ie = `
    <style></style>
    <slot></slot>
`, b = class b extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ie, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      getGap() {
        return this.root.getAttribute("gap") || nt;
      },
      /**
       * @param {string | null} value
       */
      setGap(t) {
        t === null ? this.root.removeAttribute("gap") : this.root.setAttribute("gap", t);
      }
    }, this.updateStyle();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "gap":
        this.updateStyle({ gap: i || nt });
        break;
    }
  }
  /**
   * @private
   * @param {Object} attributes
   * @param {string} [attributes.gap]
   */
  updateStyle({ gap: t = nt } = {}) {
    this.shadowRoot.querySelector("style").textContent = `
            :host {
                display: flex !important;
                flex-flow: column nowrap;
                position: relative !important;
                width: 100%;
                height: fit-content;
            }

            :host > ::slotted(*) {
                margin: ${t} 0 !important;
            }

            :host > ::slotted(*:first-child) {
                margin-top: 0 !important;
            }

            :host > ::slotted(*:last-child) {
                margin-bottom: 0 !important;
            }
        `;
  }
};
o(b, "register", () => {
  customElements.get("ui-flex-grid") || customElements.define("ui-flex-grid", b);
}), o(b, "observedAttributes", ["gap"]);
let ft = b;
const oe = n`
    <style>
        * { box-sizing: border-box; }

        :host {
            display: flex !important;
            position: absolute !important;
            z-index: 100;
            background-color: var(--ui-backdrop-bgColor);
            backdrop-filter: var(--ui-backdropFilter);
            overflow: hidden;
            user-select: none;
        }

        :host([position="top"]) {
            top: 0;
            left: 0;
            right: 0;
            height: var(--ui-app-bar-height);
            border-bottom: 1px solid var(--ui-borderColor);
        }

        :host > ui-flex-grid-row {
            width: 100%;
            height: 100%;
            align-items: center;
            justify-content: space-between;
        }

        :host > ui-flex-grid-row > * {
            height: 100%;
        }

        :host > ui-flex-grid-row > *:nth-child(1),
        :host > ui-flex-grid-row > *:nth-child(3) {
            width: fit-content;
        }

        :host > ui-flex-grid-row > [slot="left"] {
            margin-left: 0 !important;
        }

        :host > ui-flex-grid-row > [slot="center"] {
            width: 100%;
        }

        :host > ui-flex-grid-row > [slot="right"] {
            margin-right: 0 !important;
            justify-content: flex-end;
        }
    </style>

    <ui-flex-grid-row gap="0.25rem">
        <ui-flex-grid-row gap="0.25rem">
            <slot name="left"></slot>
        </ui-flex-grid-row>

        <ui-flex-grid-row gap="0.25rem" style="overflow: hidden;">
            <slot name="center"></slot>
        </ui-flex-grid-row>

        <ui-flex-grid-row gap="0.25rem">
            <slot name="right"></slot>
        </ui-flex-grid-row>
    </ui-flex-grid-row>
`, R = class R extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = oe, this.cleanup = new a(), this.ui = {
      getLeftSlot: () => [...this.querySelectorAll('[slot="left"]')],
      getCenterSlot: () => [...this.querySelectorAll('[slot="center"]')],
      getRightSlot: () => [...this.querySelectorAll('[slot="right"]')]
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
o(R, "register", () => {
  M.register(), customElements.get("ui-app-bar") || customElements.define("ui-app-bar", R);
});
let vt = R;
const se = n`
    <style>
        * { box-sizing: border-box; }

        :host {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
        }
    </style>

    <slot></slot>
`, S = class S extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = se, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      enable() {
        this.root.style.display = "flex";
      },
      disable() {
        this.root.style.display = "none";
      },
      /**
       * @returns {T}
       */
      getItem() {
        return this.root.querySelector("*");
      }
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
o(S, "register", () => {
  customElements.get("ui-app-bar-item") || customElements.define("ui-app-bar-item", S);
});
let wt = S;
const re = n`
    <style>
        * {
            box-sizing: border-box;
        }

        :host {
            display: flex !important;
            align-items: center;
            justify-content: center;
            position: relative !important;
            padding: var(--ui-spacing) calc(var(--ui-spacing) * 2.5);
            border: 1px solid currentColor;
            border-radius: var(--ui-radius);
            overflow: hidden;
            text-transform: capitalize;
            cursor: pointer;
            outline: none;
            user-select: none;
            font-size: 1.1rem;
            font-weight: 450;
            font-family: var(--ui-fontFamily);
            font-variation-settings: var(--ui-button-fontVariation);
        }

        :host([variant="full"]) {
            border: none;
        }

        :host([variant="full"][color="primary"]) {
            background-color: var(--ui-primary-bgColor);
            color: var(--ui-primary-color);
        }

        :host([variant="full"][color="secondary"]) {
            background-color: var(--ui-secondary-bgColor);
            color: var(--ui-secondary-color);
        }

        :host([variant="full"][color="destructive"]) {
            background-color: var(--ui-destructive-bgColor);
            color: var(--ui-destructive-color);
        }

        :host([variant="outline"]) {
            border-color: currentColor;
            background-color: transparent;
        }

        :host([variant="outline"][color="primary"]) {
            color: var(--ui-primary-bgColor);
        }

        :host([variant="outline"][color="secondary"]) {
            color: var(--ui-secondary-bgColor);
        }

        :host([variant="outline"][color="destructive"]) {
            color: var(--ui-destructive-bgColor);
        }

        :host([variant="ghost"]) {
            border-color: transparent;
            background-color: transparent;
            font-weight: 900;
        }

        :host([variant="ghost"][color="primary"]) {
            color: var(--ui-primary-bgColor);
        }

        :host([variant="ghost"][color="secondary"]) {
            color: var(--ui-secondary-bgColor);
        }

        :host([variant="ghost"][color="destructive"]) {
            color: var(--ui-destructive-bgColor);
        }

        :host([disabled]),
        :host([disabled]:hover),
        :host([disabled]:active) {
            background-color: transparent;
            opacity: 0.25;
            cursor: default;
            pointer-events: none;
        }
    </style>

    <slot></slot>
`, f = class f extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = re, this.setAttribute("role", "button"), this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      /**
       * @type {Events<UIButtonEvents>}
       */
      events: new u(),
      /**
       * @private
       * @type {(() => void) | null}
       */
      removeRipple: null,
      /**
       * @returns {UIButtonColor}
       */
      getColor() {
        return this.root.getAttribute("color");
      },
      /**
       * @param {UIButtonColor} value
       */
      setColor(t) {
        this.root.setAttribute("color", t);
      },
      /**
       * @returns {UIButtonVariant}
       */
      getVariant() {
        return this.root.getAttribute("variant");
      },
      /**
       * @param {UIButtonVariant} value
       */
      setVariant(t) {
        this.root.setAttribute("variant", t);
      },
      disable() {
        this.root.setAttribute("disabled", "");
      },
      enable() {
        this.root.removeAttribute("disabled");
      },
      enableRipple() {
        this.removeRipple || (this.removeRipple = ot(this.root, { centered: !0 }), this.root.removeAttribute("no-ripple"));
      },
      disableRipple() {
        this.removeRipple && (this.removeRipple(), this.removeRipple = null, this.root.setAttribute("no-ripple", ""));
      }
    };
  }
  connectedCallback() {
    !this.hasAttribute("no-ripple") && !this.ui.removeRipple && this.ui.enableRipple(), this.bindClickEvent();
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "no-ripple":
        i !== null ? this.ui.disableRipple() : this.ui.enableRipple();
        break;
      case "color":
        i !== null && (["primary", "secondary", "destructive"].includes(
          i
        ) ? this.style.color = null : this.style.color = i);
        break;
    }
  }
  /**
   * @private
   */
  bindClickEvent() {
    const t = async () => {
      this.ui.events.dispatch("click", this);
    };
    this.addEventListener("click", t), this.cleanup.add(() => {
      this.removeEventListener("click", t);
    });
  }
};
o(f, "register", () => {
  customElements.get("ui-button") || customElements.define("ui-button", f);
}), o(f, "observedAttributes", ["no-ripple", "color"]);
let yt = f;
const ne = n`
    <style>
        * {
            box-sizing: border-box;
        }

        :host {
            display: flex !important;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 2rem;
            height: 2rem;
            padding: calc(var(--ui-spacing) / 2);
            border: 1px solid currentColor;
            border-radius: var(--ui-radius);
            outline: none;
            overflow: hidden;
            cursor: pointer;
            user-select: none;
            font-size: 1.1rem;
            font-weight: 450;
            font-family: var(--ui-fontFamily);
            font-variation-settings: var(--ui-button-fontVariation);
        }

        :host([ghost]) {
            border-color: transparent !important;
            box-shadow: none;
            font-weight: 900;
        }

        :host([color="primary"]) {
            color: var(--ui-primary-bgColor);
            border-color: var(--ui-primary-bgColor);
        }

        :host([color="secondary"]) {
            color: var(--ui-secondary-bgColor);
            border-color: var(--ui-secondary-bgColor);
        }

        :host([color="destructive"]) {
            color: var(--ui-destructive-bgColor);
            border-color: var(--ui-destructive-bgColor);
        }

        /* :disabled */

        :host([disabled]),
        :host([disabled]:hover),
        :host([disabled]:active) {
            opacity: 0.25;
            cursor: default;
            pointer-events: none;
        }
    </style>

    <slot></slot>
`, v = class v extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ne, this.setAttribute("role", "button"), this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      /**
       * @type {Events<UIIconButtonEvents>}
       */
      events: new u(),
      /**
       * @private
       * @type {(() => void) | null}
       */
      removeRipple: null,
      /**
       * @returns {UIIconButtonColor}
       */
      getColor() {
        return this.root.getAttribute("color");
      },
      /**
       * @param {UIIconButtonColor} value
       */
      setColor(t) {
        this.root.setAttribute("color", t);
      },
      /**
       * @returns {boolean}
       */
      getGhost() {
        return this.root.hasAttribute("ghost");
      },
      /**
       * @param {boolean} state
       */
      setGhost(t) {
        t ? this.root.setAttribute("ghost", "") : this.root.removeAttribute("ghost");
      },
      disable() {
        this.root.setAttribute("disabled", "");
      },
      enable() {
        this.root.removeAttribute("disabled");
      },
      enableRipple() {
        this.removeRipple || (this.removeRipple = ot(this.root, { centered: !0 }), this.root.removeAttribute("no-ripple"));
      },
      disableRipple() {
        this.removeRipple && (this.removeRipple(), this.removeRipple = null, this.root.setAttribute("no-ripple", ""));
      }
    };
  }
  connectedCallback() {
    !this.hasAttribute("no-ripple") && !this.ui.removeRipple && this.ui.enableRipple(), this.bindClickEvent();
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "no-ripple":
        i !== null ? this.ui.disableRipple() : this.ui.enableRipple();
        break;
      case "color":
        i !== null && (["primary", "secondary", "destructive"].includes(
          i
        ) ? this.style.color = null : this.style.color = i);
        break;
    }
  }
  /**
   * @private
   */
  bindClickEvent() {
    const t = async () => {
      this.ui.events.dispatch("click", this);
    };
    this.addEventListener("click", t), this.cleanup.add(() => {
      this.removeEventListener("click", t);
    });
  }
};
o(v, "register", () => {
  customElements.get("ui-icon-button") || customElements.define("ui-icon-button", v);
}), o(v, "observedAttributes", ["no-ripple", "color"]);
let A = v;
const ae = n`
<style>
    * { box-sizing: border-box; }

    :host {
        display: block;
        width: 100%;
        max-width: 65rem;
        margin: 0 auto !important;
        padding: var(--ui-spacing);
    }
</style>

<slot></slot>
`, $ = class $ extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ae, this.cleanup = new a(), this.ui = {};
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
o($, "register", () => {
  customElements.get("ui-container") || customElements.define("ui-container", $);
});
let kt = $;
const le = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 24 24"
    xmlns="http://www.w3.org/2000/svg"
>

    <g id="Complete">
        <g data-name="add" id="add">
            <g>
                <line
                    fill="none"
                    stroke="currentColor"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2" x1="12" x2="12" y1="19" y2="5"
                />

                <line
                    fill="none"
                    stroke="currentColor"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2" x1="5" x2="19" y1="12" y2="12"
                />
            </g>
        </g>
    </g>
</svg>
`, z = class z extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = le;
  }
};
o(z, "register", () => {
  customElements.get("svg-add") || customElements.define("svg-add", z);
});
let Ct = z;
const ce = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 52 52"
    fill="currentColor"
    xmlns="http://www.w3.org/2000/svg"
>
    <path
        d="M50,24H6.83L27.41,3.41a2,2,0,0,0,0-2.82,2,2,0,0,0-2.82,0l-24,24a1.79,1.79,0,0,0-.25.31A1.19,1.19,0,0,0,.25,25c0,.07-.07.13-.1.2l-.06.2a.84.84,0,0,0,0,.17,2,2,0,0,0,0,.78.84.84,0,0,0,0,.17l.06.2c0,.07.07.13.1.2a1.19,1.19,0,0,0,.09.15,1.79,1.79,0,0,0,.25.31l24,24a2,2,0,1,0,2.82-2.82L6.83,28H50a2,2,0,0,0,0-4Z"
    />
</svg>
`, j = class j extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ce;
  }
};
o(j, "register", () => {
  customElements.get("svg-back-arrow") || customElements.define("svg-back-arrow", j);
});
let xt = j;
const he = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
>
    <rect width="24" height="24" fill="none" />
    <path
        d="M17 9.5L12 14.5L7 9.5"
        stroke="currentColor"
        stroke-linecap="round"
        stroke-linejoin="round"
    />
</svg>
`, q = class q extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = he;
  }
};
o(q, "register", () => {
  customElements.get("svg-chevron-down") || customElements.define("svg-chevron-down", q);
});
let at = q;
const ue = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
>
    <g clip-path="url(#clip0_429_11083)">
        <path
            d="M7 7.00006L17 17.0001M7 17.0001L17 7.00006"
            stroke="currentColor"
            stroke-width="2.5"
            stroke-linecap="round"
            stroke-linejoin="round"
        />
    </g>
    <defs>
        <clipPath id="clip0_429_11083">
            <rect width="24" height="24" fill="none" />
        </clipPath>
    </defs>
</svg>
`, P = class P extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ue;
  }
};
o(P, "register", () => {
  customElements.get("svg-close") || customElements.define("svg-close", P);
});
let lt = P;
const de = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
>
    <path
        d="M12 3V16M12 16L16 11.625M12 16L8 11.625"
        stroke="currentColor"
        stroke-width="1.5"
        stroke-linecap="round"
        stroke-linejoin="round"
    />

    <path
        d="M15 21H9C6.17157 21 4.75736 21 3.87868 20.1213C3 19.2426 3 17.8284 3 15M21 15C21 17.8284 21 19.2426 20.1213 20.1213C19.8215 20.4211 19.4594 20.6186 19 20.7487"
        stroke="currentColor"
        stroke-width="1.5"
        stroke-linecap="round"
        stroke-linejoin="round"
    />
</svg>
`, F = class F extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = de;
  }
};
o(F, "register", () => {
  customElements.get("svg-download") || customElements.define("svg-download", F);
});
let Lt = F;
const pe = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
>
    <path
        d="M20.1497 7.93997L8.27971 19.81C7.21971 20.88 4.04971 21.3699 3.27971 20.6599C2.50971 19.9499 3.06969 16.78 4.12969 15.71L15.9997 3.84C16.5478 3.31801 17.2783 3.03097 18.0351 3.04019C18.7919 3.04942 19.5151 3.35418 20.0503 3.88938C20.5855 4.42457 20.8903 5.14781 20.8995 5.90463C20.9088 6.66146 20.6217 7.39189 20.0997 7.93997H20.1497Z"
        stroke="currentColor"
        stroke-width="1.5"
        stroke-linecap="round"
        stroke-linejoin="round"
    />
    <path
        d="M21 21H12"
        stroke="currentColor"
        stroke-width="1.5"
        stroke-linecap="round"
        stroke-linejoin="round"
    />
</svg>;
`, N = class N extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = pe;
  }
};
o(N, "register", () => {
  customElements.get("svg-edit") || customElements.define("svg-edit", N);
});
let Et = N;
const ge = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 512 512"
    xmlns="http://www.w3.org/2000/svg"
    xmlns:xlink="http://www.w3.org/1999/xlink"
>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor" transform="translate(85.333333, 42.666667)">
            <path
                d="M75.9466667,285.653333 C63.8764997,278.292415 49.6246897,275.351565 35.6266667,277.333333 L1.42108547e-14,277.333333 L1.42108547e-14,405.333333 L28.3733333,405.333333 L28.3733333,356.48 L40.5333333,356.48 C53.1304778,357.774244 65.7885986,354.68506 76.3733333,347.733333 C85.3576891,340.027178 90.3112817,328.626053 89.8133333,316.8 C90.4784904,304.790173 85.3164923,293.195531 75.9466667,285.653333 L75.9466667,285.653333 Z M53.12,332.373333 C47.7608867,334.732281 41.8687051,335.616108 36.0533333,334.933333 L27.7333333,334.933333 L27.7333333,298.666667 L36.0533333,298.666667 C42.094796,298.02451 48.1897668,299.213772 53.5466667,302.08 C58.5355805,305.554646 61.3626692,311.370371 61.0133333,317.44 C61.6596233,323.558965 58.5400493,329.460862 53.12,332.373333 L53.12,332.373333 Z M150.826667,277.333333 L115.413333,277.333333 L115.413333,405.333333 L149.333333,405.333333 C166.620091,407.02483 184.027709,403.691457 199.466667,395.733333 C216.454713,383.072462 225.530463,362.408923 223.36,341.333333 C224.631644,323.277677 218.198313,305.527884 205.653333,292.48 C190.157107,280.265923 170.395302,274.806436 150.826667,277.333333 L150.826667,277.333333 Z M178.986667,376.32 C170.098963,381.315719 159.922142,383.54422 149.76,382.72 L144.213333,382.72 L144.213333,299.946667 L149.333333,299.946667 C167.253333,299.946667 174.293333,301.653333 181.333333,308.053333 C189.877212,316.948755 194.28973,329.025119 193.493333,341.333333 C194.590843,354.653818 189.18793,367.684372 178.986667,376.32 L178.986667,376.32 Z M254.506667,405.333333 L283.306667,405.333333 L283.306667,351.786667 L341.333333,351.786667 L341.333333,329.173333 L283.306667,329.173333 L283.306667,299.946667 L341.333333,299.946667 L341.333333,277.333333 L254.506667,277.333333 L254.506667,405.333333 L254.506667,405.333333 Z M234.666667,7.10542736e-15 L9.52127266e-13,7.10542736e-15 L9.52127266e-13,234.666667 L42.6666667,234.666667 L42.6666667,192 L42.6666667,169.6 L42.6666667,42.6666667 L216.96,42.6666667 L298.666667,124.373333 L298.666667,169.6 L298.666667,192 L298.666667,234.666667 L341.333333,234.666667 L341.333333,106.666667 L234.666667,7.10542736e-15 L234.666667,7.10542736e-15 Z"
            ></path>
        </g>
    </g></svg
>
`, Z = class Z extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ge;
  }
};
o(Z, "register", () => {
  customElements.get("svg-pdf") || customElements.define("svg-pdf", Z);
});
let Mt = Z;
const me = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 1024 1024"
    xmlns="http://www.w3.org/2000/svg"
>
    <path
        d="M960 160h-291.2a160 160 0 0 0-313.6 0H64a32 32 0 0 0 0 64h896a32 32 0 0 0 0-64zM512 96a96 96 0 0 1 90.24 64h-180.48A96 96 0 0 1 512 96zM844.16 290.56a32 32 0 0 0-34.88 6.72A32 32 0 0 0 800 320a32 32 0 1 0 64 0 33.6 33.6 0 0 0-9.28-22.72 32 32 0 0 0-10.56-6.72zM832 416a32 32 0 0 0-32 32v96a32 32 0 0 0 64 0v-96a32 32 0 0 0-32-32zM832 640a32 32 0 0 0-32 32v224a32 32 0 0 1-32 32H256a32 32 0 0 1-32-32V320a32 32 0 0 0-64 0v576a96 96 0 0 0 96 96h512a96 96 0 0 0 96-96v-224a32 32 0 0 0-32-32z"
        fill="currentColor"
    />
    <path
        d="M384 768V352a32 32 0 0 0-64 0v416a32 32 0 0 0 64 0zM544 768V352a32 32 0 0 0-64 0v416a32 32 0 0 0 64 0zM704 768V352a32 32 0 0 0-64 0v416a32 32 0 0 0 64 0z"
        fill="currentColor"
    />
</svg>
`, O = class O extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = me;
  }
};
o(O, "register", () => {
  customElements.get("svg-recycle") || customElements.define("svg-recycle", O);
});
let At = O;
const be = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
>
    <path
        d="M11 6C13.7614 6 16 8.23858 16 11M16.6588 16.6549L21 21M19 11C19 15.4183 15.4183 19 11 19C6.58172 19 3 15.4183 3 11C3 6.58172 6.58172 3 11 3C15.4183 3 19 6.58172 19 11Z"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
    />
</svg>
`, V = class V extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = be;
  }
};
o(V, "register", () => {
  customElements.get("svg-search") || customElements.define("svg-search", V);
});
let ct = V;
const fe = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 -0.5 21 21"
    xmlns="http://www.w3.org/2000/svg"
    xmlns:xlink="http://www.w3.org/1999/xlink"
>
    <defs></defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-259.000000, -840.000000)" fill="currentColor">
            <g transform="translate(56.000000, 160.000000)">
                <path
                    d="M211.261065,690.694762 C209.623062,692.25443 206.966811,692.25443 205.328807,690.694762 L203.614251,689.062203 C202.79525,688.282368 202.79525,687.018258 203.614251,686.238424 C204.433253,685.45859 205.761903,685.45859 206.580905,686.238424 C207.721845,687.3248 208.972894,687.224949 209.777214,686.458096 C210.587827,685.686249 210.685352,684.498026 209.541266,683.409653 C208.722264,682.629819 208.722264,681.36471 209.541266,680.584876 C210.361317,679.805041 211.688918,679.805041 212.50792,680.584876 L214.22667,682.221429 C215.864674,683.781098 215.864674,686.310317 214.22667,687.869985 L223.356286,696.563988 C225.318325,698.431197 222.350623,701.253977 220.390682,699.387767 L211.261065,690.694762 Z"
                ></path>
            </g>
        </g>
    </g>
</svg>
`, D = class D extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = fe;
  }
};
o(D, "register", () => {
  customElements.get("svg-settings") || customElements.define("svg-settings", D);
});
let Tt = D;
const ve = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
>
    <path
        d="M4 6H20M4 12H20M4 18H20"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
    />
</svg>
`, B = class B extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ve;
  }
};
o(B, "register", () => {
  customElements.get("svg-menu") || customElements.define("svg-menu", B);
});
let Ht = B;
const we = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
>
    <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M15 6.75C15 5.50736 16.0074 4.5 17.25 4.5C18.4926 4.5 19.5 5.50736 19.5 6.75C19.5 7.99264 18.4926 9 17.25 9C16.0074 9 15 7.99264 15 6.75ZM17.25 3C15.1789 3 13.5 4.67893 13.5 6.75C13.5 7.00234 13.5249 7.24885 13.5724 7.48722L9.77578 9.78436C9.09337 8.85401 7.99222 8.25 6.75 8.25C4.67893 8.25 3 9.92893 3 12C3 14.0711 4.67893 15.75 6.75 15.75C8.10023 15.75 9.28379 15.0364 9.9441 13.9657L13.5866 16.4451C13.5299 16.7044 13.5 16.9737 13.5 17.25C13.5 19.3211 15.1789 21 17.25 21C19.3211 21 21 19.3211 21 17.25C21 15.1789 19.3211 13.5 17.25 13.5C15.9988 13.5 14.8907 14.1128 14.2095 15.0546L10.4661 12.5065C10.4884 12.3409 10.5 12.1718 10.5 12C10.5 11.7101 10.4671 11.4279 10.4049 11.1569L14.1647 8.88209C14.8415 9.85967 15.971 10.5 17.25 10.5C19.3211 10.5 21 8.82107 21 6.75C21 4.67893 19.3211 3 17.25 3ZM15 17.25C15 16.0074 16.0074 15 17.25 15C18.4926 15 19.5 16.0074 19.5 17.25C19.5 18.4926 18.4926 19.5 17.25 19.5C16.0074 19.5 15 18.4926 15 17.25ZM4.5 12C4.5 10.7574 5.50736 9.75 6.75 9.75C7.99264 9.75 9 10.7574 9 12C9 13.2426 7.99264 14.25 6.75 14.25C5.50736 14.25 4.5 13.2426 4.5 12Z"
        fill="currentColor"
    />
</svg>
`, Y = class Y extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = we;
  }
};
o(Y, "register", () => {
  customElements.get("svg-share") || customElements.define("svg-share", Y);
});
let Rt = Y;
const ye = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 512 512"
    xmlns="http://www.w3.org/2000/svg"
>
    <rect
        fill="none"
        stroke="currentColor"
        stroke-linejoin="round"
        stroke-width="32"
        x="48"
        y="80"
        width="416"
        height="384"
        rx="48"
    />
    <line
        fill="none"
        stroke="currentColor"
        stroke-linejoin="round"
        stroke-width="32"
        stroke-linecap="round"
        x1="128"
        y1="48"
        x2="128"
        y2="80"
    />
    <line
        fill="none"
        stroke="currentColor"
        stroke-linejoin="round"
        stroke-width="32"
        stroke-linecap="round"
        x1="384"
        y1="48"
        x2="384"
        y2="80"
    />
    <rect
        fill="none"
        stroke="currentColor"
        stroke-linejoin="round"
        stroke-width="32"
        stroke-linecap="round"
        x="112"
        y="224"
        width="96"
        height="96"
        rx="13"
    />
    <line
        fill="none"
        stroke="currentColor"
        stroke-linejoin="round"
        stroke-width="32"
        stroke-linecap="round"
        x1="464"
        y1="160"
        x2="48"
        y2="160"
    />
</svg>
`, J = class J extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ye;
  }
};
o(J, "register", () => {
  customElements.get("svg-today") || customElements.define("svg-today", J);
});
let St = J;
const ke = n`
    <style>
        * {
            box-sizing: border-box;
        }

        :host dialog * {
            box-sizing: border-box;
        }

        dialog {
            position: fixed !important;

            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);

            max-width: 100%;
            max-height: 100%;

            margin: 0;
            padding: 0;

            border: none;
            outline: none;

            background-color: transparent;

            -ms-overflow-style: none;
            scrollbar-width: none;

            z-index: 999;
        }

        dialog::-webkit-scrollbar {
            display: none;
        }

        dialog::backdrop {
            background-color: var(--ui-backdrop-bgColor);
            backdrop-filter: var(--ui-backdropFilter);
        }

        dialog > .container {
            background-color: var(--ui-bgColor);
            color: var(--ui-color);

            border: 1px solid var(--ui-borderColor);
            border-radius: var(--ui-radius);

            padding: var(--ui-spacing);

            display: flex;
            flex-direction: column;
            justify-content: space-between;

            position: relative;
        }

        :host([fullscreen]) dialog {
            width: 100%;
            height: 100%;
        }

        :host([fullscreen]) dialog > .container {
            width: calc(100% - var(--ui-spacing) * 2);
            height: calc(
                100% -
                    (
                        env(safe-area-inset-top, 0) +
                            env(safe-area-inset-bottom, 0) +
                            (var(--ui-spacing) * 2)
                    )
            );

            margin: var(--ui-spacing);
            margin-top: calc(env(safe-area-inset-top, 0) + var(--ui-spacing));
            margin-bottom: calc(
                env(safe-area-inset-bottom, 0) + var(--ui-spacing)
            );
        }

        /*
        * Header Styles
        */

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;

            border-top-right-radius: var(--ui-radius);
            border-top-left-radius: var(--ui-radius);

            width: 100%;
            height: var(--ui-dialog-header-height);
        }

        .header h4 {
            margin: auto 0;
        }

        :host([fullscreen]) .header {
            z-index: 15;
            position: absolute;
            top: var(--ui-spacing);
            right: var(--ui-spacing);
            left: var(--ui-spacing);
            width: calc(100% - var(--ui-spacing) * 2);
        }

        /*
        * Content Styles
        */

        .content {
            padding: var(--ui-spacing);
            height: fit-content;
            min-width: fit-content;
            width: 100%;
        }

        :host([fullscreen]) .content {
            z-index: 10;
            position: absolute;
            top: calc(var(--ui-dialog-header-height) + var(--ui-spacing));
            bottom: calc(var(--ui-dialog-footer-height) + var(--ui-spacing));
            right: var(--ui-spacing);
            left: var(--ui-spacing);
            padding: unset;
            height: unset;
            width: unset;
            min-width: unset;
        }

        /*
        * Footer Styles
        */

        .footer {
            margin-top: var(--ui-spacing);
            border-bottom-right-radius: var(--ui-radius);
            border-bottom-left-radius: var(--ui-radius);

            width: 100%;
            height: var(--ui-dialog-footer-height);
        }

        :host([fullscreen]) .footer {
            z-index: 15;
            position: absolute;
            right: var(--ui-spacing);
            bottom: var(--ui-spacing);
            left: var(--ui-spacing);
            width: calc(100% - var(--ui-spacing) * 2);
        }

        .footer ui-flex-grid-row {
            height: 100%;
            flex-wrap: nowrap;
            justify-content: flex-end;
            align-items: center;
        }
    </style>

    <dialog>
        <div class="container">
            <div class="header">
                <span style="white-space: nowrap;"
                    ><slot name="title"></slot
                ></span>

                <ui-icon-button
                    style="width: var(--ui-dialog-header-height); height: 100%;"
                    ghost
                >
                    <svg-close></svg-close>
                </ui-icon-button>
            </div>

            <div class="content">
                <slot></slot>
            </div>

            <div class="footer">
                <ui-flex-grid-row gap="calc(var(--ui-spacing) / 2)">
                    <slot name="actions"></slot>
                </ui-flex-grid-row>
            </div>
        </div>
    </dialog>
`, X = class X extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ke, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      /** @type {Events<T>} */
      events: new u(),
      /**
       * @private
       * @type {HTMLElement}
       */
      h4: (() => {
        const t = document.createElement("h4");
        return t.slot = "title", this.appendChild(t), t;
      })(),
      /**
       * @private
       * @type {HTMLDialogElement}
       */
      dialog: this.shadowRoot.querySelector("dialog"),
      getFullscreen() {
        return this.root.hasAttribute("fullscreen");
      },
      /**
       * @param {boolean} state
       */
      setFullscreen(t) {
        t ? this.root.setAttribute("fullscreen", "") : this.root.removeAttribute("fullscreen");
      },
      getTitle() {
        return this.h4.innerText;
      },
      /**
       * @param {string} value
       */
      setTitle(t) {
        this.h4.innerText = t;
      },
      getDialogElement() {
        return this.dialog;
      },
      open(t = !1, e = !0) {
        const i = this.dialog.inert;
        this.dialog.inert = e, t ? this.dialog.showModal() : this.dialog.show(), this.events.dispatch("open", null), this.dialog.inert = i;
      },
      close() {
        this.dialog.close(), this.events.dispatch("close", null);
      }
    };
  }
  connectedCallback() {
    const t = this.shadowRoot.querySelector(".header ui-icon-button"), e = () => {
      this.ui.close();
    };
    t.addEventListener("click", e);
    const i = this.shadowRoot.querySelector("dialog"), r = (l) => {
      l.preventDefault();
    };
    i.addEventListener("cancel", r), this.cleanup.add(() => {
      t.removeEventListener("click", e), i.removeEventListener("cancel", r);
    }), console.debug(this.shadowRoot.querySelector("svg-close"));
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
o(X, "register", () => {
  lt.register(), A.register(), M.register(), customElements.get("ui-dialog") || customElements.define("ui-dialog", X);
});
let $t = X;
const zt = 150, Ce = n`
    <style>
        * {
            box-sizing: border-box;
        }

        :host {
            display: block;

            position: absolute !important;
            z-index: ${zt};
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;

            overflow: hidden;

            transition: left 0s ease 0.5s;
        }

        :host([open]) {
            background-color: var(--ui-backdrop-bgColor);
            backdrop-filter: var(--ui-backdropFilter);

            left: 0;

            transition: none;
        }

        aside {
            position: absolute;
            z-index: ${zt};
            top: 0;
            left: -100%;
            width: 18em;
            max-width: 100%;
            height: 100%;

            overflow-x: hidden;
            overflow-y: auto;

            -ms-overflow-style: none;
            scrollbar-width: none;

            background-color: var(--ui-card-bgColor);
            color: var(--ui-card-color);
            border-right: 1px solid var(--ui-card-borderColor);
            /*
            background-color: var(--ui-backdrop-bgColor);
            backdrop-filter: var(--ui-backdropFilter);
            */

            transition: left 0.5s ease;
        }

        :host([open]) aside {
            left: 0;
        }
    </style>

    <aside>
        <slot></slot>
    </aside>
`, w = class w extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Ce, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      aside: this.shadowRoot.querySelector("aside"),
      /**
       * @type {Events<UIDrawerEvents>}
       */
      events: new u(),
      getOpen() {
        return this.root.hasAttribute("open");
      },
      /**
       * @param {boolean} state
       */
      setOpen(t) {
        t ? this.root.setAttribute("open", "") : this.root.removeAttribute("open");
      }
    };
  }
  connectedCallback() {
    const t = (i) => {
      i.stopPropagation(), this.ui.setOpen(!1);
    }, e = (i) => {
      i.stopPropagation();
    };
    this.addEventListener("click", t), this.ui.aside.addEventListener("click", e), this.cleanup.add(() => {
      this.ui.aside.removeEventListener("click", e), this.removeEventListener("click", t);
    });
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "open":
        i !== null ? (this.classList.add("open"), this.ui.events.dispatch("open", this)) : (this.classList.remove("open"), this.ui.events.dispatch("close", this));
        break;
    }
  }
};
o(w, "register", () => {
  customElements.get("ui-drawer") || customElements.define("ui-drawer", w);
}), o(w, "observedAttributes", ["open"]);
let jt = w;
const xe = n`
    <style>
        :host {
            font-size: 1.1rem;
            font-family: var(--ui-fontFamily);
            font-variation-settings: var(--ui-text-primary-fontVariation);
        }
    </style>

    <slot></slot>
`, K = class K extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = xe, this.cleanup = new a(), this.ui = {};
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
o(K, "register", () => {
  customElements.get("ui-primary") || customElements.define("ui-primary", K);
});
let T = K;
const Le = n`
    <style>
        :host {
            font-size: 0.9rem;
            font-family: var(--ui-fontFamily);
            font-variation-settings: var(--ui-text-secondary-fontVariation);
        }
    </style>

    <slot></slot>
`, Q = class Q extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Le, this.cleanup = new a(), this.ui = {};
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
o(Q, "register", () => {
  customElements.get("ui-secondary") || customElements.define("ui-secondary", Q);
});
let p = Q;
const Ee = n`
    <style>
        * {
            box-sizing: border-box;
        }

        :host {
            position: relative !important;
            display: flex !important;
            flex-direction: row;
            width: 100%;
            padding: var(--ui-spacing);
            border-radius: var(--ui-radius);
        }

        :host > .text {
            display: flex;
            flex: 1;
            flex-direction: column;
            justify-content: center;
            margin-right: var(--ui-spacing);
        }

        :host > .input {
            display: flex;
            align-items: center;
            justify-content: flex-end;
        }
    </style>

    <span class="text">
        <ui-primary></ui-primary>
        <ui-secondary></ui-secondary>
    </span>

    <span class="input">
        <slot name="input"></slot>
        <slot></slot>
    </span>
`, y = class y extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Ee, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      /** @private */
      running: !1,
      /**
       * @private
       * @type {(() => void|Promise<void>) | null}
       */
      removeRipple: null,
      /** @private */
      onClick: async () => {
        this.ui.getInputSlot().forEach((t) => t.click());
      },
      /** @private */
      onInputClick: async (t) => {
        t.stopPropagation();
      },
      getPrimary() {
        return this.root.getAttribute("primary");
      },
      /**
       * @param {string | null} value
       */
      setPrimary(t) {
        if (t === null) {
          this.root.removeAttribute("primary");
          return;
        }
        this.root.setAttribute("primary", t);
      },
      getSecondary() {
        return this.root.getAttribute("secondary");
      },
      /**
       * @param {string | null} value
       */
      setSecondary(t) {
        if (t === null) {
          this.root.removeAttribute("secondary");
          return;
        }
        this.root.setAttribute("secondary", t);
      },
      /**
       * @returns {HTMLElement[]}
       */
      getInputSlot() {
        return [...this.root.querySelectorAll('[slot="input"]')];
      },
      enableRipple() {
        this.removeRipple || (this.removeRipple = ot(this.root), this.root.style.cursor = "pointer", this.startInputHandling());
      },
      disableRipple() {
        this.removeRipple && this.removeRipple(), this.stopInputHandling();
      },
      /** @private */
      startInputHandling() {
        this.running || (this.root.addEventListener("click", this.onClick), this.getInputSlot().forEach((t) => {
          t.addEventListener("click", this.onInputClick);
        }), this.running = !0);
      },
      /**
       * @private
       */
      stopInputHandling() {
        this.root.removeEventListener("click", this.onClick), [...this.root.querySelectorAll('[slot="input"]')].forEach(
          (t) => {
            t.removeEventListener("click", this.onInputClick);
          }
        ), this.running = !1;
      }
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "ripple":
        i !== null ? this.ui.enableRipple() : this.ui.disableRipple();
        break;
      case "primary":
        this.shadowRoot.querySelector("ui-primary").innerHTML = i || "";
        break;
      case "secondary":
        this.shadowRoot.querySelector("ui-secondary").innerHTML = i || "";
        break;
    }
  }
};
o(y, "register", () => {
  T.register(), p.register(), customElements.get("ui-label") || customElements.define("ui-label", y);
}), o(y, "observedAttributes", ["ripple", "secondary", "primary"]);
let qt = y;
const Me = n`
    <style>
        * {
            box-sizing: border-box;
        }

        li {
            padding: var(--ui-spacing) calc(var(--ui-spacing) * 1.5);
            display: flex;
            flex-direction: row;
            flex-wrap: nowrap;
        }

        ::slotted(*) {
            width: 100%;
        }
    </style>

    <li>
        <slot></slot>
    </li>
`, W = class W extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Me, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      /**
       * @returns {boolean}
       */
      getOpen() {
        return this.root.hasAttribute("open");
      },
      /**
       * @param {boolean} state
       */
      setOpen(t) {
        t ? this.root.setAttribute("open", "") : this.root.removeAttribute("open");
      }
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
o(W, "register", () => {
  customElements.get("ui-drawer-group-item") || customElements.define("ui-drawer-group-item", W);
});
let ht = W;
const Ae = n`
    <style>
        * {
            box-sizing: border-box;
        }

        ul {
            list-style: none;
            padding: var(--ui-spacing);
            overflow: hidden;
        }

        ui-drawer-group-item:not(.visible) {
            display: none;
        }
    </style>

    <ul>
        <ui-drawer-group-item class="ui-drawer-group-title">
        </ui-drawer-group-item>

        <slot></slot>
    </ul>
`, k = class k extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Ae, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      getTitle() {
        return this.root.getAttribute("title") || null;
      },
      /**
       * @param {string} value
       */
      setTitle(t) {
        let e = this.root.shadowRoot.querySelector(
          ".ui-drawer-group-title"
        );
        e.classList.add("visible"), e.innerHTML = `
                    <span
                        style="
                            font-size: 1.5rem;
                            font-weight: 600;
                            font-variation-settings: var(--ui-heading-fontVariation);
                        "
                    >
                        ${t}
                    </span>
                `;
      },
      removeTitle() {
        this.root.shadowRoot.querySelector(
          ".ui-drawer-group-title"
        ).classList.remove("visible");
      }
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "title":
        i === "" ? this.removeAttribute("title") : i !== null ? this.ui.setTitle(i) : this.ui.removeTitle();
        break;
    }
  }
};
o(k, "register", () => {
  ht.register(), T.register(), customElements.get("ui-drawer-group") || customElements.define("ui-drawer-group", k);
}), o(k, "observedAttributes", ["title"]);
let Pt = k;
const Te = n`
    <style>
        :host {
            display: block;
            position: relative;
            width: 100%;
        }

        input {
            width: calc(100% - var(--ui-spacing) * 4);
            display: block;
            margin: 0;
            padding: var(--ui-spacing) calc(var(--ui-spacing) * 2);
            border: none !important;
            border-radius: inherit;
            outline: none !important;
            font-size: 0.9rem;
            font-family: var(--ui-fontFamily);
            font-variation-settings: var(--ui-input-fontVariation);
            accent-color: var(--ui-primary-bgColor);
            background-color: transparent !important;
        }

        .container {
            width: 100%;
            border: none;
            border-bottom: 1px solid var(--ui-borderColor);
            border-radius: 0;
            transition: border-color 0.25s linear;
        }

        .container:has(input:focus) {
            border-color: var(--ui-primary-bgColor);
        }

        :host([invalid]) .container {
            border-color: var(--ui-destructive-bgColor);
        }

        ::slotted([slot="title"]) {
            display: block;
            padding: 0 var(--ui-spacing);
            user-select: none;
            transform: translateY(calc(var(--ui-spacing) / 2));
        }
    </style>

    <div class="container">
        <slot name="title"></slot>
        <input />
    </div>
`, C = class C extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Te, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      input: (() => {
        const t = this.shadowRoot.querySelector("input");
        return t.type = this.getAttribute("type") || "text", t.oninput = () => this.ui.events.dispatch("input", this.ui.getValue()), t.onchange = () => this.ui.events.dispatch("change", this.ui.getValue()), t;
      })(),
      /**
       * @type {Events<E>}
       */
      events: new u(),
      /**
       * @param {string | null} v
       */
      setTitle(t) {
        if (t === null) {
          this.root.removeAttribute("title");
          return;
        }
        this.root.setAttribute("title", t);
      },
      getTitle() {
        return this.root.getAttribute("title");
      },
      /**
       * @param {UIInputTypes | null} value
       */
      setType(t) {
        if (t === null) {
          this.root.removeAttribute("type");
          return;
        }
        this.root.setAttribute("type", t);
      },
      /**
       * @returns {UIInputTypes}
       */
      getType() {
        return this.root.getAttribute("type") || "text";
      },
      /**
       * @param {UIInputTypeValues[T] | null} value
       */
      setValue(t) {
        if (t === null) {
          this.root.removeAttribute("value");
          return;
        }
        this.root.setAttribute("value", t.toString());
      },
      /**
       * @returns {UIInputTypeValues[T]}
       */
      getValue() {
        const t = this.input.value;
        switch (this.getType()) {
          case "number":
            return t ? parseFloat(t) : NaN;
          default:
            return t;
        }
      },
      /**
       * @param {string | null} value
       */
      setPlaceholder(t) {
        if (t === null) {
          this.root.removeAttribute("placeholder");
          return;
        }
        this.root.setAttribute("placeholder", t);
      },
      /**
       * @returns {string}
       */
      getPlaceholder() {
        return this.root.getAttribute("placeholder");
      },
      /**
       * @param {boolean} state
       */
      setInvalid(t) {
        if (t === null || t === !1) {
          this.root.removeAttribute("invalid");
          return;
        }
        this.root.setAttribute("invalid", "");
      },
      /**
       * @returns {boolean}
       */
      getInvalid() {
        return this.root.hasAttribute("invalid");
      },
      /**
       * @param {UIInputTypeValues[T] | null} n
       */
      setMin(t) {
        if (t === null) {
          this.root.removeAttribute("min");
          return;
        }
        this.root.setAttribute("min", t.toString());
      },
      /**
       * @returns {UIInputTypeValues[T]}
       */
      getMin() {
        const t = this.root.getAttribute("min");
        switch (this.input.type) {
          case "number":
            return t ? parseFloat(t) : NaN;
          default:
            return t;
        }
      },
      /**
       * @param {UIInputTypeValues[T] | null} n
       */
      setMax(t) {
        t === null && this.root.removeAttribute("max"), this.root.setAttribute("max", t.toString());
      },
      /**
       * @returns {UIInputTypeValues[T]}
       */
      getMax() {
        const t = this.root.getAttribute("max");
        switch (this.input.type) {
          case "number":
            return t ? parseFloat(t) : NaN;
          default:
            return t;
        }
      }
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "title":
        let r = this.querySelector('[slot="title"]');
        if (i === null && r && (this.removeChild(r), r = null), i === null)
          return;
        r || (r = new p(), r.slot = "title", this.appendChild(r)), r.innerHTML = i;
        break;
      case "type":
        this.ui.input.value = i || "text";
        break;
      case "value":
        this.ui.input.value = (i || "").toString();
        break;
      case "placeholder":
        this.ui.input.placeholder = i || "";
        break;
      case "invalid":
        this.ui.input.ariaInvalid = i;
        break;
      case "min":
        this.ui.input.min = i || "";
        break;
      case "max":
        this.ui.input.max = i || "";
        break;
    }
  }
};
o(C, "register", () => {
  p.register(), customElements.get("ui-input") || customElements.define("ui-input", C);
}), o(C, "observedAttributes", [
  "title",
  "type",
  "value",
  "placeholder",
  "invalid",
  "min",
  "max"
]);
let Ft = C;
const He = n`
    <style>
        :host {
            display: none;
            align-items: center;

            padding: var(--ui-spacing);
            padding-right: 2rem;

            height: calc(1em * var(--ui-lineHeight) + var(--ui-spacing) * 2);

            white-space: nowrap;
            text-overflow: ellipsis;

            transition:
                background-color 0.25s linear,
                color 0.25s linear;

            overflow: hidden;
        }
    </style>

    <slot></slot>
`, G = class G extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = He, this.setAttribute("role", "button"), this.ui = {
      /** @private */
      root: this,
      getValue() {
        return this.root.getAttribute("value");
      },
      /**
       * @param {string | null} value
       */
      setValue(t) {
        if (t === null) {
          this.root.removeAttribute("value");
          return;
        }
        this.root.setAttribute("value", t);
      },
      getSelected() {
        return this.root.hasAttribute("selected");
      },
      /**
       * @param {boolean} state
       */
      setSelected(t) {
        if (!t) {
          this.root.removeAttribute("selected");
          return;
        }
        this.root.setAttribute("selected", "");
      }
    };
  }
};
o(G, "register", () => {
  customElements.get("ui-select-option") || customElements.define("ui-select-option", G);
});
let H = G;
const Re = n`
    <style>
        * {
            box-sizing: border-box;
        }

        :host {
            --ui-bgColor: "transparent";
            --items-length: 0;

            position: relative !important;
            display: block !important;

            width: 100%;
            height: calc(1em * var(--ui-lineHeight) + var(--ui-spacing) * 2);
            transition: height 0.25s ease;

            background-color: var(--ui-bgColor);
            color: var(--ui-color);

            border: 1px solid var(--ui-borderColor);
            border-radius: var(--ui-radius);

            line-height: 1.15;

            overflow: hidden;

            font-size: 0.9rem;
            font-family: var(--ui-fontFamily);
            font-variation-settings: var(--ui-select-fontVariation);
        }

        .options {
            cursor: pointer;
            display: none;
            display: flex;
            flex-direction: column;
            min-height: 100%;
        }

        .icon {
            display: flex;
            justify-content: center;
            align-items: center;
            position: absolute;
            top: 0;
            right: 0;
            width: 2.5rem;
            height: 100%;
            color: var(--ui-primary-bgColor);
        }

        ::slotted(ui-select-option) {
            display: flex;
        }

        :host(.open) {
            height: calc(
                (1em * var(--ui-lineHeight) + var(--ui-spacing) * 2) *
                    var(--items-length)
            );
        }

        :host(.open) .options {
            display: block;
        }

        :host(.open) .icon {
            display: none;
        }

        :host(.open) ::slotted(ui-select-option[selected]) {
            background-color: var(--ui-primary-bgColor);
            color: var(--ui-primary-color);
        }

        :host(.open) ::slotted(ui-select-option:not([selected]):hover) {
            background-color: hsla(var(--ui-color-hsl), 0.1);
        }

        :host(:not(.open))
            .options:has(> ::slotted(ui-select-option[selected])) {
            display: block;
        }

        :host(:not(.open)) ::slotted(ui-select-option:not([selected])) {
            display: none;
        }
    </style>

    <div class="options">
        <div class="icon"><svg-chevron-down></svg-chevron-down></div>

        <slot></slot>
    </div>
`, I = class I extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Re, this.cleanup = new a(), this.ui = {
      /**
       *  @type {Events<UISelectEvents>}
       */
      events: new u()
    };
  }
  connectedCallback() {
    const t = this.shadowRoot.querySelector(".options"), e = async (r) => {
      (r.composedPath() || []).forEach((l) => {
        l instanceof H && ([...this.querySelectorAll("ui-select-option")].forEach(
          (c) => c.removeAttribute("selected")
        ), l.setAttribute("selected", ""), this.ui.events.dispatch("change", l));
      });
    }, i = (r) => {
      this.classList.toggle("open") ? (r.stopPropagation(), this.addEventListener("click", e)) : setTimeout(() => this.removeEventListener("click", e));
    };
    t.addEventListener("click", i), this.cleanup.add(() => {
      this.removeEventListener("click", i), t.removeEventListener("click", i);
    }), this.style.setProperty(
      "--items-length",
      this.querySelectorAll("ui-select-option").length.toString()
    );
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
o(I, "register", () => {
  at.register(), H.register(), customElements.get("ui-select") || customElements.define("ui-select", I);
});
let Nt = I;
const Se = n`
    <style>
        * {
            box-sizing: border-box;
        }

        :host {
            display: block;
            position: relative;
            width: 100%;
        }

        input {
            width: calc(100% - var(--ui-spacing) * 4);
            display: block;
            margin: 0;
            padding: var(--ui-spacing) calc(var(--ui-spacing) * 2);
            border: none !important;
            border-radius: inherit;
            outline: none !important;
            font-size: 0.9rem;
            font-family: var(--ui-fontFamily);
            font-variation-settings: var(--ui-input-fontVariation);
            accent-color: var(--ui-primary-bgColor);
            background-color: transparent !important;
        }

        .container {
            position: relative;
            width: 100%;
            border: none;
            border: 1px solid var(--ui-borderColor);
            border-radius: var(--ui-radius);
            transition: border-color 0.25s linear;
            background-color: var(--ui-backdrop-bgColor);
            backdrop-filter: var(--ui-backdropFilter);
        }

        .container:has(input:focus) {
            border-color: var(--ui-primary-bgColor);
        }

        :host([invalid]) .container {
            border-color: var(--ui-destructive-bgColor);
        }

        ::slotted([slot="title"]) {
            display: block;
            padding: 0 var(--ui-spacing);
            user-select: none;
            transform: translateY(calc(var(--ui-spacing) / 2));
        }

        ui-icon-button {
            position: absolute;
            top: 0;
            right: 0;
            height: 100%;
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }
    </style>

    <div class="container">
        <slot name="title"></slot>
        <input type="search" />
        <ui-icon-button ghost>
            <svg-search></svg-search>
        </ui-icon-button>
    </div>
`, x = class x extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Se, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      submit: (() => {
        const t = this.shadowRoot.querySelector("ui-icon-button");
        return t.ui.events.on("click", () => {
          this.ui.events.dispatch("submit", this.ui.getValue());
        }), t;
      })(),
      input: (() => {
        const t = this.shadowRoot.querySelector("input");
        return t.type = "text", t.onkeydown = (e) => {
          e.key === "Enter" && this.ui.submit.click();
        }, t.oninput = () => this.ui.events.dispatch("input", t.value), t.onchange = () => this.ui.events.dispatch("change", t.value), t;
      })(),
      /** @type {Events<E>} */
      events: new u(),
      /**
       * @param {string | null} value
       */
      setTitle(t) {
        t === null ? this.root.removeAttribute("title") : this.root.setAttribute("title", t);
      },
      getTitle() {
        return this.root.getAttribute("title");
      },
      /**
       * @param {string | null} value
       */
      setValue(t) {
        if (t === null) {
          this.root.removeAttribute("value");
          return;
        }
        this.root.setAttribute("value", t);
      },
      getValue() {
        return this.input.value;
      },
      /**
       * @param {string | null} value
       */
      setPlaceholder(t) {
        if (t === null) {
          this.root.removeAttribute("placeholder");
          return;
        }
        this.root.setAttribute("placeholder", t);
      },
      /**
       * @returns {string}
       */
      getPlaceholder() {
        return this.root.getAttribute("placeholder");
      },
      /**
       * @param {boolean} state
       */
      setInvalid(t) {
        if (t === null || t === !1) {
          this.root.setAttribute("invalid", "");
          return;
        }
        this.root.removeAttribute("invalid");
      },
      /**
       * @returns {boolean}
       */
      getInvalid() {
        return this.root.hasAttribute("invalid");
      }
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "title":
        let r = this.querySelector('[slot="title"]');
        i === null && r && (this.removeChild(r), r = null), r || (r = new p(), r.slot = "title", this.appendChild(r)), r.innerHTML = i || "";
        break;
      case "value":
        this.ui.input.value = i || "";
        break;
      case "placeholder":
        this.ui.input.placeholder = i || "";
        break;
      case "invalid":
        this.ui.input.ariaInvalid = i !== null ? "" : null;
        break;
    }
  }
};
o(x, "register", () => {
  p.register(), A.register(), ct.register(), customElements.get("ui-search") || customElements.define("ui-search", x);
}), o(x, "observedAttributes", ["title", "value", "placeholder", "invalid"]);
let Zt = x;
const L = class L extends HTMLElement {
  constructor() {
    super(), this.ui = {
      /** @private */
      root: this,
      /**
       * @private
       * @type {Events<{ "change": UILangType}>}
       */
      events: new u(),
      /**
       * @type {{
       *  [key: string]: {
       *      [key: string]: string;
       *  };
       * }}
       */
      data: {},
      /**
       *@type {UILangType | null}
       */
      langType: null,
      getCurrent() {
        return this.root.getAttribute("current");
      },
      /**
       * @param {string | null} v
       */
      setCurrent(t) {
        if (t === null) {
          this.root.removeAttribute("current");
          return;
        }
        this.root.setAttribute("current", t);
      },
      /**
       * @returns {UILangType}
       */
      getFallbackElement() {
        return this.root.querySelector("ui-lang-type[fallback]");
      },
      /**
       * @param {UILangType} langType
       * @param {{
       *  [key: string]: {
       *      [key: string]: string;
       *  };
       * }} data
       */
      new(t, e) {
        this.langType = t, this.data = e, this.events.dispatch("change", this.langType);
      },
      /**
       * @param {string} group
       * @param {string} key
       */
      get(t, e) {
        var i, r;
        return ((r = (i = this.data) == null ? void 0 : i[t]) == null ? void 0 : r[e]) || null;
      },
      /**
       * @param {"change"} key
       * @param {(langType: UILangType | null) => void|Promise<void>} callback
       * @param {boolean} [trigger] - this will run the callback first
       * @returns {() => void} clean up function
       */
      on(t, e, i = !1) {
        if (typeof e != "function")
          throw "callback is not a function";
        return i && e(this.langType), this.events.on(t, e);
      }
    };
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "current":
        i !== null && this.loadLanguage(i);
        break;
    }
  }
  /**
   * @private
   * @param {string} name
   */
  async loadLanguage(t) {
    const e = this.querySelector(`ui-lang-type[name="${t}"]`) || this.ui.getFallbackElement();
    if (!e)
      return;
    if (!e.ui.getHref())
      throw "Missing href attribute!";
    const i = await fetch(e.ui.getHref());
    this.ui.new(e, await i.json());
  }
};
o(L, "register", () => {
  customElements.get("ui-lang") || customElements.define("ui-lang", L);
}), o(L, "observedAttributes", ["current"]);
let Ot = L;
const U = class U extends HTMLElement {
  constructor() {
    super(), this.ui = {
      /** @private */
      root: this,
      getName() {
        return this.root.getAttribute("name");
      },
      /**
       * @param {string | null} value
       */
      setName(t) {
        if (t === null) {
          this.root.removeAttribute("name");
          return;
        }
        this.root.setAttribute("name", t);
      },
      getHref() {
        return this.root.getAttribute("href");
      },
      /**
       * @param {string | null} value
       */
      setHref(t) {
        if (t === null) {
          this.root.removeAttribute("href");
          return;
        }
        this.root.setAttribute("href", t);
      },
      getFallback() {
        return this.root.hasAttribute("fallback");
      },
      /**
       * @param {boolean} state
       */
      setFallback(t) {
        if (!t) {
          this.root.removeAttribute("fallback");
          return;
        }
        this.root.setAttribute("fallback", "");
      }
    };
  }
};
o(U, "register", () => {
  customElements.get("ui-lang-type") || customElements.define("ui-lang-type", U);
});
let Vt = U;
const $e = n`
    <style>
        .background {
            z-index: 999;
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            background-color: var(--ui-backdrop-bgColor);
            backdrop-filter: var(--ui-backdropFilter);
        }

        .spinner {
            z-index: 1000;
            content: "";
            box-sizing: border-box;
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2.5rem;
            height: 2.5rem;
            margin-top: -1.25rem;
            margin-left: -1.25rem;
            border-radius: 50%;
            border: 2px solid var(--ui-borderColor);
            border-top-color: var(--ui-primary-bgColor);
            animation: spinner 0.6s linear infinite;
        }

        @keyframes spinner {
            to {
                transform: rotate(360deg);
            }
        }
    </style>

    <div class="background"></div>
    <div class="spinner"></div>
`, _ = class _ extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = $e, this.cleanup = new a(), this.ui = {};
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
o(_, "register", () => {
  customElements.get("ui-spinner") || customElements.define("ui-spinner", _);
});
let Dt = _;
const ze = n`
    <style>
        :host {
            display: block !important;
            position: absolute !important;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            animation: fade-in 0.5s;
            transition: opacity 0.5s ease;
        }

        :host(:last-child) {
            opacity: 1;
        }

        @keyframes fade-in {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }
    </style>

    <slot></slot>
`, tt = class tt extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ze, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      getName() {
        return this.root.getAttribute("name");
      },
      /**
       * @param {string | null} value
       */
      setName(t) {
        t === null && this.root.removeAttribute("name"), this.root.setAttribute("name", t);
      }
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
o(tt, "register", () => {
  customElements.get("ui-stack-layout-page") || customElements.define("ui-stack-layout-page", tt);
});
let ut = tt;
const je = n`
    <style>
        :host {
            display: block !important;
            position: relative !important;
            width: 100%;
            height: 100%;
        }
    </style>

    <slot></slot>
`, et = class et extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = je, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      /**
       * @private
       * @type {UIPages}
       */
      pages: {},
      /**
       * @private
       * @type {UIStackLayoutPage[]}
       */
      stack: [],
      /**
       * @type {Events<{ "change": { oldPage: UIStackLayoutPage | null, newPage: UIStackLayoutPage | null } }>}
       */
      events: new u(),
      lock: !1,
      /**
       * @param {string} name
       * @param {() => (UIStackLayoutPage)} cb
       */
      registerPage(t, e) {
        this.pages[t] = e;
      },
      /**
       * @param {string} name
       */
      unregisterPage(t) {
        delete this.pages[t];
      },
      clearStack() {
        for (; this.stackSize() > 0; )
          this.root.removeChild(this.stack.pop());
      },
      stackSize() {
        return this.stack.length;
      },
      goBack() {
        if (!this.stack.length || this.lock)
          return;
        const t = this.root.removeChild(this.stack.pop());
        this.stack.length > 0 && (this.stack[this.stack.length - 1].parentElement || this.root.appendChild(
          this.stack[this.stack.length - 1]
        )), this.dispatchChangeEvent(t);
      },
      /**
       * @param {string} name
       * @param {((page: UIStackLayoutPage) => void|Promise<void>) | null} [cb]
       * @param {boolean} [keepOldPage]
       */
      setPage(t, e = null, i = !1) {
        if (this.lock)
          return;
        const r = this.pages[t]();
        this.stack.push(this.root.appendChild(r)), typeof e == "function" && setTimeout(() => e(r));
        let l = null;
        this.stack.length > 1 && !i && (l = this.stack[this.stack.length - 2], l.parentElement.removeChild(l)), this.dispatchChangeEvent(l);
      },
      /**
       * @param {UIStackLayoutPage} oldChild
       */
      async dispatchChangeEvent(t) {
        this.events.dispatch("change", {
          newPage: this.stack[this.stack.length - 1] || null,
          oldPage: t || this.stack[this.stack.length - 2] || null
        });
      }
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
o(et, "register", () => {
  ut.register(), customElements.get("ui-stack-layout") || customElements.define("ui-stack-layout", et);
});
let Bt = et;
const it = class it extends HTMLElement {
  constructor() {
    super(), this.ui = {
      /** @private */
      root: this,
      /**
       * @type {any}
       */
      stores: {},
      /**
       * @type {Events<T>}
       */
      events: new u(),
      getLocalStoragePrefix() {
        return this.root.getAttribute("local-storage-prefix");
      },
      /**
       * @param {string | null} prefix
       */
      setLocalStoragePrefix(t) {
        if (t === null) {
          this.root.removeAttribute("local-storage-prefix");
          return;
        }
        this.root.setAttribute("local-storage-prefix", t);
      },
      getEnableLocalStorage() {
        return this.root.hasAttribute("enable-local-storage");
      },
      /**
       * @param {boolean} state
       */
      setEnableLocalStorage(t) {
        if (!t) {
          this.root.removeAttribute("enable-local-storage");
          return;
        }
        this.root.setAttribute("enable-local-storage", "");
      },
      /**
       * @template {keyof T} K
       * @param {K} key
       * @returns {T[K]}
       */
      get(t) {
        return this.stores[t];
      },
      /**
       * @template {keyof T} K
       * @param {K} key
       * @param {T[K]} data
       * @param {boolean} [useDataAsFallback] Use data as fallback, if nothing found in the browsers `localStorage`
       * `this.enableLocalStorage` flag needs to be set to `true` for this to work
       */
      set(t, e, i = !1) {
        if (i && this.getEnableLocalStorage()) {
          const r = JSON.parse(
            localStorage.getItem(
              this.getLocalStoragePrefix() + t.toString()
            ) || "null"
          );
          this.stores[t] = r ?? e;
        } else
          this.stores[t] = e;
        this.getEnableLocalStorage() && localStorage.setItem(
          this.getLocalStoragePrefix() + t.toString(),
          JSON.stringify(this.stores[t])
        ), this.events.dispatch(t, this.stores[t]);
      },
      /**
       * @template {keyof T} K
       * @param {K} key
       * @param {(data: T[K]) => any} callback
       */
      update(t, e) {
        if (typeof e != "function")
          throw "callback is not a function";
        this.set(t, e(this.stores[t]));
      },
      /**
       * @template {keyof T} K
       * @param {K} key
       * @param {(data: T[K]) => void|Promise<void>} callback
       * @param {boolean} [trigger] - this will run the callback first
       * @returns {() => void} clean up function
       */
      on(t, e, i = !1) {
        if (typeof e != "function")
          throw "callback is not a function";
        return i && e(this.get(t)), this.events.on(t, e);
      }
    };
  }
};
o(it, "register", () => {
  customElements.get("ui-store") || customElements.define("ui-store", it);
});
let Yt = it;
const E = class E extends HTMLElement {
  constructor() {
    super(), this.ui = {
      /**
       * @private
       * @type {MediaQueryList | null}
       */
      media: null,
      /**
       * @type {{ name: string; href: string } | null}
       */
      currentTheme: null,
      /**
       * @type {{ [key: string]: string }}
       */
      themes: {},
      enableAutoMode() {
        if (this.removeMode(), this.media) {
          this.mediaChangeHandler(this.media);
          return;
        }
        this.media = window.matchMedia("(prefers-color-scheme: dark)"), this.media.addEventListener("change", this.mediaChangeHandler), this.mediaChangeHandler(this.media);
      },
      disableAutoMode() {
        this.removeMedia();
      },
      /**
       * @param {string} name
       * @param {string} href
       */
      addTheme(t, e) {
        this.themes[t] = e;
      },
      /**
       * @param {string} name
       */
      loadTheme(t) {
        var i;
        if (!this.themes[t])
          throw `theme "${t}" is missing in this.themes`;
        if (((i = this.currentTheme) == null ? void 0 : i.name) == t)
          return;
        {
          const r = document.getElementById("theme");
          r && (document.head.removeChild(r), this.currentTheme = null);
        }
        const e = document.createElement("link");
        e.id = "theme", e.rel = "stylesheet", e.href = this.themes[t], document.head.appendChild(e), this.currentTheme = { name: t, href: this.themes[t] };
      },
      /**
       * @param {MediaQueryListEvent | MediaQueryList} ev
       */
      mediaChangeHandler(t) {
        t.matches ? document.body.setAttribute("data-theme", "dark") : document.body.setAttribute("data-theme", "light");
      },
      /**
       * @param {HTMLElement} element
       */
      removeMode(t = document.body) {
        t.removeAttribute("data-theme");
      },
      /**
       * @param {UIMode} mode
       * @param {HTMLElement} element
       */
      setMode(t, e = document.body) {
        switch (t) {
          case "dark":
            e.setAttribute("data-theme", t);
            break;
          case "light":
            e.setAttribute("data-theme", t);
            break;
        }
      },
      /**
       * @private
       */
      removeMedia() {
        this.media && (this.media.removeEventListener(
          "change",
          this.mediaChangeHandler
        ), this.media = null);
      }
    };
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "auto":
        i !== null ? this.ui.enableAutoMode() : this.ui.disableAutoMode();
        break;
      case "mode":
        i !== null ? this.ui.setMode(i) : this.ui.removeMode();
        break;
    }
  }
};
o(E, "register", () => {
  customElements.get("ui-theme-handler") || customElements.define("ui-theme-handler", E);
}), o(E, "observedAttributes", ["auto", "mode"]);
let Jt = E;
export {
  Ct as SvgAdd,
  xt as SvgBackArrow,
  at as SvgChevronDown,
  lt as SvgClose,
  Lt as SvgDownload,
  Et as SvgEdit,
  Ht as SvgMenu,
  Mt as SvgPDF,
  At as SvgRecycle,
  ct as SvgSearch,
  Tt as SvgSettings,
  Rt as SvgShare,
  St as SvgToday,
  vt as UIAppBar,
  wt as UIAppBarItem,
  yt as UIButton,
  kt as UIContainer,
  $t as UIDialog,
  jt as UIDrawer,
  Pt as UIDrawerGroup,
  ht as UIDrawerGroupItem,
  ft as UIFlexGrid,
  bt as UIFlexGridItem,
  M as UIFlexGridRow,
  A as UIIconButton,
  Ft as UIInput,
  qt as UILabel,
  Ot as UILang,
  Vt as UILangType,
  T as UIPrimary,
  Zt as UISearch,
  p as UISecondary,
  Nt as UISelect,
  H as UISelectOption,
  Dt as UISpinner,
  Bt as UIStackLayout,
  ut as UIStackLayoutPage,
  Yt as UIStore,
  Jt as UIThemeHandler,
  Pe as js
};
