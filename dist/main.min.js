var Ae = Object.defineProperty;
var Re = (o, t, e) => t in o ? Ae(o, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : o[t] = e;
var r = (o, t, e) => (Re(o, typeof t != "symbol" ? t + "" : t, e), e), jt = (o, t, e) => {
  if (!t.has(o))
    throw TypeError("Cannot " + e);
};
var i = (o, t, e) => (jt(o, t, "read from private field"), e ? e.call(o) : t.get(o)), l = (o, t, e) => {
  if (t.has(o))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(o) : t.set(o, e);
}, c = (o, t, e, s) => (jt(o, t, "write to private field"), s ? s.call(o, e) : t.set(o, e), e);
const zt = {
  onDragStart: null,
  onDragging: null,
  onDragEnd: null
};
function $e(o, t = {}) {
  t = {
    ...zt,
    ...t
  };
  const e = () => {
    const g = [...o.parentNode.children].indexOf(o);
    o.draggable = !0, o.ondragstart = (m) => {
      m.dataTransfer.effectAllowed = "move", m.dataTransfer.dropEffect = "move", m.dataTransfer.setData(
        "text/plain",
        g.toString()
      ), t.onDragStart && t.onDragStart(g);
    }, o.ondragover = (m) => (m.preventDefault(), !1), o.ondragenter = (m) => {
      m.preventDefault(), t.onDragging && t.onDragging(g);
    }, o.ondrop = (m) => {
      m.preventDefault(), m.dataTransfer.dropEffect = "move";
      const He = parseInt(
        m.dataTransfer.getData("text/plain"),
        10
      );
      t.onDragEnd && t.onDragEnd(He, g);
    };
  }, s = () => {
    o.draggable = !1, o.ondragstart = null, o.ondragover = null, o.ondragenter = null, o.ondrop = null;
  };
  return e(), {
    /**
     * @param {DraggableOptions} _options
     */
    update(a) {
      t = {
        ...zt,
        ...a
      }, s(), e();
    },
    destroy: s
  };
}
var f;
class A {
  constructor() {
    /**
     * @type {any}
     */
    l(this, f, {});
  }
  /**
   * @template {keyof T} K
   * @param {K} key
   * @param {((data: T[K]) => void|Promise<void>) | null} listener
   * @returns {() => void} clean up function
   */
  on(t, e) {
    if (typeof e != "function")
      throw `invalid event listener passed for "${t.toString()}" event!`;
    return i(this, f)[t] || (i(this, f)[t] = []), i(this, f)[t].push(e), () => {
      this.off(t, e);
    };
  }
  // }}}
  /**
   * @template {keyof T} K
   * @param {K} key
   * @param {((data: T[K]) => void|Promise<void>)} listener
   */
  off(t, e) {
    if (!i(this, f)[t])
      throw `no listeners found for ${t.toString()}, there is nothing to delete`;
    let s = !1, a = 0;
    for (const g of i(this, f)[t])
      g === e && (i(this, f)[t].splice(a, 1), s = !0), a++;
    if (!s)
      throw `listener not found for ${t.toString()}, there is nothing to delete`;
    return this;
  }
  // }}}
  /**
   * @template {keyof T} K
   * @param {K} key
   * @param {T[K]} data
   */
  dispatch(t, e) {
    if (e === void 0)
      throw "data is undefined!";
    if (i(this, f)[t])
      for (const s of i(this, f)[t])
        s(e);
    return this;
  }
  // }}}
}
f = new WeakMap();
function Nt(o, t) {
  const e = document.createElement("div");
  e.classList.add("ripple"), e.style.position = "absolute", e.style.color = "inherit", e.style.borderRadius = "50%", e.style.pointerEvents = "none", e.style.width = "100px", e.style.height = "100px", e.style.marginTop = "-50px", e.style.marginLeft = "-50px", e.style.opacity = `${t.opacity}`, e.style.backgroundColor = t.color, e.style.transform = "scale(0) translate(0, 0)", e.style.transition = `transform ${t.spreadDuration} ${t.spreadTiming} 0s,opacity ${t.clearDuration} ${t.clearTiming} 0s`, o.currentTarget.appendChild(e);
  const s = o.currentTarget.getBoundingClientRect();
  t.centered ? (e.style.top = `${s.height / 2}px`, e.style.left = `${s.width / 2}px`) : (e.style.top = `${o.clientY - s.top}px`, e.style.left = `${o.clientX - s.left}px`);
  const a = Math.max(s.width, s.height) * 0.02;
  return e.style.transform = `scale(${a}) translate(0, 0)`, e;
}
function Zt(o) {
  o && (o.addEventListener("transitionend", (t) => {
    t.propertyName === "opacity" && o.remove();
  }), o.style.opacity = "0");
}
const xe = {
  color: "var(--ui-ripple-color, currentColor)",
  opacity: "var(--ui-ripple-opacity, 0.2)",
  centered: !1,
  spreadDuration: ".4s",
  spreadTiming: "linear",
  clearDuration: "1s",
  clearTiming: "ease-in-out",
  useClick: !1
};
function Et(o, t = {}) {
  t = { ...xe, ...t };
  let e;
  const s = (g) => {
    e = Nt(g, t);
  }, a = () => {
    Zt(e);
  };
  return o.classList.add("ripple-container"), o.style.overflow = "hidden", t.useClick === !0 ? o.addEventListener("click", (g) => {
    e = Nt(g, t), Zt(e);
  }) : (o.addEventListener("pointerdown", s), o.addEventListener("pointerup", a), o.addEventListener("pointerleave", a)), () => {
    o.classList.remove("ripple-container"), o.removeEventListener("pointerdown", s), o.removeEventListener("pointerup", a), o.removeEventListener("pointerleave", a);
  };
}
function Se() {
  return /(android)/i.test(navigator.userAgent);
}
const n = String.raw, qe = String.raw;
class h {
  constructor() {
    this.callbacks = [];
  }
  /**
   * @param {(() => void|Promise<void>)} cb
   */
  add(t) {
    this.callbacks.push(t);
  }
  async run() {
    for (let t = 0; t < this.callbacks.length; t++)
      if (this.callbacks[t] !== null)
        try {
          await this.callbacks[t](), this.callbacks[t] = null;
        } catch (e) {
          console.error("cleanup error:", e);
        }
    this.callbacks = this.callbacks.filter((t) => t !== null);
  }
}
const Ai = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CleanUp: h,
  Events: A,
  createDraggable: $e,
  createRipple: Et,
  css: qe,
  defaultRippleOptions: xe,
  html: n,
  isAndroid: Se
}, Symbol.toStringTag, { value: "Module" })), Mt = "1", je = n`
<style></style>
<slot></slot>
`;
let ze = class {
  /**
   * @param {UIFlexGridItem} root
   */
  constructor(t) {
    this.root = t;
  }
  get flex() {
    return this.root.hasAttribute("flex") ? this.root.getAttribute("flex") : Mt;
  }
  set flex(t) {
    t === null ? this.root.removeAttribute("flex") : this.root.setAttribute("flex", t);
  }
};
const z = class z extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = je, this.cleanup = new h(), this.ui = new ze(this), this.updateStyle();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, s) {
    switch (t) {
      case "flex":
        this.updateStyle({ flex: s || Mt });
        break;
    }
  }
  /**
   * @private
   * @param {Object} attributes
   * @param {string} [attributes.flex]
   */
  updateStyle({ flex: t = Mt } = {}) {
    this.shadowRoot.querySelector("style").textContent = `
            :host {
                flex: ${t};
            }
        `;
  }
};
r(z, "register", () => {
  customElements.get("ui-flex-grid-item") || customElements.define("ui-flex-grid-item", z);
}), r(z, "observedAttributes", ["flex"]);
let Pt = z;
const Tt = "0", Ne = n`
<style></style>
<slot></slot>
`;
let Ze = class {
  /**
   * @param {UIFlexGridRow} root
   */
  constructor(t) {
    this.root = t;
  }
  get gap() {
    return this.root.getAttribute("gap") || Tt;
  }
  set gap(t) {
    t === null ? this.root.removeAttribute("gap") : this.root.setAttribute("gap", t);
  }
};
const N = class N extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Ne, this.cleanup = new h(), this.ui = new Ze(this), this.updateStyle();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, s) {
    switch (t) {
      case "gap":
        this.updateStyle({ gap: s || Tt });
        break;
    }
  }
  /**
   * @private
   * @param {Object} attributes
   * @param {string} [attributes.gap]
   */
  updateStyle({ gap: t = Tt } = {}) {
    this.shadowRoot.querySelector("style").textContent = `
            :host {
                display: flex !important;
                flex-flow: row nowrap;
                position: relative !important;
                width: 100%;
            }

            :host > ::slotted(*) {
                margin: 0 ${t} !important;
            }

            :host > ::slotted(*:first-child) {
                margin-left: 0 !important;
            }

            :host > ::slotted(*:last-child) {
                margin-right: 0 !important;
            }
        `;
  }
};
r(N, "register", () => {
  customElements.get("ui-flex-grid-row") || customElements.define("ui-flex-grid-row", N);
}), r(N, "observedAttributes", ["gap"]);
let I = N;
const Ht = "0", Pe = n`
<style></style>
<slot></slot>
`;
let Oe = class {
  /**
   * @param {UIFlexGrid} root
   */
  constructor(t) {
    this.root = t;
  }
  get gap() {
    return this.root.getAttribute("gap") || Ht;
  }
  set gap(t) {
    t === null ? this.root.removeAttribute("gap") : this.root.setAttribute("gap", t);
  }
};
const Z = class Z extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Pe, this.cleanup = new h(), this.ui = new Oe(this), this.updateStyle();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, s) {
    switch (t) {
      case "gap":
        this.updateStyle({ gap: s || Ht });
        break;
    }
  }
  /**
   * @private
   * @param {Object} attributes
   * @param {string} [attributes.gap]
   */
  updateStyle({ gap: t = Ht } = {}) {
    this.shadowRoot.querySelector("style").textContent = `
            :host {
                display: flex !important;
                flex-flow: column nowrap;
                position: relative !important;
                width: 100%;
                height: fit-content;
            }

            :host > ::slotted(*) {
                margin: ${t} 0 !important;
            }

            :host > ::slotted(*:first-child) {
                margin-top: 0 !important;
            }

            :host > ::slotted(*:last-child) {
                margin-bottom: 0 !important;
            }
        `;
  }
};
r(Z, "register", () => {
  customElements.get("ui-flex-grid") || customElements.define("ui-flex-grid", Z);
}), r(Z, "observedAttributes", ["gap"]);
let Ot = Z;
const Ve = n`
<style>
    :host {
        display: flex !important;
        position: absolute !important;
        z-index: 100;
        background-color: var(--ui-backdrop-bgColor);
        backdrop-filter: var(--ui-backdropFilter);
        overflow: hidden;
        user-select: none;
    }

    :host([position="top"]) {
        top: 0;
        left: 0;
        width: 100%;
        height: var(--ui-app-bar-height);
        border-bottom: 1px solid var(--ui-borderColor);
    }

    :host > ui-flex-grid-row {
        width: 100%;
        height: 100%;
        align-items: center;
        justify-content: space-between;
    }

    :host > ui-flex-grid-row > * {
        height: 100%;
    }

    :host > ui-flex-grid-row > *:nth-child(1),
    :host > ui-flex-grid-row > *:nth-child(3) {
        width: fit-content;
    }

    :host > ui-flex-grid-row > [slot="left"] {
        margin-left: 0 !important;
    }

    :host > ui-flex-grid-row > [slot="center"] {
        width: 100%;
    }

    :host > ui-flex-grid-row > [slot="right"] {
        margin-right: 0 !important;
        justify-content: flex-end;
    }
</style>

<ui-flex-grid-row gap="0.25rem">
    <ui-flex-grid-row gap="0.25rem">
        <slot name="left"></slot>
    </ui-flex-grid-row>

    <ui-flex-grid-row gap="0.25rem" style="overflow: hidden;">
        <slot name="center"></slot>
    </ui-flex-grid-row>

    <ui-flex-grid-row gap="0.25rem">
        <slot name="right"></slot>
    </ui-flex-grid-row>
</ui-flex-grid-row>
`;
var M, de;
let De = (de = class {
  /** @param {UIAppBar} root */
  constructor(t) {
    /** @type {UIAppBar} */
    l(this, M, void 0);
    c(this, M, t);
  }
  getLeftSlot() {
    return [...i(this, M).querySelectorAll('[slot="left"]')];
  }
  getCenterSlot() {
    return [...i(this, M).querySelectorAll('[slot="center"]')];
  }
  getRightSlot() {
    return [...i(this, M).querySelectorAll('[slot="right"]')];
  }
}, M = new WeakMap(), de);
const tt = class tt extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Ve, this.cleanup = new h(), this.ui = new De(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
r(tt, "register", () => {
  I.register(), customElements.get("ui-app-bar") || customElements.define("ui-app-bar", tt);
});
let Vt = tt;
const Be = n`
<style>
    :host {
        display: flex !important;
        align-items: center;
        justify-content: center;
        position: relative !important;
        padding: var(--ui-spacing) calc(var(--ui-spacing) * 2.5);
        border: 1px solid currentColor;
        border-radius: var(--ui-radius);
        overflow: hidden;
        text-transform: capitalize;
        cursor: pointer;
        outline: none;
        user-select: none;
        font-size: 1.1rem;
        font-weight: 450;
        font-family: var(--ui-fontFamily);
        font-variation-settings: var(--ui-button-fontVariation);
    }

    :host([variant="full"]) {
        border: none;
    }

    :host([variant="full"][color="primary"]) {
        background-color: var(--ui-primary-bgColor);
        color: var(--ui-primary-color);
    }

    :host([variant="full"][color="secondary"]) {
        background-color: var(--ui-secondary-bgColor);
        color: var(--ui-secondary-color);
    }

    :host([variant="full"][color="destructive"]) {
        background-color: var(--ui-destructive-bgColor);
        color: var(--ui-destructive-color);
    }

    :host([variant="outline"]) {
        border-color: currentColor;
        background-color: transparent;
    }

    :host([variant="outline"][color="primary"]) {
        color: var(--ui-primary-bgColor);
    }

    :host([variant="outline"][color="secondary"]) {
        color: var(--ui-secondary-bgColor);
    }

    :host([variant="outline"][color="destructive"]) {
        color: var(--ui-destructive-bgColor);
    }

    :host([variant="ghost"]) {
        border-color: transparent;
        background-color: transparent;
    }

    :host([variant="ghost"][color="primary"]) {
        color: var(--ui-primary-bgColor);
    }

    :host([variant="ghost"][color="secondary"]) {
        color: var(--ui-secondary-bgColor);
    }

    :host([variant="ghost"][color="destructive"]) {
        color: var(--ui-destructive-bgColor);
    }

    :host([disabled]),
    :host([disabled]:hover),
    :host([disabled]:active) {
        background-color: transparent;
        opacity: 0.25;
        cursor: default;
        pointer-events: none;
    }
</style>

<slot></slot>
`;
var p, pe;
let Fe = (pe = class {
  /** @param {UIButton} root */
  constructor(t) {
    /** @type {UIButton} */
    l(this, p, void 0);
    c(this, p, t), this.removeRipple = null;
  }
  get color() {
    return i(this, p).getAttribute("color");
  }
  /**
   * @param {UIButtonColor} v
   */
  set color(t) {
    i(this, p).setAttribute("color", t);
  }
  get variant() {
    return i(this, p).getAttribute("variant");
  }
  /**
   * @param {UIButtonVariant} v
   */
  set variant(t) {
    i(this, p).setAttribute("variant", t);
  }
  disable() {
    i(this, p).setAttribute("disabled", "");
  }
  enable() {
    i(this, p).removeAttribute("disabled");
  }
  enableRipple() {
    this.removeRipple || (this.removeRipple = Et(i(this, p), { centered: !0 }), i(this, p).removeAttribute("no-ripple"));
  }
  disableRipple() {
    this.removeRipple && (this.removeRipple(), this.removeRipple = null, i(this, p).setAttribute("no-ripple", ""));
  }
}, p = new WeakMap(), pe);
const P = class P extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Be, this.setAttribute("role", "button"), this.cleanup = new h(), this.ui = new Fe(this);
  }
  connectedCallback() {
    !this.hasAttribute("no-ripple") && !this.ui.removeRipple && this.ui.enableRipple();
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, s) {
    switch (t) {
      case "no-ripple":
        s !== null ? this.ui.disableRipple() : this.ui.enableRipple();
        break;
    }
  }
};
r(P, "register", () => {
  customElements.get("ui-button") || customElements.define("ui-button", P);
}), r(P, "observedAttributes", ["no-ripple"]);
let Dt = P;
const Je = n`
<style>
    :host {
        display: flex !important;
        align-items: center;
        justify-content: center;
        position: relative !important;
        width: 2rem;
        height: 2rem;
        padding: calc(var(--ui-spacing) / 2);
        border: 1px solid currentColor;
        border-radius: var(--ui-radius);
        outline: none;
        overflow: hidden;
        cursor: pointer;
        user-select: none;
        font-size: 1.1rem;
        font-weight: 450;
        font-family: var(--ui-fontFamily);
        font-variation-settings: var(--ui-button-fontVariation);
    }

    :host([ghost]) {
        border-color: transparent !important;
        box-shadow: none;
    }

    :host([color="primary"]) {
        color: var(--ui-primary-bgColor);
        border-color: var(--ui-primary-bgColor);
    }

    :host([color="secondary"]) {
        color: var(--ui-secondary-bgColor);
        border-color: var(--ui-secondary-bgColor);
    }

    :host([color="destructive"]) {
        color: var(--ui-destructive-bgColor);
        border-color: var(--ui-destructive-bgColor);
    }

    /* :disabled */

    :host([disabled]),
    :host([disabled]:hover),
    :host([disabled]:active) {
        opacity: 0.25;
        cursor: default;
        pointer-events: none;
    }
</style>

<slot></slot>
`;
var d, ge;
let Ye = (ge = class {
  /** @param {UIIconButton} root */
  constructor(t) {
    /** @type {UIIconButton} */
    l(this, d, void 0);
    c(this, d, t), this.removeRipple = null;
  }
  get color() {
    return i(this, d).getAttribute("color");
  }
  /**
   * @param {UIIconButtonColor} v
   */
  set color(t) {
    i(this, d).setAttribute("color", t);
  }
  get ghost() {
    return i(this, d).hasAttribute("ghost");
  }
  set ghost(t) {
    t ? i(this, d).setAttribute("ghost", "") : i(this, d).removeAttribute("ghost");
  }
  disable() {
    i(this, d).setAttribute("disabled", "");
  }
  enable() {
    i(this, d).removeAttribute("disabled");
  }
  enableRipple() {
    this.removeRipple || (this.removeRipple = Et(i(this, d), { centered: !0 }), i(this, d).removeAttribute("no-ripple"));
  }
  disableRipple() {
    this.removeRipple && (this.removeRipple(), this.removeRipple = null, i(this, d).setAttribute("no-ripple", ""));
  }
}, d = new WeakMap(), ge);
const O = class O extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Je, this.setAttribute("role", "button"), this.cleanup = new h(), this.ui = new Ye(this);
  }
  connectedCallback() {
    !this.hasAttribute("no-ripple") && !this.ui.removeRipple && this.ui.enableRipple();
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, s) {
    switch (t) {
      case "no-ripple":
        s !== null ? this.ui.disableRipple() : this.ui.enableRipple();
        break;
    }
  }
};
r(O, "register", () => {
  customElements.get("ui-icon-button") || customElements.define("ui-icon-button", O);
}), r(O, "observedAttributes", ["no-ripple"]);
let At = O;
const Xe = n`
<style>
    :host {
        display: block;
        width: 100%;
        max-width: 65rem;
        margin: 0 auto !important;
        padding: var(--ui-spacing);
    }
</style>

<slot></slot>
`, et = class et extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Xe, this.cleanup = new h();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
r(et, "register", () => {
  customElements.get("ui-container") || customElements.define("ui-container", et);
});
let Bt = et;
const Ke = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 24 24"
    xmlns="http://www.w3.org/2000/svg"
>

    <g id="Complete">
        <g data-name="add" id="add">
            <g>
                <line
                    fill="none"
                    stroke="currentColor"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2" x1="12" x2="12" y1="19" y2="5"
                />

                <line
                    fill="none"
                    stroke="currentColor"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2" x1="5" x2="19" y1="12" y2="12"
                />
            </g>
        </g>
    </g>
</svg>
`, it = class it extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Ke;
  }
};
r(it, "register", () => {
  customElements.get("svg-add") || customElements.define("svg-add", it);
});
let Ft = it;
const Qe = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 52 52"
    fill="currentColor"
    xmlns="http://www.w3.org/2000/svg"
>
    <path
        d="M50,24H6.83L27.41,3.41a2,2,0,0,0,0-2.82,2,2,0,0,0-2.82,0l-24,24a1.79,1.79,0,0,0-.25.31A1.19,1.19,0,0,0,.25,25c0,.07-.07.13-.1.2l-.06.2a.84.84,0,0,0,0,.17,2,2,0,0,0,0,.78.84.84,0,0,0,0,.17l.06.2c0,.07.07.13.1.2a1.19,1.19,0,0,0,.09.15,1.79,1.79,0,0,0,.25.31l24,24a2,2,0,1,0,2.82-2.82L6.83,28H50a2,2,0,0,0,0-4Z"
    />
</svg>
`, st = class st extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Qe;
  }
};
r(st, "register", () => {
  customElements.get("svg-back-arrow") || customElements.define("svg-back-arrow", st);
});
let Jt = st;
const We = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
>
    <rect width="24" height="24" fill="none" />
    <path
        d="M17 9.5L12 14.5L7 9.5"
        stroke="currentColor"
        stroke-linecap="round"
        stroke-linejoin="round"
    />
</svg>
`, ot = class ot extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = We;
  }
};
r(ot, "register", () => {
  customElements.get("svg-chevron-down") || customElements.define("svg-chevron-down", ot);
});
let Rt = ot;
const Ge = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
>
    <g clip-path="url(#clip0_429_11083)">
        <path
            d="M7 7.00006L17 17.0001M7 17.0001L17 7.00006"
            stroke="currentColor"
            stroke-width="2.5"
            stroke-linecap="round"
            stroke-linejoin="round"
        />
    </g>
    <defs>
        <clipPath id="clip0_429_11083">
            <rect width="24" height="24" fill="none" />
        </clipPath>
    </defs>
</svg>
`, rt = class rt extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Ge;
  }
};
r(rt, "register", () => {
  customElements.get("svg-close") || customElements.define("svg-close", rt);
});
let $t = rt;
const Ie = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
>
    <path
        d="M12 3V16M12 16L16 11.625M12 16L8 11.625"
        stroke="currentColor"
        stroke-width="1.5"
        stroke-linecap="round"
        stroke-linejoin="round"
    />

    <path
        d="M15 21H9C6.17157 21 4.75736 21 3.87868 20.1213C3 19.2426 3 17.8284 3 15M21 15C21 17.8284 21 19.2426 20.1213 20.1213C19.8215 20.4211 19.4594 20.6186 19 20.7487"
        stroke="currentColor"
        stroke-width="1.5"
        stroke-linecap="round"
        stroke-linejoin="round"
    />
</svg>
`, nt = class nt extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Ie;
  }
};
r(nt, "register", () => {
  customElements.get("svg-download") || customElements.define("svg-download", nt);
});
let Yt = nt;
const Ue = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
>
    <path
        d="M20.1497 7.93997L8.27971 19.81C7.21971 20.88 4.04971 21.3699 3.27971 20.6599C2.50971 19.9499 3.06969 16.78 4.12969 15.71L15.9997 3.84C16.5478 3.31801 17.2783 3.03097 18.0351 3.04019C18.7919 3.04942 19.5151 3.35418 20.0503 3.88938C20.5855 4.42457 20.8903 5.14781 20.8995 5.90463C20.9088 6.66146 20.6217 7.39189 20.0997 7.93997H20.1497Z"
        stroke="currentColor"
        stroke-width="1.5"
        stroke-linecap="round"
        stroke-linejoin="round"
    />
    <path
        d="M21 21H12"
        stroke="currentColor"
        stroke-width="1.5"
        stroke-linecap="round"
        stroke-linejoin="round"
    />
</svg>;
`, at = class at extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Ue;
  }
};
r(at, "register", () => {
  customElements.get("svg-edit") || customElements.define("svg-edit", at);
});
let Xt = at;
const _e = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 512 512"
    xmlns="http://www.w3.org/2000/svg"
    xmlns:xlink="http://www.w3.org/1999/xlink"
>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g fill="currentColor" transform="translate(85.333333, 42.666667)">
            <path
                d="M75.9466667,285.653333 C63.8764997,278.292415 49.6246897,275.351565 35.6266667,277.333333 L1.42108547e-14,277.333333 L1.42108547e-14,405.333333 L28.3733333,405.333333 L28.3733333,356.48 L40.5333333,356.48 C53.1304778,357.774244 65.7885986,354.68506 76.3733333,347.733333 C85.3576891,340.027178 90.3112817,328.626053 89.8133333,316.8 C90.4784904,304.790173 85.3164923,293.195531 75.9466667,285.653333 L75.9466667,285.653333 Z M53.12,332.373333 C47.7608867,334.732281 41.8687051,335.616108 36.0533333,334.933333 L27.7333333,334.933333 L27.7333333,298.666667 L36.0533333,298.666667 C42.094796,298.02451 48.1897668,299.213772 53.5466667,302.08 C58.5355805,305.554646 61.3626692,311.370371 61.0133333,317.44 C61.6596233,323.558965 58.5400493,329.460862 53.12,332.373333 L53.12,332.373333 Z M150.826667,277.333333 L115.413333,277.333333 L115.413333,405.333333 L149.333333,405.333333 C166.620091,407.02483 184.027709,403.691457 199.466667,395.733333 C216.454713,383.072462 225.530463,362.408923 223.36,341.333333 C224.631644,323.277677 218.198313,305.527884 205.653333,292.48 C190.157107,280.265923 170.395302,274.806436 150.826667,277.333333 L150.826667,277.333333 Z M178.986667,376.32 C170.098963,381.315719 159.922142,383.54422 149.76,382.72 L144.213333,382.72 L144.213333,299.946667 L149.333333,299.946667 C167.253333,299.946667 174.293333,301.653333 181.333333,308.053333 C189.877212,316.948755 194.28973,329.025119 193.493333,341.333333 C194.590843,354.653818 189.18793,367.684372 178.986667,376.32 L178.986667,376.32 Z M254.506667,405.333333 L283.306667,405.333333 L283.306667,351.786667 L341.333333,351.786667 L341.333333,329.173333 L283.306667,329.173333 L283.306667,299.946667 L341.333333,299.946667 L341.333333,277.333333 L254.506667,277.333333 L254.506667,405.333333 L254.506667,405.333333 Z M234.666667,7.10542736e-15 L9.52127266e-13,7.10542736e-15 L9.52127266e-13,234.666667 L42.6666667,234.666667 L42.6666667,192 L42.6666667,169.6 L42.6666667,42.6666667 L216.96,42.6666667 L298.666667,124.373333 L298.666667,169.6 L298.666667,192 L298.666667,234.666667 L341.333333,234.666667 L341.333333,106.666667 L234.666667,7.10542736e-15 L234.666667,7.10542736e-15 Z"
            ></path>
        </g>
    </g></svg
>
`, lt = class lt extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = _e;
  }
};
r(lt, "register", () => {
  customElements.get("svg-pdf") || customElements.define("svg-pdf", lt);
});
let Kt = lt;
const ti = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 1024 1024"
    xmlns="http://www.w3.org/2000/svg"
>
    <path
        d="M960 160h-291.2a160 160 0 0 0-313.6 0H64a32 32 0 0 0 0 64h896a32 32 0 0 0 0-64zM512 96a96 96 0 0 1 90.24 64h-180.48A96 96 0 0 1 512 96zM844.16 290.56a32 32 0 0 0-34.88 6.72A32 32 0 0 0 800 320a32 32 0 1 0 64 0 33.6 33.6 0 0 0-9.28-22.72 32 32 0 0 0-10.56-6.72zM832 416a32 32 0 0 0-32 32v96a32 32 0 0 0 64 0v-96a32 32 0 0 0-32-32zM832 640a32 32 0 0 0-32 32v224a32 32 0 0 1-32 32H256a32 32 0 0 1-32-32V320a32 32 0 0 0-64 0v576a96 96 0 0 0 96 96h512a96 96 0 0 0 96-96v-224a32 32 0 0 0-32-32z"
        fill="currentColor"
    />
    <path
        d="M384 768V352a32 32 0 0 0-64 0v416a32 32 0 0 0 64 0zM544 768V352a32 32 0 0 0-64 0v416a32 32 0 0 0 64 0zM704 768V352a32 32 0 0 0-64 0v416a32 32 0 0 0 64 0z"
        fill="currentColor"
    />
</svg>
`, ct = class ct extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ti;
  }
};
r(ct, "register", () => {
  customElements.get("svg-recycle") || customElements.define("svg-recycle", ct);
});
let Qt = ct;
const ei = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 -0.5 21 21"
    xmlns="http://www.w3.org/2000/svg"
    xmlns:xlink="http://www.w3.org/1999/xlink"
>
    <defs></defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-259.000000, -840.000000)" fill="currentColor">
            <g transform="translate(56.000000, 160.000000)">
                <path
                    d="M211.261065,690.694762 C209.623062,692.25443 206.966811,692.25443 205.328807,690.694762 L203.614251,689.062203 C202.79525,688.282368 202.79525,687.018258 203.614251,686.238424 C204.433253,685.45859 205.761903,685.45859 206.580905,686.238424 C207.721845,687.3248 208.972894,687.224949 209.777214,686.458096 C210.587827,685.686249 210.685352,684.498026 209.541266,683.409653 C208.722264,682.629819 208.722264,681.36471 209.541266,680.584876 C210.361317,679.805041 211.688918,679.805041 212.50792,680.584876 L214.22667,682.221429 C215.864674,683.781098 215.864674,686.310317 214.22667,687.869985 L223.356286,696.563988 C225.318325,698.431197 222.350623,701.253977 220.390682,699.387767 L211.261065,690.694762 Z"
                ></path>
            </g>
        </g>
    </g>
</svg>
`, ht = class ht extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ei;
  }
};
r(ht, "register", () => {
  customElements.get("svg-settings") || customElements.define("svg-settings", ht);
});
let Wt = ht;
const ii = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
>
    <path
        d="M4 6H20M4 12H20M4 18H20"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
    />
</svg>
`, ut = class ut extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ii;
  }
};
r(ut, "register", () => {
  customElements.get("svg-menu") || customElements.define("svg-menu", ut);
});
let Gt = ut;
const si = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 24 24"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
>
    <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M15 6.75C15 5.50736 16.0074 4.5 17.25 4.5C18.4926 4.5 19.5 5.50736 19.5 6.75C19.5 7.99264 18.4926 9 17.25 9C16.0074 9 15 7.99264 15 6.75ZM17.25 3C15.1789 3 13.5 4.67893 13.5 6.75C13.5 7.00234 13.5249 7.24885 13.5724 7.48722L9.77578 9.78436C9.09337 8.85401 7.99222 8.25 6.75 8.25C4.67893 8.25 3 9.92893 3 12C3 14.0711 4.67893 15.75 6.75 15.75C8.10023 15.75 9.28379 15.0364 9.9441 13.9657L13.5866 16.4451C13.5299 16.7044 13.5 16.9737 13.5 17.25C13.5 19.3211 15.1789 21 17.25 21C19.3211 21 21 19.3211 21 17.25C21 15.1789 19.3211 13.5 17.25 13.5C15.9988 13.5 14.8907 14.1128 14.2095 15.0546L10.4661 12.5065C10.4884 12.3409 10.5 12.1718 10.5 12C10.5 11.7101 10.4671 11.4279 10.4049 11.1569L14.1647 8.88209C14.8415 9.85967 15.971 10.5 17.25 10.5C19.3211 10.5 21 8.82107 21 6.75C21 4.67893 19.3211 3 17.25 3ZM15 17.25C15 16.0074 16.0074 15 17.25 15C18.4926 15 19.5 16.0074 19.5 17.25C19.5 18.4926 18.4926 19.5 17.25 19.5C16.0074 19.5 15 18.4926 15 17.25ZM4.5 12C4.5 10.7574 5.50736 9.75 6.75 9.75C7.99264 9.75 9 10.7574 9 12C9 13.2426 7.99264 14.25 6.75 14.25C5.50736 14.25 4.5 13.2426 4.5 12Z"
        fill="currentColor"
    />
</svg>
`, dt = class dt extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = si;
  }
};
r(dt, "register", () => {
  customElements.get("svg-share") || customElements.define("svg-share", dt);
});
let It = dt;
const oi = n`
<style>
    :host {
        width: 100%;
        height: 100%;
        color: inherit;
    }
</style>

<svg
    width="100%"
    height="100%"
    viewBox="0 0 512 512"
    xmlns="http://www.w3.org/2000/svg"
>
    <rect
        fill="none"
        stroke="currentColor"
        stroke-linejoin="round"
        stroke-width="32"
        x="48"
        y="80"
        width="416"
        height="384"
        rx="48"
    />
    <line
        fill="none"
        stroke="currentColor"
        stroke-linejoin="round"
        stroke-width="32"
        stroke-linecap="round"
        x1="128"
        y1="48"
        x2="128"
        y2="80"
    />
    <line
        fill="none"
        stroke="currentColor"
        stroke-linejoin="round"
        stroke-width="32"
        stroke-linecap="round"
        x1="384"
        y1="48"
        x2="384"
        y2="80"
    />
    <rect
        fill="none"
        stroke="currentColor"
        stroke-linejoin="round"
        stroke-width="32"
        stroke-linecap="round"
        x="112"
        y="224"
        width="96"
        height="96"
        rx="13"
    />
    <line
        fill="none"
        stroke="currentColor"
        stroke-linejoin="round"
        stroke-width="32"
        stroke-linecap="round"
        x1="464"
        y1="160"
        x2="48"
        y2="160"
    />
</svg>
`, pt = class pt extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = oi;
  }
};
r(pt, "register", () => {
  customElements.get("svg-today") || customElements.define("svg-today", pt);
});
let Ut = pt;
const ri = n`
<style>
    :host dialog * {
        box-sizing: border-box;
    }

    dialog {
        position: fixed !important;

        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);

        max-width: 100%;
        max-height: 100%;

        margin: 0;
        padding: 0;

        border: none;
        outline: none;

        background-color: transparent;

        -ms-overflow-style: none;
        scrollbar-width: none;

        z-index: 999;
    }

    dialog::-webkit-scrollbar {
        display: none;
    }

    dialog::backdrop {
        background-color: var(--ui-backdrop-bgColor);
        backdrop-filter: var(--ui-backdropFilter);
    }

    dialog > .container {
        background-color: var(--ui-bgColor);
        color: var(--ui-color);

        border: 1px solid var(--ui-borderColor);
        border-radius: var(--ui-radius);

        padding: var(--ui-spacing);

        display: flex;
        flex-direction: column;
        justify-content: space-between;

        position: relative;
    }

    :host([fullscreen]) dialog {
        width: 100%;
        height: 100%;
    }

    :host([fullscreen]) dialog > .container {
        width: calc(100% - var(--ui-spacing) * 2);
        height: calc(100% - (env(safe-area-inset-top, 0) + env(safe-area-inset-bottom, 0) + (var(--ui-spacing) * 2)));

        margin: var(--ui-spacing);
        margin-top: calc(env(safe-area-inset-top, 0) + var(--ui-spacing));
        margin-bottom: calc(env(safe-area-inset-bottom, 0) + var(--ui-spacing));
    }

    /*
     * Header Styles
     */
  
    .header {
        display: flex;
        align-items: center;
        justify-content: space-between;

        border-top-right-radius: var(--ui-radius);
        border-top-left-radius: var(--ui-radius);

        width: 100%;
        height: var(--ui-dialog-header-height);
    }

    .header h4 {
        margin: auto 0;
    }

    :host([fullscreen]) .header {
        z-index: 15;
        position: absolute;
        top: var(--ui-spacing);
        right: var(--ui-spacing);
        left: var(--ui-spacing);
        width: calc(100% - var(--ui-spacing) * 2);
    }

    /*
     * Content Styles
     */

    .content {
        padding: var(--ui-spacing);
        height: fit-content;
        min-width: fit-content;
        width: 100%;
    }

    :host([fullscreen]) .content {
        z-index: 10;
        position: absolute;
        top: calc(var(--ui-dialog-header-height) + var(--ui-spacing));
        bottom: calc(var(--ui-dialog-footer-height) + var(--ui-spacing));
        right: var(--ui-spacing);
        left: var(--ui-spacing);
        padding: unset;
        height: unset;
        width: unset;
        min-width: unset;
    }

    /*
     * Footer Styles
     */

    .footer {
        margin-top: var(--ui-spacing);
        border-bottom-right-radius: var(--ui-radius);
        border-bottom-left-radius: var(--ui-radius);

        width: 100%;
        height: var(--ui-dialog-footer-height);
    }

    :host([fullscreen]) .footer {
        z-index: 15;
        position: absolute;
        right: var(--ui-spacing);
        bottom: var(--ui-spacing);
        left: var(--ui-spacing);
        width: calc(100% - var(--ui-spacing) * 2);
    }

    .footer ui-flex-grid-row {
        height: 100%;
        flex-wrap: nowrap;
        justify-content: flex-end;
        align-items: center;
    }
</style>

<dialog>
	<div class="container">
        <div class="header">
            <span style="white-space: nowrap;"><slot name="title"></slot></span>

            <ui-icon-button style="width: var(--ui-dialog-header-height); height: 100%;" ghost>
                <svg-close></svg-close>
            </ui-icon-button>
        </div>

        <div class="content">
            <slot></slot>
        </div>

        <div class="footer">
            <ui-flex-grid-row gap="calc(var(--ui-spacing) / 2)">
                <slot name="actions"></slot>
            </ui-flex-grid-row>
        </div>
	</div>
</dialog>
`;
var x, b, L, me;
let ni = (me = class {
  /**
   * @param {UIDialog} root
   * @param {HTMLDialogElement} dialog
   */
  constructor(t, e) {
    /** @type {UIDialog} */
    l(this, x, void 0);
    /** @type {HTMLDialogElement} */
    l(this, b, void 0);
    /** @type {HTMLElement} */
    l(this, L, void 0);
    c(this, x, t), c(this, b, e), this.events = new A(), c(this, L, document.createElement("h4")), i(this, L).slot = "title", i(this, x).appendChild(i(this, L));
  }
  get fullscreen() {
    return i(this, x).hasAttribute("fullscreen");
  }
  set fullscreen(t) {
    t ? i(this, x).setAttribute("fullscreen", "") : i(this, x).removeAttribute("fullscreen");
  }
  get title() {
    return i(this, L).innerText;
  }
  set title(t) {
    i(this, L).innerText = t;
  }
  getDialogElement() {
    return i(this, b);
  }
  open(t = !1, e = !0) {
    const s = i(this, b).inert;
    i(this, b).inert = e, t ? i(this, b).showModal() : i(this, b).show(), this.events.dispatch("open", null), i(this, b).inert = s;
  }
  close() {
    i(this, b).close(), this.events.dispatch("close", null);
  }
}, x = new WeakMap(), b = new WeakMap(), L = new WeakMap(), me);
const gt = class gt extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ri, this.cleanup = new h(), this.ui = new ni(this, this.shadowRoot.querySelector("dialog"));
  }
  connectedCallback() {
    const t = this.shadowRoot.querySelector(".header ui-icon-button"), e = () => {
      this.ui.close();
    };
    t.addEventListener("click", e);
    const s = this.shadowRoot.querySelector("dialog"), a = (g) => {
      g.preventDefault();
    };
    s.addEventListener("cancel", a), this.cleanup.add(() => {
      t.removeEventListener("click", e), s.removeEventListener("cancel", a);
    });
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
r(gt, "register", () => {
  At.register(), $t.register(), I.register(), customElements.get("ui-dialog") || customElements.define("ui-dialog", gt);
});
let _t = gt;
const te = 150, Le = document.createElement("template");
Le.innerHTML = `
    <style>
        :host {
            display: block;

            position: absolute;
            z-index: ${te};
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;

            overflow: hidden;

            transition: left 0s ease .5s;
        }

        :host([open]) {
            background-color: var(--ui-backdrop-bgColor);
            backdrop-filter: var(--ui-backdropFilter);

            left: 0;

            transition: none;
        }

        aside {
            position: absolute;
            z-index: ${te};
            top: 0;
            left: -100%;
            width: 18em;
            max-width: 100%;
            height: 100%;

            overflow-x: hidden;
            overflow-y: auto;

            -ms-overflow-style: none;
            scrollbar-width: none;

            /* TODO: Maybe add card bgColor here? */
            color: var(--ui-color);
            background-color: var(--ui-backdrop-bgColor);
            backdrop-filter: var(--ui-backdropFilter);

            transition: left .5s ease;
        }

        :host([open]) aside {
            left: 0;
        }
    </style>

    <aside>
        <slot></slot>
    </aside>
`;
let ai = class {
  /**
   * @param {UIDrawer} root
   */
  constructor(t) {
    this.root = t, this.aside = this.root.shadowRoot.querySelector("aside");
  }
  get open() {
    return this.root.hasAttribute("open");
  }
  set open(t) {
    t ? this.root.setAttribute("open", "") : this.root.removeAttribute("open");
  }
};
const V = class V extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.appendChild(Le.content.cloneNode(!0)), this.cleanup = new h(), this.ui = new ai(this);
  }
  connectedCallback() {
    const t = (s) => {
      s.stopPropagation(), this.ui.open = !1;
    }, e = (s) => {
      s.stopPropagation();
    };
    this.addEventListener("click", t), this.ui.aside.addEventListener("click", e), this.cleanup.add(() => {
      this.ui.aside.removeEventListener("click", e), this.removeEventListener("click", t);
    });
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, s) {
    switch (t) {
      case "open":
        s !== null ? this.classList.add("open") : this.classList.remove("open");
        break;
    }
  }
};
r(V, "register", () => {
  customElements.get("ui-drawer") || customElements.define("ui-drawer", V);
}), r(V, "observedAttributes", ["open"]);
let ee = V;
const Ee = document.createElement("template");
Ee.innerHTML = `
    <style>
        li {
            padding: var(--ui-spacing) calc(var(--ui-spacing) * 1.5);
            display: flex;
            flex-direction: row;
            flex-wrap: nowrap;
        }

        ::slotted(*) {
            width: 100%;
        }
    </style>

    <li>
        <slot></slot>
    </li>
`;
let li = class {
  /**
   * @param {UIDrawerGroupItem} root
   */
  constructor(t) {
    this.root = t, this.outside = this.root.querySelector(".outside"), this.aside = this.root.shadowRoot.querySelector("aside");
  }
  get open() {
    return this.root.hasAttribute("open");
  }
  set open(t) {
    t ? this.root.setAttribute("open", "") : this.root.removeAttribute("open");
  }
};
const mt = class mt extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.appendChild(Ee.content.cloneNode(!0)), this.cleanup = new h(), this.ui = new li(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
r(mt, "register", () => {
  customElements.get("ui-drawer-group-item") || customElements.define("ui-drawer-group-item", mt);
});
let U = mt;
const Me = document.createElement("template");
Me.innerHTML = `
    <style>
        ul {
            list-style: none;
            padding: var(--ui-spacing);
            overflow: hidden;
        }

        ul:not([title]) ui-drawer-group-item.title {
            display: none;
        }
    </style>

    <ul>
        <slot name="title"></slot>

        <slot></slot>
    </ul>
`;
let ci = class {
  /**
   * @param {UIDrawerGroup} root
   */
  constructor(t) {
    this.root = t, this.outside = this.root.querySelector(".outside"), this.aside = this.root.shadowRoot.querySelector("aside");
  }
  get title() {
    return this.root.getAttribute("title") || null;
  }
  set title(t) {
    t ? this.root.setAttribute("title", t) : this.root.removeAttribute("title");
  }
};
const D = class D extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.appendChild(Me.content.cloneNode(!0)), this.cleanup = new h(), this.ui = new ci(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, s) {
    switch (t) {
      case "title":
        s === "" ? this.removeAttribute("title") : s !== null ? this.setTitle(s) : this.removeTitle();
        break;
    }
  }
  /**
   * @private
   * @param {string} value
   */
  setTitle(t) {
    let e = this.querySelector('ui-drawer-group-item[slot="title"]');
    e || (e = new U(), e.slot = "title"), e.innerHTML = `
            <h4>${t}</h4>
        `, this.appendChild(e);
  }
  /**
   * @private
   */
  removeTitle() {
    const t = this.querySelector('span[slot="title"]');
    t && this.removeChild(t);
  }
};
r(D, "register", () => {
  U.register(), customElements.get("ui-drawer-group") || customElements.define("ui-drawer-group", D);
}), r(D, "observedAttributes", ["title"]);
let ie = D;
const hi = n`
<style>
    :host {
        font-size: 1.1rem;
        font-family: var(--ui-fontFamily);
        font-variation-settings: var(--ui-text-primary-fontVariation);
    }
</style>

<slot></slot>
`, ft = class ft extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = hi, this.cleanup = new h();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
r(ft, "register", () => {
  customElements.get("ui-primary") || customElements.define("ui-primary", ft);
});
let St = ft;
const ui = n`
<style>
    :host {
        font-size: 0.9rem;
        font-family: var(--ui-fontFamily);
        font-variation-settings: var(--ui-text-secondary-fontVariation);
    }
</style>

<slot></slot>
`, bt = class bt extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ui, this.cleanup = new h();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
r(bt, "register", () => {
  customElements.get("ui-secondary") || customElements.define("ui-secondary", bt);
});
let X = bt;
const di = n`
<style>
    :host {
        position: relative !important;
        display: flex !important;
        flex-direction: row;
        width: 100%;
        padding: var(--ui-spacing);
        border-radius: var(--ui-radius);
    }

    :host > .text {
        display: flex;
        flex: 1;
        flex-direction: column;
        justify-content: center;
        margin-right: var(--ui-spacing);
    }

    :host > .input {
        display: flex;
        align-items: center;
        justify-content: flex-end;
    }
</style>

<span class="text">
    <ui-primary></ui-primary>
    <ui-secondary></ui-secondary>
</span>

<span class="input">
    <slot name="input"></slot>
    <slot></slot>
</span>
`;
var u, R, K, Q, $, fe;
let pi = (fe = class {
  /** @param {UILabel} root */
  constructor(t) {
    /** @type {UILabel} */
    l(this, u, void 0);
    l(this, R, !1);
    l(this, K, async () => {
      [...i(this, u).querySelectorAll('[slot="input"]')].forEach((t) => t.click());
    });
    l(this, Q, async (t) => {
      t.stopPropagation();
    });
    /** @type {() => void} */
    l(this, $, void 0);
    c(this, u, t);
  }
  get primary() {
    return i(this, u).getAttribute("primary");
  }
  set primary(t) {
    i(this, u).setAttribute("primary", t);
  }
  get secondary() {
    return i(this, u).getAttribute("secondary");
  }
  set secondary(t) {
    i(this, u).setAttribute("secondary", t);
  }
  getInputSlot() {
    return [...i(this, u).querySelectorAll('[slot="input"]')];
  }
  enableRipple() {
    i(this, $) || (this.removeRipple = Et(i(this, u)), i(this, u).style.cursor = "pointer", this.startInputHandling());
  }
  disableRipple() {
    i(this, $) && i(this, $).call(this), this.stopInputHandling();
  }
  /**
   * @private
   */
  startInputHandling() {
    i(this, R) || (i(this, u).addEventListener("click", i(this, K)), this.getInputSlot().forEach((t) => {
      t.addEventListener("click", i(this, Q));
    }), c(this, R, !0));
  }
  /**
   * @private
   */
  stopInputHandling() {
    i(this, u).removeEventListener("click", i(this, K)), [...i(this, u).querySelectorAll('[slot="input"]')].forEach((t) => {
      t.removeEventListener("click", i(this, Q));
    }), c(this, R, !1);
  }
}, u = new WeakMap(), R = new WeakMap(), K = new WeakMap(), Q = new WeakMap(), $ = new WeakMap(), fe);
const B = class B extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = di, this.cleanup = new h(), this.ui = new pi(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
  * @param {string} name
  * @param {string | null} _oldValue
  * @param {string | null} newValue
  */
  attributeChangedCallback(t, e, s) {
    switch (t) {
      case "ripple":
        s !== null ? this.ui.enableRipple() : this.ui.disableRipple();
        break;
      case "primary":
        this.shadowRoot.querySelector("ui-primary").innerHTML = s || "";
        break;
      case "secondary":
        this.shadowRoot.querySelector("ui-secondary").innerHTML = s || "";
        break;
    }
  }
};
r(B, "register", () => {
  St.register(), X.register(), customElements.get("ui-label") || customElements.define("ui-label", B);
}), r(B, "observedAttributes", ["ripple", "secondary", "primary"]);
let se = B;
const Te = document.createElement("template");
Te.innerHTML = `
    <style>
        :host {
            display: block;
            position: relative;
            width: 100%;
        }

        input {
            width: calc(100% - var(--ui-spacing) * 4);
            display: block;
            margin: 0;
            padding: var(--ui-spacing) calc(var(--ui-spacing) * 2);
            border: none !important;
            border-radius: inherit;
            outline: none !important;
            font-size: 0.9rem;
            font-family: var(--ui-fontFamily);
            font-variation-settings: var(--ui-input-fontVariation);
            accent-color: var(--ui-primary-bgColor);
            background-color: transparent !important;
        }

        .container {
            width: 100%;
            border: none;
            border-bottom: 1px solid var(--ui-borderColor);
            border-radius: 0;
            transition: border-color 0.25s linear;
        }

        .container:has(input:focus) {
            border-color: var(--ui-primary-bgColor);
        }

        .container:has(input[aria-invalid]) {
            border-color: hsl(var(--ui-destructive-bgColor));
        }

        ::slotted([slot="title"]) {
            display: block;
            padding: 0 var(--ui-spacing);
            user-select: none;
            transform: translateY(calc(var(--ui-spacing) / 2));
        }
    </style>

    <div class="container">
        <slot name="title"></slot>
        <input>
    </div>
`;
let gi = class {
  /**
   * @param {UIInput} root
   */
  constructor(t) {
    this.root = t, this.events = new A(), this.input = this.root.shadowRoot.querySelector("input"), this.input.type = this.root.getAttribute("type") || "text", this.input.oninput = () => this.events.dispatch("input", this.value), this.input.onchange = () => this.events.dispatch("change", this.value);
  }
  /**
   * @param {string | null} v
   */
  set title(t) {
    let e = this.root.querySelector('[slot="title"]');
    t === null && e && (this.root.removeChild(e), e = null), e || (e = new X(), e.slot = "title", this.root.appendChild(e)), e.innerHTML = t || "";
  }
  get title() {
    var t;
    return ((t = this.root.querySelector('[slot="title"]')) == null ? void 0 : t.innerHTML) || null;
  }
  /**
   * @param {UIInputTypes} value
   */
  set type(t) {
    this.input.type = t;
  }
  /**
   * @returns {UIInputTypes}
   */
  get type() {
    return this.input.type || "text";
  }
  /**
   * @param {UIInputTypeValues[T]} value
   */
  set value(t) {
    this.input.value = t;
  }
  /**
   * @returns {UIInputTypeValues[T]}
   */
  get value() {
    switch (this.input.type) {
      case "number":
        return this.input.value ? new Number(this.input.value) : NaN;
      default:
        return this.input.value;
    }
  }
  /**
   * @param {string} value
   */
  set placeholder(t) {
    this.input.placeholder = t;
  }
  /**
   * @returns {string}
   */
  get placeholder() {
    return this.input.placeholder;
  }
  /**
   * @param {boolean} state
   */
  set invalid(t) {
    this.input.ariaInvalid = t ? "" : null;
  }
  /**
   * @returns {boolean}
   */
  get invalid() {
    return this.input.ariaInvalid !== null;
  }
  /**
   * @param {UIInputTypeValues[T]} n
   */
  set min(t) {
    this.input.min = t;
  }
  /**
   * @returns {UIInputTypeValues[T]}
   */
  get min() {
    switch (this.input.type) {
      case "number":
        return this.input.min ? new Number(this.input.min) : NaN;
      default:
        return this.input.min;
    }
  }
  /**
   * @param {UIInputTypeValues[T]} n
   */
  set max(t) {
    this.input.max = t;
  }
  /**
   * @returns {UIInputTypeValues[T]}
   */
  get max() {
    switch (this.input.type) {
      case "number":
        return this.input.max ? new Number(this.input.max) : NaN;
      default:
        return this.input.max;
    }
  }
};
const F = class F extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.appendChild(Te.content.cloneNode(!0)), this.cleanup = new h(), this.ui = new gi(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, s) {
    switch (t) {
      case "title":
        this.ui.title = s;
        break;
      case "type":
        s === null ? this.ui.type = "text" : this.ui.type = s;
        break;
      case "value":
        this.ui.value = this.parseNewValue(s);
        break;
      case "placeholder":
        s === null ? this.ui.placeholder = "" : this.ui.placeholder = s;
        break;
      case "invalid":
        this.ui.invalid = s !== null;
        break;
      case "min":
        this.ui.min = this.parseNewValue(s);
        break;
      case "max":
        this.ui.max = this.parseNewValue(s);
        break;
    }
  }
  /**
   * @private
   * @param {string | null} value
   * @returns {UIInputTypeValues[T]}
   */
  parseNewValue(t) {
    switch (this.ui.type) {
      case "number":
        return t ? new Number(t) : NaN;
      default:
        return t || "";
    }
  }
};
r(F, "register", () => {
  X.register(), customElements.get("ui-input") || customElements.define("ui-input", F);
}), r(F, "observedAttributes", [
  "title",
  "type",
  "value",
  "placeholder",
  "invalid",
  "min",
  "max"
]);
let oe = F;
const mi = n`
<style>
    :host {
        display: none;
        align-items: center;

        padding: var(--ui-spacing);
        padding-right: 2rem;

        height: calc(1em * var(--ui-lineHeight) + var(--ui-spacing) * 2);

        white-space: nowrap;
        text-overflow: ellipsis;

        transition: background-color 0.25s linear, color 0.25s linear;

        overflow: hidden;
    }
</style>

<slot></slot>
`;
var y, be;
let fi = (be = class {
  /** @param {UISelectOption} root */
  constructor(t) {
    /** @type {UISelectOption} */
    l(this, y, void 0);
    c(this, y, t);
  }
  get value() {
    return i(this, y).getAttribute("value");
  }
  set value(t) {
    i(this, y).setAttribute("value", t);
  }
  get selected() {
    return i(this, y).hasAttribute("selected");
  }
  set selected(t) {
    t ? i(this, y).setAttribute("selected", "") : i(this, y).removeAttribute("selected");
  }
}, y = new WeakMap(), be);
const vt = class vt extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = mi, this.setAttribute("role", "button"), this.ui = new fi(this);
  }
};
r(vt, "register", () => {
  customElements.get("ui-select-option") || customElements.define("ui-select-option", vt);
});
let _ = vt;
const bi = n`
<style>
    * {
        box-sizing: border-box;
    }

    :host {
        --ui-bgColor: "transparent";
        --items-length: 0;

        position: relative !important; 
        display: block !important;

        width: 100%;
        height: calc(1em * var(--ui-lineHeight) + var(--ui-spacing) * 2);
        transition: height 0.25s ease;

        background-color: var(--ui-bgColor);
        color: var(--ui-color);

        border: 1px solid var(--ui-borderColor);
        border-radius: var(--ui-radius);

        line-height: 1.15;

        overflow: hidden;

        font-size: 0.9rem;
        font-family: var(--ui-fontFamily);
        font-variation-settings: var(--ui-select-fontVariation);
    }

    .options {
        cursor: pointer;
        display: none;
        display: flex;
        flex-direction: column;
        min-height: 100%;
    }

    .icon {
        display: flex;
        justify-content: center;
        align-items: center;
        position: absolute;
        top: 0;
        right: 0;
        width: 2.5rem;
        height: 100%;
        color: var(--ui-primary-bgColor);
    }

    ::slotted(ui-select-option) {
        display: flex;
    }

    :host(.open) {
        height: calc((1em * var(--ui-lineHeight) + var(--ui-spacing) * 2) * var(--items-length));
    }

    :host(.open) .options {
        display: block;
    }

    :host(.open) .icon {
        display: none;
    }

    :host(.open) ::slotted(ui-select-option[selected]) {
        background-color: var(--ui-primary-bgColor);
        color: var(--ui-primary-color);
    }

    :host(.open) ::slotted(ui-select-option:not([selected]):hover) {
        background-color: hsla(var(--ui-color-hsl), 0.1);
    }

    :host(:not(.open)) .options:has(> ::slotted(ui-select-option[selected])) {
        display: block;
    }

    :host(:not(.open)) ::slotted(ui-select-option:not([selected])) {
        display: none;
    }
</style>

<div class="options">
    <div class="icon"><svg-chevron-down></svg-chevron-down></div>

    <slot></slot>
</div>
`;
let vi = class {
  constructor() {
    this.events = new A();
  }
};
var W;
const wt = class wt extends HTMLElement {
  constructor() {
    super();
    /** @param {MouseEvent | PointerEvent} ev */
    l(this, W, async (e) => {
      (e.composedPath() || []).forEach((s) => {
        s instanceof _ && ([...this.querySelectorAll("ui-select-option")].forEach(
          (a) => a.removeAttribute("selected")
        ), s.setAttribute("selected", ""), this.ui.events.dispatch("change", s));
      });
    });
    this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = bi, this.cleanup = new h(), this.ui = new vi();
  }
  // }}}
  connectedCallback() {
    const e = this.shadowRoot.querySelector(".options"), s = this.onClickOptions.bind(this);
    e.addEventListener("click", s), this.cleanup.add(() => {
      this.removeEventListener("click", s), e.removeEventListener("click", this.onClickOptions);
    }), this.style.setProperty(
      "--items-length",
      this.querySelectorAll("ui-select-option").length.toString()
    );
  }
  // }}}
  disconnectedCallback() {
    this.cleanup.run();
  }
  // }}}
  /**
   * @private
   * @param {Event} ev
   */
  async onClickOptions(e) {
    this.classList.toggle("open") ? (e.stopPropagation(), this.addEventListener("click", i(this, W))) : setTimeout(
      () => this.removeEventListener("click", i(this, W))
    );
  }
  // }}}
};
W = new WeakMap(), // }}}
r(wt, "register", () => {
  Rt.register(), _.register(), customElements.get("ui-select") || customElements.define("ui-select", wt);
});
let re = wt;
var E, S, G, ve;
let wi = (ve = class {
  /** @param {UILang} root */
  constructor(t) {
    /** @type {UILang} */
    l(this, E, void 0);
    /**
     * @type {Events<{ "change": UILangType}>}
     */
    l(this, S, void 0);
    /**
     * @type {{
     *  [key: string]: {
     *      [key: string]: string;
     *  };
     * }}
     */
    l(this, G, void 0);
    c(this, E, t), c(this, S, new A()), this.langType = null;
  }
  get current() {
    return i(this, E).getAttribute("current");
  }
  set current(t) {
    t === null ? i(this, E).removeAttribute("current") : i(this, E).setAttribute("current", t);
  }
  /** @returns {UILangType} */
  getFallbackElement() {
    return i(this, E).querySelector("ui-lang-type[fallback]");
  }
  /**
   * @param {UILangType} langType
   * @param {{
   *  [key: string]: {
   *      [key: string]: string;
   *  };
   * }} data
   */
  new(t, e) {
    this.langType = t, c(this, G, e), i(this, S).dispatch("change", this.langType);
  }
  /**
   * @param {string} group
   * @param {string} key
   */
  get(t, e) {
    var s, a;
    return ((a = (s = i(this, G)) == null ? void 0 : s[t]) == null ? void 0 : a[e]) || null;
  }
  /**
   * @param {"change"} key
   * @param {(langType: UILangType | null) => void|Promise<void>} callback
   * @param {boolean} [trigger] - this will run the callback first
   * @returns {() => void} clean up function
   */
  on(t, e, s = !1) {
    if (typeof e != "function")
      throw "callback is not a function";
    return s && e(this.langType), i(this, S).on(t, e);
  }
}, E = new WeakMap(), S = new WeakMap(), G = new WeakMap(), ve);
const J = class J extends HTMLElement {
  constructor() {
    super(), this.ui = new wi(this);
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, s) {
    switch (t) {
      case "current":
        s !== null && this.loadLanguage(s);
        break;
    }
  }
  /**
   * @private
   * @param {string} name
   */
  async loadLanguage(t) {
    const e = this.querySelector(`ui-lang-type[name="${t}"]`) || this.ui.getFallbackElement();
    if (!e)
      return;
    if (!e.ui.href)
      throw "Missing href attribute!";
    const s = await fetch(e.ui.href);
    this.ui.new(e, await s.json());
  }
};
r(J, "register", () => {
  customElements.get("ui-lang") || customElements.define("ui-lang", J);
}), r(J, "observedAttributes", ["current"]);
let ne = J;
var v, we;
let yi = (we = class {
  /**
  * @param {UILangType} root
  */
  constructor(t) {
    /** @type {UILangType} */
    l(this, v, void 0);
    c(this, v, t);
  }
  get name() {
    return i(this, v).getAttribute("name");
  }
  set name(t) {
    i(this, v).setAttribute("name", t);
  }
  get href() {
    return i(this, v).getAttribute("href");
  }
  set href(t) {
    i(this, v).setAttribute("href", t);
  }
  get fallback() {
    return i(this, v).hasAttribute("fallback");
  }
  set fallback(t) {
    t ? i(this, v).setAttribute("fallback", "") : i(this, v).removeAttribute("fallback");
  }
}, v = new WeakMap(), we);
const yt = class yt extends HTMLElement {
  constructor() {
    super(), this.ui = new yi(this);
  }
};
r(yt, "register", () => {
  customElements.get("ui-lang-type") || customElements.define("ui-lang-type", yt);
});
let ae = yt;
const ki = n`
<style>
    .background {
        z-index: 999;
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        background-color: var(--ui-backdrop-bgColor);
        backdrop-filter: var(--ui-backdropFilter);
    }

    .spinner {
        z-index: 1000;
        content: '';
        box-sizing: border-box;
        position: absolute;
        top: 50%;
        left: 50%;
        width: 2.5rem;
        height: 2.5rem;
        margin-top: -1.25rem;
        margin-left: -1.25rem;
        border-radius: 50%;
        border: 2px solid var(--ui-borderColor);
        border-top-color: var(--ui-primary-bgColor);
        animation: spinner .6s linear infinite;
    }

    @keyframes spinner {
        to {transform: rotate(360deg);}
    }
</style>

<div class="background"></div>
<div class="spinner"></div>
`, kt = class kt extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ki, this.cleanup = new h();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
r(kt, "register", () => {
  customElements.get("ui-spinner") || customElements.define("ui-spinner", kt);
});
let le = kt;
const Ci = n`
    <style>
        :host {
            display: block !important;
            position: absolute !important;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            animation: fade-in 0.5s;
            transition: opacity 0.5s ease;
        }

        :host(:last-child) {
            opacity: 1;
        }

        @keyframes fade-in {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }
    </style>

    <slot></slot>
`;
var q, ye;
let xi = (ye = class {
  /**
  * @param {UIStackLayoutPage} root
  */
  constructor(t) {
    /** @type {UIStackLayoutPage} */
    l(this, q, void 0);
    c(this, q, t);
  }
  get name() {
    return i(this, q).getAttribute("name");
  }
  set name(t) {
    i(this, q).setAttribute("name", t);
  }
}, q = new WeakMap(), ye);
const Ct = class Ct extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Ci, this.cleanup = new h(), this.ui = new xi(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
r(Ct, "register", () => {
  customElements.get("ui-stack-layout-page") || customElements.define("ui-stack-layout-page", Ct);
});
let qt = Ct;
const Li = n`
    <style>
        :host {
            display: block !important;
            position: relative !important;
            width: 100%;
            height: 100%;
        }
    </style>

    <slot></slot>
`;
var T, H, j, ke;
let Ei = (ke = class {
  /** @param {UIStackLayout} root */
  constructor(t) {
    /** @type {UIStackLayout} */
    l(this, T, void 0);
    l(this, H, !1);
    /**
     * @type {UIPages}
     */
    l(this, j, {});
    c(this, T, t), this.events = new A(), this.stack = [];
  }
  /**
   * @param {string} name
   * @param {() => (UIStackLayoutPage | DocumentFragment | Node)} cb
   */
  registerPage(t, e) {
    i(this, j)[t] = e;
  }
  /**
   * @param {string} name
   */
  unregisterPage(t) {
    delete i(this, j)[t];
  }
  lock() {
    c(this, H, !0);
  }
  unlock() {
    c(this, H, !1);
  }
  goBack() {
    if (!this.stack.length || i(this, H))
      return;
    const t = this.stack.pop(), e = i(this, T).removeChild(t);
    this.stack.length && i(this, T).appendChild(this.stack[this.stack.length - 1]), this.dispatchChangeEvent(e);
  }
  /**
   * @param {string} name
   */
  setPage(t) {
    if (!i(this, H)) {
      if (this.stack.push(
        // @ts-expect-error
        i(this, T).appendChild(i(this, j)[t]().children[0])
      ), this.stack.length > 1) {
        const e = this.stack[this.stack.length - 2];
        e.parentElement.removeChild(e);
      }
      this.dispatchChangeEvent(null);
    }
  }
  /**
   * @param {UIStackLayoutPage} oldChild
   */
  async dispatchChangeEvent(t) {
    this.events.dispatch("change", {
      newPage: this.stack[this.stack.length - 1] || null,
      oldPage: t || this.stack[this.stack.length - 2] || null
    });
  }
}, T = new WeakMap(), H = new WeakMap(), j = new WeakMap(), ke);
const xt = class xt extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Li, this.cleanup = new h(), this.ui = new Ei(this);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
r(xt, "register", () => {
  qt.register(), customElements.get("ui-stack-layout") || customElements.define("ui-stack-layout", xt);
});
let ce = xt;
var k, C, Ce;
let Mi = (Ce = class {
  /**
   * @param {UIStore} root
   */
  constructor(t) {
    /** @type {UIStore} */
    l(this, k, void 0);
    /** @type {any} */
    l(this, C, {});
    c(this, k, t), this.events = new A();
  }
  get localStoragePrefix() {
    return i(this, k).getAttribute("local-storage-prefix");
  }
  set localStoragePrefix(t) {
    i(this, k).setAttribute("local-storage-prefix", t);
  }
  get enableLocalStorage() {
    return i(this, k).hasAttribute("enable-local-storage");
  }
  set enableLocalStorage(t) {
    t ? i(this, k).setAttribute("enable-local-storage", "") : i(this, k).removeAttribute("enable-local-storage");
  }
  /**
   * @template {keyof T} K
   * @param {K} key
   * @returns {T[K]}
   */
  get(t) {
    return i(this, C)[t];
  }
  /**
   * @template {keyof T} K
   * @param {K} key
   * @param {T[K]} data
   * @param {boolean} [useDataAsFallback] Use data as fallback, if nothing found in the browsers `localStorage`
   * `this.enableLocalStorage` flag needs to be set to `true` for this to work
   */
  set(t, e, s = !1) {
    if (s && this.enableLocalStorage) {
      const a = JSON.parse(localStorage.getItem(this.localStoragePrefix + t.toString()) || "null");
      i(this, C)[t] = a ?? e;
    } else
      i(this, C)[t] = e;
    this.enableLocalStorage && localStorage.setItem(this.localStoragePrefix + t.toString(), JSON.stringify(i(this, C)[t])), this.events.dispatch(t, i(this, C)[t]);
  }
  /**
   * @template {keyof T} K
   * @param {K} key
   * @param {(data: T[K]) => any} callback
   */
  update(t, e) {
    if (typeof e != "function")
      throw "callback is not a function";
    this.set(t, e(i(this, C)[t]));
  }
  /**
   * @template {keyof T} K
   * @param {K} key
   * @param {(data: T[K]) => void|Promise<void>} callback
   * @param {boolean} [trigger] - this will run the callback first
   * @returns {() => void} clean up function
   */
  on(t, e, s = !1) {
    if (typeof e != "function")
      throw "callback is not a function";
    return s && e(this.get(t)), this.events.on(t, e);
  }
}, k = new WeakMap(), C = new WeakMap(), Ce);
const Lt = class Lt extends HTMLElement {
  constructor() {
    super(), this.ui = new Mi(this);
  }
};
r(Lt, "register", () => {
  customElements.get("ui-store") || customElements.define("ui-store", Lt);
});
let he = Lt;
var w;
class Ti {
  constructor() {
    /** @type {MediaQueryList | null} */
    l(this, w, null);
    this.currentTheme = null, this.themes = {};
  }
  enableAutoMode() {
    if (this.removeMode(), i(this, w)) {
      this.mediaChangeHandler(i(this, w));
      return;
    }
    c(this, w, window.matchMedia("(prefers-color-scheme: dark)")), i(this, w).addEventListener("change", this.mediaChangeHandler), this.mediaChangeHandler(i(this, w));
  }
  disableAutoMode() {
    this.removeMedia();
  }
  /**
   * @param {string} name
   * @param {string} href
   */
  addTheme(t, e) {
    this.themes[t] = e;
  }
  /**
   * @param {string} name
   */
  loadTheme(t) {
    var s;
    if (!this.themes[t])
      throw `theme "${t}" is missing in this.themes`;
    if (((s = this.currentTheme) == null ? void 0 : s.name) == t)
      return;
    {
      const a = document.getElementById("theme");
      a && (document.head.removeChild(a), this.currentTheme = null);
    }
    const e = document.createElement("link");
    e.id = "theme", e.rel = "stylesheet", e.href = this.themes[t], document.head.appendChild(e), this.currentTheme = { name: t, href: this.themes[t] };
  }
  /**
   * @param {MediaQueryListEvent | MediaQueryList} ev
   */
  mediaChangeHandler(t) {
    t.matches ? document.body.setAttribute("data-theme", "dark") : document.body.setAttribute("data-theme", "light");
  }
  /**
   * @param {HTMLElement} element
   */
  removeMode(t = document.body) {
    t.removeAttribute("data-theme");
  }
  /**
   * @param {UIMode} mode
   * @param {HTMLElement} element
   */
  setMode(t, e = document.body) {
    switch (t) {
      case "dark":
        e.setAttribute("data-theme", t);
        break;
      case "light":
        e.setAttribute("data-theme", t);
        break;
    }
  }
  /**
   * @private
   */
  removeMedia() {
    i(this, w) && (i(this, w).removeEventListener("change", this.mediaChangeHandler), c(this, w, null));
  }
}
w = new WeakMap();
const Y = class Y extends HTMLElement {
  constructor() {
    super(), this.ui = new Ti();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue 
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, s) {
    switch (t) {
      case "auto":
        s !== null ? this.ui.enableAutoMode() : this.ui.disableAutoMode();
        break;
      case "mode":
        s !== null ? this.ui.setMode(s) : this.ui.removeMode();
        break;
    }
  }
};
r(Y, "register", () => {
  customElements.get("ui-theme-handler") || customElements.define("ui-theme-handler", Y);
}), r(Y, "observedAttributes", ["auto", "mode"]);
let ue = Y;
export {
  Ft as SvgAdd,
  Jt as SvgBackArrow,
  Rt as SvgChevronDown,
  $t as SvgClose,
  Yt as SvgDownload,
  Xt as SvgEdit,
  Gt as SvgMenu,
  Kt as SvgPDF,
  Qt as SvgRecycle,
  Wt as SvgSettings,
  It as SvgShare,
  Ut as SvgToday,
  Vt as UIAppBar,
  Dt as UIButton,
  Bt as UIContainer,
  _t as UIDialog,
  ee as UIDrawer,
  ie as UIDrawerGroup,
  U as UIDrawerGroupItem,
  Ot as UIFlexGrid,
  Pt as UIFlexGridItem,
  I as UIFlexGridRow,
  At as UIIconButton,
  oe as UIInput,
  se as UILabel,
  ne as UILang,
  ae as UILangType,
  St as UIPrimary,
  X as UISecondary,
  re as UISelect,
  _ as UISelectOption,
  le as UISpinner,
  ce as UIStackLayout,
  qt as UIStackLayoutPage,
  he as UIStore,
  ue as UIThemeHandler,
  Ai as js
};
