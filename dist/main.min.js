var Jt = Object.defineProperty;
var Xt = (r, t, e) => t in r ? Jt(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;
var o = (r, t, e) => (Xt(r, typeof t != "symbol" ? t + "" : t, e), e), Qt = (r, t, e) => {
  if (!t.has(r))
    throw TypeError("Cannot " + e);
};
var d = (r, t, e) => (Qt(r, t, "read from private field"), e ? e.call(r) : t.get(r)), pt = (r, t, e) => {
  if (t.has(r))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(r) : t.set(r, e);
};
const gt = {
  onDragStart: null,
  onDragging: null,
  onDragEnd: null
};
function Wt(r, t = {}) {
  t = {
    ...gt,
    ...t
  };
  const e = () => {
    const l = [...r.parentNode.children].indexOf(r);
    r.draggable = !0, r.ondragstart = (c) => {
      c.dataTransfer.effectAllowed = "move", c.dataTransfer.dropEffect = "move", c.dataTransfer.setData(
        "text/plain",
        l.toString()
      ), t.onDragStart && t.onDragStart(l);
    }, r.ondragover = (c) => (c.preventDefault(), !1), r.ondragenter = (c) => {
      c.preventDefault(), t.onDragging && t.onDragging(l);
    }, r.ondrop = (c) => {
      c.preventDefault(), c.dataTransfer.dropEffect = "move";
      const Yt = parseInt(
        c.dataTransfer.getData("text/plain"),
        10
      );
      t.onDragEnd && t.onDragEnd(Yt, l);
    };
  }, i = () => {
    r.draggable = !1, r.ondragstart = null, r.ondragover = null, r.ondragenter = null, r.ondrop = null;
  };
  return e(), {
    /**
     * @param {DraggableOptions} _options
     */
    update(s) {
      t = {
        ...gt,
        ...s
      }, i(), e();
    },
    destroy: i
  };
}
var u;
class h {
  constructor() {
    /**
     * @type {any}
     */
    pt(this, u, {});
  }
  /**
   * @template {keyof T} K
   * @param {K} key
   * @param {((data: T[K]) => void|Promise<void>) | null} listener
   * @returns {() => void} clean up function
   */
  on(t, e) {
    if (typeof e != "function")
      throw `invalid event listener passed for "${t.toString()}" event!`;
    return d(this, u)[t] || (d(this, u)[t] = []), d(this, u)[t].push(e), () => {
      this.off(t, e);
    };
  }
  // }}}
  /**
   * @template {keyof T} K
   * @param {K} key
   * @param {((data: T[K]) => void|Promise<void>)} listener
   */
  off(t, e) {
    if (!d(this, u)[t])
      throw `no listeners found for ${t.toString()}, there is nothing to delete`;
    let i = !1, s = 0;
    for (const l of d(this, u)[t])
      l === e && (d(this, u)[t].splice(s, 1), i = !0), s++;
    if (!i)
      throw `listener not found for ${t.toString()}, there is nothing to delete`;
    return this;
  }
  // }}}
  /**
   * @template {keyof T} K
   * @param {K} key
   * @param {T[K]} data
   */
  dispatch(t, e) {
    if (e === void 0)
      throw "data is undefined!";
    if (d(this, u)[t])
      for (const i of d(this, u)[t])
        i(e);
    return this;
  }
  // }}}
}
u = new WeakMap();
function ft(r, t) {
  const e = document.createElement("div");
  e.classList.add("ripple"), e.style.position = "absolute", e.style.color = "inherit", e.style.borderRadius = "50%", e.style.pointerEvents = "none", e.style.width = "100px", e.style.height = "100px", e.style.marginTop = "-50px", e.style.marginLeft = "-50px", e.style.opacity = `${t.opacity}`, e.style.backgroundColor = t.color, e.style.transform = "scale(0) translate(0, 0)", e.style.transition = `transform ${t.spreadDuration} ${t.spreadTiming} 0s,opacity ${t.clearDuration} ${t.clearTiming} 0s`, r.currentTarget.appendChild(e);
  const i = r.currentTarget.getBoundingClientRect();
  t.centered ? (e.style.top = `${i.height / 2}px`, e.style.left = `${i.width / 2}px`) : (e.style.top = `${r.clientY - i.top}px`, e.style.left = `${r.clientX - i.left}px`);
  const s = Math.max(i.width, i.height) * 0.02;
  return e.style.transform = `scale(${s}) translate(0, 0)`, e;
}
function mt(r) {
  r && (r.addEventListener("transitionend", (t) => {
    t.propertyName === "opacity" && r.remove();
  }), r.style.opacity = "0");
}
const Kt = {
  color: "var(--ui-ripple-color, currentColor)",
  opacity: "var(--ui-ripple-opacity, 0.2)",
  centered: !1,
  spreadDuration: ".4s",
  spreadTiming: "linear",
  clearDuration: "1s",
  clearTiming: "ease-in-out",
  useClick: !1
};
function ot(r, t = {}) {
  t = { ...Kt, ...t };
  let e;
  const i = (l) => {
    e = ft(l, t);
  }, s = () => {
    mt(e);
  };
  return r.classList.add("ripple-container"), r.style.overflow = "hidden", t.useClick === !0 ? r.addEventListener("click", (l) => {
    e = ft(l, t), mt(e);
  }) : (r.addEventListener("pointerdown", i), r.addEventListener("pointerup", s), r.addEventListener("pointerleave", s)), () => {
    r.classList.remove("ripple-container"), r.removeEventListener("pointerdown", i), r.removeEventListener("pointerup", s), r.removeEventListener("pointerleave", s);
  };
}
function It() {
  return /(android)/i.test(navigator.userAgent);
}
const n = String.raw, Ut = String.raw;
class a {
  constructor() {
    this.callbacks = [];
  }
  /**
   * @param {(() => void|Promise<void>)} cb
   */
  add(t) {
    this.callbacks.push(t);
  }
  run() {
    for (let t = 0; t < this.callbacks.length; t++)
      if (this.callbacks[t] !== null)
        try {
          this.callbacks[t](), this.callbacks[t] = null;
        } catch (e) {
          console.error("cleanup error:", e);
        }
    this.callbacks = this.callbacks.filter((t) => t !== null);
  }
}
const Ge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CleanUp: a,
  Events: h,
  createDraggable: Wt,
  createRipple: ot,
  css: Ut,
  defaultRippleOptions: Kt,
  html: n,
  isAndroid: It
}, Symbol.toStringTag, { value: "Module" })), rt = "1", te = n`
    <style></style>
    <slot></slot>
`, g = class g extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = te, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      getFlex() {
        return this.root.hasAttribute("flex") ? this.root.getAttribute("flex") : rt;
      },
      /**
       * @param {string | null} value
       */
      setFlex(t) {
        t === null ? this.root.removeAttribute("flex") : this.root.setAttribute("flex", t);
      }
    }, this.updateStyle();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "flex":
        this.updateStyle({ flex: i || rt });
        break;
    }
  }
  /**
   * @private
   * @param {Object} attributes
   * @param {string} [attributes.flex]
   */
  updateStyle({ flex: t = rt } = {}) {
    this.shadowRoot.querySelector("style").textContent = `
            :host {
                flex: ${t};
            }
        `;
  }
};
o(g, "register", () => {
  customElements.get("ui-flex-grid-item") || customElements.define("ui-flex-grid-item", g);
}), o(g, "observedAttributes", ["flex"]);
let bt = g;
const st = "0", ee = `
    <style></style>
    <slot></slot>
`, f = class f extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ee, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      getGap() {
        return this.root.getAttribute("gap") || st;
      },
      /**
       * @param {string | null} value
       */
      setGap(t) {
        t === null ? this.root.removeAttribute("gap") : this.root.setAttribute("gap", t);
      }
    }, this.updateStyle();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "gap":
        this.updateStyle({ gap: i || st });
        break;
    }
  }
  /**
   * @private
   * @param {Object} attributes
   * @param {string} [attributes.gap]
   */
  updateStyle({ gap: t = st } = {}) {
    this.shadowRoot.querySelector("style").textContent = `
            :host {
                display: flex !important;
                flex-flow: row nowrap;
                position: relative !important;
                width: 100%;
            }

            :host > ::slotted(*) {
                margin: 0 ${t} !important;
            }

            :host > ::slotted(*:first-child) {
                margin-left: 0 !important;
            }

            :host > ::slotted(*:last-child) {
                margin-right: 0 !important;
            }
        `;
  }
};
o(f, "register", () => {
  customElements.get("ui-flex-grid-row") || customElements.define("ui-flex-grid-row", f);
}), o(f, "observedAttributes", ["gap"]);
let A = f;
const nt = "0", ie = `
    <style></style>
    <slot></slot>
`, m = class m extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ie, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      getGap() {
        return this.root.getAttribute("gap") || nt;
      },
      /**
       * @param {string | null} value
       */
      setGap(t) {
        t === null ? this.root.removeAttribute("gap") : this.root.setAttribute("gap", t);
      }
    }, this.updateStyle();
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "gap":
        this.updateStyle({ gap: i || nt });
        break;
    }
  }
  /**
   * @private
   * @param {Object} attributes
   * @param {string} [attributes.gap]
   */
  updateStyle({ gap: t = nt } = {}) {
    this.shadowRoot.querySelector("style").textContent = `
            :host {
                display: flex !important;
                flex-flow: column nowrap;
                position: relative !important;
                width: 100%;
                height: fit-content;
            }

            :host > ::slotted(*) {
                margin: ${t} 0 !important;
            }

            :host > ::slotted(*:first-child) {
                margin-top: 0 !important;
            }

            :host > ::slotted(*:last-child) {
                margin-bottom: 0 !important;
            }
        `;
  }
};
o(m, "register", () => {
  customElements.get("ui-flex-grid") || customElements.define("ui-flex-grid", m);
}), o(m, "observedAttributes", ["gap"]);
let vt = m;
const oe = n`
    <style>
        * { box-sizing: border-box; }

        :host {
            display: flex !important;
            position: absolute !important;
            z-index: 100;
            background-color: var(--ui-backdrop-bgColor);
            -webkit-backdrop-filter: var(--ui-backdropFilter);
            backdrop-filter: var(--ui-backdropFilter);
            overflow: hidden;
            user-select: none;
        }

        :host([position="top"]) {
            top: 0;
            left: 0;
            right: 0;
            height: var(--ui-app-bar-height);
            border-bottom: 1px solid var(--ui-borderColor);
        }

        :host > ui-flex-grid-row {
            width: 100%;
            height: 100%;
            align-items: center;
            justify-content: space-between;
        }

        :host > ui-flex-grid-row > * {
            height: 100%;
        }

        :host > ui-flex-grid-row > *:nth-child(1),
        :host > ui-flex-grid-row > *:nth-child(3) {
            width: fit-content;
        }

        :host > ui-flex-grid-row > [slot="left"] {
            margin-left: 0 !important;
        }

        :host > ui-flex-grid-row > [slot="center"] {
            width: 100%;
        }

        :host > ui-flex-grid-row > [slot="right"] {
            margin-right: 0 !important;
            justify-content: flex-end;
        }
    </style>

    <ui-flex-grid-row gap="0.25rem">
        <ui-flex-grid-row gap="0.25rem">
            <slot name="left"></slot>
        </ui-flex-grid-row>

        <ui-flex-grid-row gap="0.25rem" style="overflow: hidden;">
            <slot name="center"></slot>
        </ui-flex-grid-row>

        <ui-flex-grid-row gap="0.25rem">
            <slot name="right"></slot>
        </ui-flex-grid-row>
    </ui-flex-grid-row>
`, V = class V extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = oe, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      getLeftSlot() {
        return [...this.root.querySelectorAll('[slot="left"]')];
      },
      getCenterSlot() {
        return [...this.root.querySelectorAll('[slot="center"]')];
      },
      getRightSlot() {
        return [...this.root.querySelectorAll('[slot="right"]')];
      }
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
o(V, "register", () => {
  A.register(), customElements.get("ui-app-bar") || customElements.define("ui-app-bar", V);
});
let wt = V;
const re = n`
    <style>
        * { box-sizing: border-box; }

        :host {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
        }
    </style>

    <slot></slot>
`, Z = class Z extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = re, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      enable() {
        this.root.style.display = "flex";
      },
      disable() {
        this.root.style.display = "none";
      },
      /**
       * @returns {T}
       */
      getItem() {
        return this.root.querySelector("*");
      }
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
o(Z, "register", () => {
  customElements.get("ui-app-bar-item") || customElements.define("ui-app-bar-item", Z);
});
let kt = Z;
const se = n`
    <style>
        * {
            box-sizing: border-box;
        }

        :host {
            display: flex !important;
            align-items: center;
            justify-content: center;
            position: relative !important;
            padding: var(--ui-spacing) calc(var(--ui-spacing) * 2.5);
            border: 1px solid currentColor;
            border-radius: var(--ui-radius);
            overflow: hidden;
            text-transform: capitalize;
            cursor: pointer;
            outline: none;
            user-select: none;
            font-size: 1.1rem;
            font-weight: 450;
            font-family: var(--ui-fontFamily);
            font-variation-settings: var(--ui-button-fontVariation);
        }

        :host([variant="full"]) {
            border: none;
        }

        :host([variant="full"][color="primary"]) {
            background-color: var(--ui-primary-bgColor);
            color: var(--ui-primary-color);
        }

        :host([variant="full"][color="secondary"]) {
            background-color: var(--ui-secondary-bgColor);
            color: var(--ui-secondary-color);
        }

        :host([variant="full"][color="destructive"]) {
            background-color: var(--ui-destructive-bgColor);
            color: var(--ui-destructive-color);
        }

        :host([variant="outline"]) {
            border-color: currentColor;
            background-color: transparent;
        }

        :host([variant="outline"][color="primary"]) {
            color: var(--ui-primary-bgColor);
        }

        :host([variant="outline"][color="secondary"]) {
            color: var(--ui-secondary-bgColor);
        }

        :host([variant="outline"][color="destructive"]) {
            color: var(--ui-destructive-bgColor);
        }

        :host([variant="ghost"]) {
            border-color: transparent;
            background-color: transparent;
            font-weight: 900;
        }

        :host([variant="ghost"][color="primary"]) {
            color: var(--ui-primary-bgColor);
        }

        :host([variant="ghost"][color="secondary"]) {
            color: var(--ui-secondary-bgColor);
        }

        :host([variant="ghost"][color="destructive"]) {
            color: var(--ui-destructive-bgColor);
        }

        :host([disabled]),
        :host([disabled]:hover),
        :host([disabled]:active) {
            background-color: transparent;
            opacity: 0.25;
            cursor: default;
            pointer-events: none;
        }
    </style>

    <slot></slot>
`, b = class b extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = se, this.setAttribute("role", "button"), this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      /**
       * @type {Events<UIButtonEvents>}
       */
      events: new h(),
      /**
       * @private
       * @type {(() => void) | null}
       */
      removeRipple: null,
      /**
       * @returns {UIButtonColor}
       */
      getColor() {
        return this.root.getAttribute("color");
      },
      /**
       * @param {UIButtonColor} value
       */
      setColor(t) {
        this.root.setAttribute("color", t);
      },
      /**
       * @returns {UIButtonVariant}
       */
      getVariant() {
        return this.root.getAttribute("variant");
      },
      /**
       * @param {UIButtonVariant} value
       */
      setVariant(t) {
        this.root.setAttribute("variant", t);
      },
      disable() {
        this.root.setAttribute("disabled", "");
      },
      enable() {
        this.root.removeAttribute("disabled");
      },
      enableRipple() {
        this.removeRipple || (this.removeRipple = ot(this.root, { centered: !0 }), this.root.removeAttribute("no-ripple"));
      },
      disableRipple() {
        this.removeRipple && (this.removeRipple(), this.removeRipple = null, this.root.setAttribute("no-ripple", ""));
      }
    };
  }
  connectedCallback() {
    !this.hasAttribute("no-ripple") && !this.ui.removeRipple && this.ui.enableRipple(), this.bindClickEvent();
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "no-ripple":
        i !== null ? this.ui.disableRipple() : this.ui.enableRipple();
        break;
      case "color":
        i !== null && (["primary", "secondary", "destructive"].includes(
          i
        ) ? this.style.color = null : this.style.color = i);
        break;
    }
  }
  /**
   * @private
   */
  bindClickEvent() {
    const t = async () => {
      this.ui.events.dispatch("click", this);
    };
    this.addEventListener("click", t), this.cleanup.add(() => {
      this.removeEventListener("click", t);
    });
  }
};
o(b, "register", () => {
  customElements.get("ui-button") || customElements.define("ui-button", b);
}), o(b, "observedAttributes", ["no-ripple", "color"]);
let yt = b;
const ne = n`
    <style>
        * {
            box-sizing: border-box;
        }

        :host {
            display: flex !important;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 2rem;
            height: 2rem;
            padding: calc(var(--ui-spacing) / 2);
            border: 1px solid currentColor;
            border-radius: var(--ui-radius);
            outline: none;
            overflow: hidden;
            cursor: pointer;
            user-select: none;
            font-size: 1.1rem;
            font-weight: 450;
            font-family: var(--ui-fontFamily);
            font-variation-settings: var(--ui-button-fontVariation);
        }

        :host([ghost]) {
            border-color: transparent !important;
            box-shadow: none;
            font-weight: 900;
        }

        :host([color="primary"]) {
            color: var(--ui-primary-bgColor);
            border-color: var(--ui-primary-bgColor);
        }

        :host([color="secondary"]) {
            color: var(--ui-secondary-bgColor);
            border-color: var(--ui-secondary-bgColor);
        }

        :host([color="destructive"]) {
            color: var(--ui-destructive-bgColor);
            border-color: var(--ui-destructive-bgColor);
        }

        /* :disabled */

        :host([disabled]),
        :host([disabled]:hover),
        :host([disabled]:active) {
            opacity: 0.25;
            cursor: default;
            pointer-events: none;
        }
    </style>

    <slot></slot>
`, v = class v extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ne, this.setAttribute("role", "button"), this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      /**
       * @type {Events<UIIconButtonEvents>}
       */
      events: new h(),
      /**
       * @private
       * @type {(() => void) | null}
       */
      removeRipple: null,
      /**
       * @returns {UIIconButtonColor}
       */
      getColor() {
        return this.root.getAttribute("color");
      },
      /**
       * @param {UIIconButtonColor} value
       */
      setColor(t) {
        this.root.setAttribute("color", t);
      },
      /**
       * @returns {boolean}
       */
      getGhost() {
        return this.root.hasAttribute("ghost");
      },
      /**
       * @param {boolean} state
       */
      setGhost(t) {
        t ? this.root.setAttribute("ghost", "") : this.root.removeAttribute("ghost");
      },
      disable() {
        this.root.setAttribute("disabled", "");
      },
      enable() {
        this.root.removeAttribute("disabled");
      },
      enableRipple() {
        this.removeRipple || (this.removeRipple = ot(this.root, { centered: !0 }), this.root.removeAttribute("no-ripple"));
      },
      disableRipple() {
        this.removeRipple && (this.removeRipple(), this.removeRipple = null, this.root.setAttribute("no-ripple", ""));
      }
    };
  }
  connectedCallback() {
    !this.hasAttribute("no-ripple") && !this.ui.removeRipple && this.ui.enableRipple(), this.bindClickEvent();
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "no-ripple":
        i !== null ? this.ui.disableRipple() : this.ui.enableRipple();
        break;
      case "color":
        i !== null && (["primary", "secondary", "destructive"].includes(
          i
        ) ? this.style.color = null : this.style.color = i);
        break;
    }
  }
  /**
   * @private
   */
  bindClickEvent() {
    const t = async () => {
      this.ui.events.dispatch("click", this);
    };
    this.addEventListener("click", t), this.cleanup.add(() => {
      this.removeEventListener("click", t);
    });
  }
};
o(v, "register", () => {
  customElements.get("ui-icon-button") || customElements.define("ui-icon-button", v);
}), o(v, "observedAttributes", ["no-ripple", "color"]);
let R = v;
const ae = n`
<style>
    * { box-sizing: border-box; }

    :host {
        display: block;
        width: 100%;
        max-width: 65rem;
        margin: 0 auto !important;
        padding: var(--ui-spacing);
    }
</style>

<slot></slot>
`, $ = class $ extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ae, this.cleanup = new a(), this.ui = {};
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
o($, "register", () => {
  customElements.get("ui-container") || customElements.define("ui-container", $);
});
let Ct = $;
const le = n`
    <style>
        :host {
            width: 100%;
            height: 100%;
            color: inherit;
        }

        svg {
            width: 100%;
            height: 100%;
        }
    </style>

    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
        <g
            id="SVGRepo_tracerCarrier"
            stroke-linecap="round"
            stroke-linejoin="round"
        ></g>
        <g id="SVGRepo_iconCarrier">
            <rect width="24" height="24" fill="none"></rect>
            <path
                d="M12 6V18"
                stroke="currentColor"
                stroke-linecap="round"
                stroke-linejoin="round"
            ></path>
            <path
                d="M6 12H18"
                stroke="currentColor"
                stroke-linecap="round"
                stroke-linejoin="round"
            ></path>
        </g>
    </svg>
`, j = class j extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = le;
  }
};
o(j, "register", () => {
  customElements.get("svg-plus") || customElements.define("svg-plus", j);
});
let Lt = j;
const ce = n`
    <style>
        :host {
            width: 100%;
            height: 100%;
            color: inherit;
        }

        svg {
            width: 100%;
            height: 100%;
        }
    </style>

    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
        <g
            id="SVGRepo_tracerCarrier"
            stroke-linecap="round"
            stroke-linejoin="round"
        ></g>
        <g id="SVGRepo_iconCarrier">
            <rect width="24" height="24" fill="none"></rect>
            <path
                d="M14.5 17L9.5 12L14.5 7"
                stroke="currentColor"
                stroke-linecap="round"
                stroke-linejoin="round"
            ></path>
        </g>
    </svg>
`, G = class G extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ce;
  }
};
o(G, "register", () => {
  customElements.get("svg-chevron-left") || customElements.define("svg-chevron-left", G);
});
let xt = G;
const ue = n`
    <style>
        :host {
            width: 100%;
            height: 100%;
            color: inherit;
        }

        svg {
            width: 100%;
            height: 100%;
        }
    </style>

    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
        <g
            id="SVGRepo_tracerCarrier"
            stroke-linecap="round"
            stroke-linejoin="round"
        ></g>
        <g id="SVGRepo_iconCarrier">
            <rect width="24" height="24" fill="none"></rect>
            <path
                d="M17 9.5L12 14.5L7 9.5"
                stroke="currentColor"
                stroke-linecap="round"
                stroke-linejoin="round"
            ></path>
        </g>
    </svg>
`, B = class B extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ue;
  }
};
o(B, "register", () => {
  customElements.get("svg-chevron-down") || customElements.define("svg-chevron-down", B);
});
let at = B;
const he = n`
    <style>
        :host {
            width: 100%;
            height: 100%;
            color: inherit;
        }

        svg {
            width: 100%;
            height: 100%;
        }
    </style>

    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
        <g
            id="SVGRepo_tracerCarrier"
            stroke-linecap="round"
            stroke-linejoin="round"
        ></g>
        <g id="SVGRepo_iconCarrier">
            <rect width="24" height="24" fill="none"></rect>
            <path
                d="M7 17L16.8995 7.10051"
                stroke="currentColor"
                stroke-linecap="round"
                stroke-linejoin="round"
            ></path>
            <path
                d="M7 7.00001L16.8995 16.8995"
                stroke="currentColor"
                stroke-linecap="round"
                stroke-linejoin="round"
            ></path>
        </g>
    </svg>
`, F = class F extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = he;
  }
};
o(F, "register", () => {
  customElements.get("svg-close") || customElements.define("svg-close", F);
});
let lt = F;
const de = n`
    <style>
        :host {
            width: 100%;
            height: 100%;
            color: inherit;
        }

        svg {
            width: 100%;
            height: 100%;
        }
    </style>

    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
        <g
            id="SVGRepo_tracerCarrier"
            stroke-linecap="round"
            stroke-linejoin="round"
        ></g>
        <g id="SVGRepo_iconCarrier">
            <rect width="24" height="24" fill="none"></rect>
            <path
                d="M5 12V18C5 18.5523 5.44772 19 6 19H18C18.5523 19 19 18.5523 19 18V12"
                stroke="currentColor"
                stroke-linecap="round"
                stroke-linejoin="round"
            ></path>
            <path
                d="M12 3L12 15M12 15L16 11M12 15L8 11"
                stroke="currentColor"
                stroke-linecap="round"
                stroke-linejoin="round"
            ></path>
        </g>
    </svg>
`, z = class z extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = de;
  }
};
o(z, "register", () => {
  customElements.get("svg-download") || customElements.define("svg-download", z);
});
let Mt = z;
const pe = n`
    <style>
        :host {
            width: 100%;
            height: 100%;
            color: inherit;
        }

        svg {
            width: 100%;
            height: 100%;
        }
    </style>

    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
        <g
            id="SVGRepo_tracerCarrier"
            stroke-linecap="round"
            stroke-linejoin="round"
        ></g>
        <g id="SVGRepo_iconCarrier">
            <rect width="24" height="24" fill="none"></rect>
            <path
                d="M15.6287 5.12132L4.31497 16.435M15.6287 5.12132L19.1642 8.65685M15.6287 5.12132L17.0429 3.70711C17.4334 3.31658 18.0666 3.31658 18.4571 3.70711L20.5784 5.82843C20.969 6.21895 20.969 6.85212 20.5784 7.24264L19.1642 8.65685M7.85051 19.9706L4.31497 16.435M7.85051 19.9706L19.1642 8.65685M7.85051 19.9706L3.25431 21.0312L4.31497 16.435"
                stroke="currentColor"
                stroke-linecap="round"
                stroke-linejoin="round"
            ></path>
        </g>
    </svg>
`, q = class q extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = pe;
  }
};
o(q, "register", () => {
  customElements.get("svg-pen") || customElements.define("svg-pen", q);
});
let Et = q;
const ge = n`
    <style>
        :host {
            width: 100%;
            height: 100%;
            color: inherit;
        }

        svg {
            width: 100%;
            height: 100%;
        }
    </style>

    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
        <g
            id="SVGRepo_tracerCarrier"
            stroke-linecap="round"
            stroke-linejoin="round"
        ></g>
        <g id="SVGRepo_iconCarrier">
            <rect width="24" height="24" fill="none"></rect>
            <path
                d="M13 3L16 6L19 9M13 3L5 3L5 21L19 21L19 9M13 3L13 9L19 9"
                stroke="currentColor"
                stroke-linejoin="round"
            ></path>
        </g>
    </svg>
`, _ = class _ extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ge;
  }
};
o(_, "register", () => {
  customElements.get("svg-document-new") || customElements.define("svg-document-new", _);
});
let St = _;
const fe = n`
    <style>
        :host {
            width: 100%;
            height: 100%;
            color: inherit;
        }

        svg {
            width: 100%;
            height: 100%;
        }
    </style>

    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
        <g
            id="SVGRepo_tracerCarrier"
            stroke-linecap="round"
            stroke-linejoin="round"
        ></g>
        <g id="SVGRepo_iconCarrier">
            <rect width="24" height="24" fill="none"></rect>
            <path
                d="M5 7.5H19L18 21H6L5 7.5Z"
                stroke="currentColor"
                stroke-linejoin="round"
            ></path>
            <path
                d="M15.5 9.5L15 19"
                stroke="currentColor"
                stroke-linecap="round"
                stroke-linejoin="round"
            ></path>
            <path
                d="M12 9.5V19"
                stroke="currentColor"
                stroke-linecap="round"
                stroke-linejoin="round"
            ></path>
            <path
                d="M8.5 9.5L9 19"
                stroke="currentColor"
                stroke-linecap="round"
                stroke-linejoin="round"
            ></path>
            <path
                d="M16 5H19C20.1046 5 21 5.89543 21 7V7.5H3V7C3 5.89543 3.89543 5 5 5H8M16 5L15 3H9L8 5M16 5H8"
                stroke="currentColor"
                stroke-linejoin="round"
            ></path>
        </g>
    </svg>
`, O = class O extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = fe;
  }
};
o(O, "register", () => {
  customElements.get("svg-trash") || customElements.define("svg-trash", O);
});
let At = O;
const me = n`
    <style>
        :host {
            width: 100%;
            height: 100%;
            color: inherit;
        }

        svg {
            width: 100%;
            height: 100%;
        }
    </style>

    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
        <g
            id="SVGRepo_tracerCarrier"
            stroke-linecap="round"
            stroke-linejoin="round"
        ></g>
        <g id="SVGRepo_iconCarrier">
            <g clip-path="url(#clip0_15_152)">
                <rect width="24" height="24" fill="none"></rect>
                <circle
                    cx="10.5"
                    cy="10.5"
                    r="6.5"
                    stroke="currentColor"
                    stroke-linejoin="round"
                ></circle>
                <path
                    d="M19.6464 20.3536C19.8417 20.5488 20.1583 20.5488 20.3536 20.3536C20.5488 20.1583 20.5488 19.8417 20.3536 19.6464L19.6464 20.3536ZM20.3536 19.6464L15.3536 14.6464L14.6464 15.3536L19.6464 20.3536L20.3536 19.6464Z"
                    fill="currentColor"
                ></path>
            </g>
            <defs>
                <clipPath id="clip0_15_152">
                    <rect width="24" height="24" fill="none"></rect>
                </clipPath>
            </defs>
        </g>
    </svg>
`, P = class P extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = me;
  }
};
o(P, "register", () => {
  customElements.get("svg-search") || customElements.define("svg-search", P);
});
let ct = P;
const be = n`
    <style>
        :host {
            width: 100%;
            height: 100%;
            color: inherit;
        }

        svg {
            width: 100%;
            height: 100%;
        }
    </style>

    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
        <g
            id="SVGRepo_tracerCarrier"
            stroke-linecap="round"
            stroke-linejoin="round"
        ></g>
        <g id="SVGRepo_iconCarrier">
            <rect width="24" height="24" fill="none"></rect>
            <path
                d="M13.5 2L13.9961 1.93798C13.9649 1.68777 13.7522 1.5 13.5 1.5V2ZM10.5 2V1.5C10.2478 1.5 10.0351 1.68777 10.0039 1.93798L10.5 2ZM13.7747 4.19754L13.2786 4.25955C13.3047 4.46849 13.4589 4.63867 13.6642 4.68519L13.7747 4.19754ZM16.2617 5.22838L15.995 5.6513C16.1731 5.76362 16.4024 5.75233 16.5687 5.62306L16.2617 5.22838ZM18.0104 3.86826L18.364 3.51471C18.1857 3.3364 17.9025 3.31877 17.7034 3.47359L18.0104 3.86826ZM20.1317 5.98958L20.5264 6.29655C20.6812 6.09751 20.6636 5.81434 20.4853 5.63603L20.1317 5.98958ZM18.7716 7.73831L18.3769 7.43134C18.2477 7.59754 18.2364 7.82693 18.3487 8.00503L18.7716 7.73831ZM19.8025 10.2253L19.3148 10.3358C19.3613 10.5411 19.5315 10.6953 19.7404 10.7214L19.8025 10.2253ZM22 10.5H22.5C22.5 10.2478 22.3122 10.0351 22.062 10.0039L22 10.5ZM22 13.5L22.062 13.9961C22.3122 13.9649 22.5 13.7522 22.5 13.5H22ZM19.8025 13.7747L19.7404 13.2786C19.5315 13.3047 19.3613 13.4589 19.3148 13.6642L19.8025 13.7747ZM18.7716 16.2617L18.3487 15.995C18.2364 16.1731 18.2477 16.4025 18.3769 16.5687L18.7716 16.2617ZM20.1317 18.0104L20.4853 18.364C20.6636 18.1857 20.6812 17.9025 20.5264 17.7034L20.1317 18.0104ZM18.0104 20.1317L17.7034 20.5264C17.9025 20.6812 18.1857 20.6636 18.364 20.4853L18.0104 20.1317ZM16.2617 18.7716L16.5687 18.3769C16.4024 18.2477 16.1731 18.2364 15.995 18.3487L16.2617 18.7716ZM13.7747 19.8025L13.6642 19.3148C13.4589 19.3613 13.3047 19.5315 13.2786 19.7404L13.7747 19.8025ZM13.5 22V22.5C13.7522 22.5 13.9649 22.3122 13.9961 22.062L13.5 22ZM10.5 22L10.0039 22.062C10.0351 22.3122 10.2478 22.5 10.5 22.5V22ZM10.2253 19.8025L10.7214 19.7404C10.6953 19.5315 10.5411 19.3613 10.3358 19.3148L10.2253 19.8025ZM7.73832 18.7716L8.00504 18.3487C7.82694 18.2364 7.59756 18.2477 7.43135 18.3769L7.73832 18.7716ZM5.98959 20.1317L5.63604 20.4853C5.81435 20.6636 6.09752 20.6812 6.29656 20.5264L5.98959 20.1317ZM3.86827 18.0104L3.4736 17.7034C3.31878 17.9025 3.33641 18.1857 3.51472 18.364L3.86827 18.0104ZM5.22839 16.2617L5.62307 16.5687C5.75234 16.4025 5.76363 16.1731 5.65131 15.995L5.22839 16.2617ZM4.19754 13.7747L4.68519 13.6642C4.63867 13.4589 4.46849 13.3047 4.25955 13.2786L4.19754 13.7747ZM2 13.5H1.5C1.5 13.7522 1.68777 13.9649 1.93798 13.9961L2 13.5ZM2 10.5L1.93798 10.0039C1.68777 10.0351 1.5 10.2478 1.5 10.5H2ZM4.19754 10.2253L4.25955 10.7214C4.46849 10.6953 4.63867 10.5411 4.68519 10.3358L4.19754 10.2253ZM5.22839 7.73831L5.65131 8.00503C5.76363 7.82693 5.75234 7.59755 5.62307 7.43134L5.22839 7.73831ZM3.86827 5.98959L3.51472 5.63603C3.33641 5.81434 3.31878 6.09751 3.47359 6.29656L3.86827 5.98959ZM5.98959 3.86827L6.29656 3.47359C6.09752 3.31878 5.81434 3.33641 5.63604 3.51471L5.98959 3.86827ZM7.73832 5.22839L7.43135 5.62306C7.59755 5.75233 7.82694 5.76363 8.00504 5.6513L7.73832 5.22839ZM10.2253 4.19754L10.3358 4.68519C10.5411 4.63867 10.6953 4.46849 10.7214 4.25955L10.2253 4.19754ZM13.5 1.5H10.5V2.5H13.5V1.5ZM14.2708 4.13552L13.9961 1.93798L13.0039 2.06202L13.2786 4.25955L14.2708 4.13552ZM16.5284 4.80547C15.7279 4.30059 14.8369 3.92545 13.8851 3.70989L13.6642 4.68519C14.503 4.87517 15.2886 5.20583 15.995 5.6513L16.5284 4.80547ZM16.5687 5.62306L18.3174 4.26294L17.7034 3.47359L15.9547 4.83371L16.5687 5.62306ZM17.6569 4.22182L19.7782 6.34314L20.4853 5.63603L18.364 3.51471L17.6569 4.22182ZM19.7371 5.68261L18.3769 7.43134L19.1663 8.04528L20.5264 6.29655L19.7371 5.68261ZM20.2901 10.1149C20.0746 9.16313 19.6994 8.27213 19.1945 7.47158L18.3487 8.00503C18.7942 8.71138 19.1248 9.49695 19.3148 10.3358L20.2901 10.1149ZM22.062 10.0039L19.8645 9.72917L19.7404 10.7214L21.938 10.9961L22.062 10.0039ZM22.5 13.5V10.5H21.5V13.5H22.5ZM19.8645 14.2708L22.062 13.9961L21.938 13.0039L19.7404 13.2786L19.8645 14.2708ZM19.1945 16.5284C19.6994 15.7279 20.0746 14.8369 20.2901 13.8851L19.3148 13.6642C19.1248 14.503 18.7942 15.2886 18.3487 15.995L19.1945 16.5284ZM20.5264 17.7034L19.1663 15.9547L18.3769 16.5687L19.7371 18.3174L20.5264 17.7034ZM18.364 20.4853L20.4853 18.364L19.7782 17.6569L17.6569 19.7782L18.364 20.4853ZM15.9547 19.1663L17.7034 20.5264L18.3174 19.7371L16.5687 18.3769L15.9547 19.1663ZM13.8851 20.2901C14.8369 20.0746 15.7279 19.6994 16.5284 19.1945L15.995 18.3487C15.2886 18.7942 14.503 19.1248 13.6642 19.3148L13.8851 20.2901ZM13.9961 22.062L14.2708 19.8645L13.2786 19.7404L13.0039 21.938L13.9961 22.062ZM10.5 22.5H13.5V21.5H10.5V22.5ZM9.72917 19.8645L10.0039 22.062L10.9961 21.938L10.7214 19.7404L9.72917 19.8645ZM7.4716 19.1945C8.27214 19.6994 9.16314 20.0746 10.1149 20.2901L10.3358 19.3148C9.49696 19.1248 8.71139 18.7942 8.00504 18.3487L7.4716 19.1945ZM6.29656 20.5264L8.04529 19.1663L7.43135 18.3769L5.68262 19.7371L6.29656 20.5264ZM3.51472 18.364L5.63604 20.4853L6.34315 19.7782L4.22183 17.6569L3.51472 18.364ZM4.83372 15.9547L3.4736 17.7034L4.26295 18.3174L5.62307 16.5687L4.83372 15.9547ZM3.70989 13.8851C3.92545 14.8369 4.30059 15.7279 4.80547 16.5284L5.65131 15.995C5.20584 15.2886 4.87517 14.503 4.68519 13.6642L3.70989 13.8851ZM1.93798 13.9961L4.13552 14.2708L4.25955 13.2786L2.06202 13.0039L1.93798 13.9961ZM1.5 10.5V13.5H2.5V10.5H1.5ZM4.13552 9.72917L1.93798 10.0039L2.06202 10.9961L4.25955 10.7214L4.13552 9.72917ZM4.80547 7.47159C4.30059 8.27213 3.92545 9.16313 3.70989 10.1149L4.68519 10.3358C4.87517 9.49696 5.20583 8.71138 5.65131 8.00503L4.80547 7.47159ZM3.47359 6.29656L4.83371 8.04528L5.62307 7.43134L4.26295 5.68262L3.47359 6.29656ZM5.63604 3.51471L3.51472 5.63603L4.22182 6.34314L6.34314 4.22182L5.63604 3.51471ZM8.04529 4.83371L6.29656 3.47359L5.68262 4.26294L7.43135 5.62306L8.04529 4.83371ZM10.1149 3.70989C9.16313 3.92545 8.27214 4.30059 7.4716 4.80547L8.00504 5.6513C8.71139 5.20583 9.49696 4.87517 10.3358 4.68519L10.1149 3.70989ZM10.0039 1.93798L9.72917 4.13552L10.7214 4.25955L10.9961 2.06202L10.0039 1.93798Z"
                fill="currentColor"
            ></path>
            <circle
                cx="12"
                cy="12"
                r="4"
                stroke="currentColor"
                stroke-linejoin="round"
            ></circle>
        </g>
    </svg>
`, N = class N extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = be;
  }
};
o(N, "register", () => {
  customElements.get("svg-settings") || customElements.define("svg-settings", N);
});
let Rt = N;
const ve = n`
    <style>
        :host {
            width: 100%;
            height: 100%;
            color: inherit;
        }

        svg {
            width: 100%;
            height: 100%;
        }
    </style>

    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
        <g
            id="SVGRepo_tracerCarrier"
            stroke-linecap="round"
            stroke-linejoin="round"
        ></g>
        <g id="SVGRepo_iconCarrier">
            <rect width="24" height="24" fill="none"></rect>
            <path
                d="M6 12H18"
                stroke="currentColor"
                stroke-linecap="round"
                stroke-linejoin="round"
            ></path>
            <path
                d="M6 15.5H18"
                stroke="currentColor"
                stroke-linecap="round"
                stroke-linejoin="round"
            ></path>
            <path
                d="M6 8.5H18"
                stroke="currentColor"
                stroke-linecap="round"
                stroke-linejoin="round"
            ></path>
        </g>
    </svg>
`, D = class D extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ve;
  }
};
o(D, "register", () => {
  customElements.get("svg-menu") || customElements.define("svg-menu", D);
});
let Ht = D;
const we = n`
    <style>
        :host {
            width: 100%;
            height: 100%;
            color: inherit;
        }

        svg {
            width: 100%;
            height: 100%;
        }
    </style>

    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
        <g
            id="SVGRepo_tracerCarrier"
            stroke-linecap="round"
            stroke-linejoin="round"
        ></g>
        <g id="SVGRepo_iconCarrier">
            <g clip-path="url(#clip0_15_72)">
                <rect width="24" height="24" fill="none"></rect>
                <circle
                    cx="7"
                    cy="12"
                    r="2"
                    stroke="currentColor"
                    stroke-linejoin="round"
                ></circle>
                <circle
                    cx="17"
                    cy="6"
                    r="2"
                    stroke="currentColor"
                    stroke-linejoin="round"
                ></circle>
                <path d="M15 7L8.5 11" stroke="currentColor"></path>
                <circle
                    cx="17"
                    cy="18"
                    r="2"
                    stroke="currentColor"
                    stroke-linejoin="round"
                ></circle>
                <path d="M8.5 13.5L15 17" stroke="currentColor"></path>
            </g>
            <defs>
                <clipPath id="clip0_15_72">
                    <rect width="24" height="24" fill="none"></rect>
                </clipPath>
            </defs>
        </g>
    </svg>
`, K = class K extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = we;
  }
};
o(K, "register", () => {
  customElements.get("svg-share") || customElements.define("svg-share", K);
});
let Tt = K;
const ke = n`
    <style>
        :host {
            width: 100%;
            height: 100%;
            color: inherit;
        }

        svg {
            width: 100%;
            height: 100%;
        }
    </style>

    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
        <g
            id="SVGRepo_tracerCarrier"
            stroke-linecap="round"
            stroke-linejoin="round"
        ></g>
        <g id="SVGRepo_iconCarrier">
            <rect width="24" height="24" fill="none"></rect>
            <g filter="url(#filter0_d_15_286)">
                <path
                    d="M3 8.26667V19C3 19.5523 3.44772 20 4 20H20C20.5523 20 21 19.5523 21 19V8.26667M3 8.26667V5C3 4.44772 3.44772 4 4 4H20C20.5523 4 21 4.44772 21 5V8.26667M3 8.26667H21"
                    stroke="currentColor"
                    stroke-linejoin="round"
                ></path>
            </g>
            <g filter="url(#filter1_d_15_286)">
                <circle
                    cx="12"
                    cy="14"
                    r="2"
                    stroke="currentColor"
                    stroke-linejoin="round"
                ></circle>
            </g>
            <g filter="url(#filter2_d_15_286)">
                <path
                    d="M7 2V5"
                    stroke="currentColor"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                ></path>
            </g>
            <g filter="url(#filter3_d_15_286)">
                <path
                    d="M17 2V5"
                    stroke="currentColor"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                ></path>
            </g>
            <defs>
                <filter
                    id="filter0_d_15_286"
                    x="1.5"
                    y="3.5"
                    width="21"
                    height="19"
                    filterUnits="userSpaceOnUse"
                    color-interpolation-filters="sRGB"
                >
                    <feFlood
                        flood-opacity="0"
                        result="BackgroundImageFix"
                    ></feFlood>
                    <feColorMatrix
                        in="SourceAlpha"
                        type="matrix"
                        values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
                        result="hardAlpha"
                    ></feColorMatrix>
                    <feOffset dy="1"></feOffset>
                    <feGaussianBlur stdDeviation="0.5"></feGaussianBlur>
                    <feColorMatrix
                        type="matrix"
                        values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.1 0"
                    ></feColorMatrix>
                    <feBlend
                        mode="normal"
                        in2="BackgroundImageFix"
                        result="effect1_dropShadow_15_286"
                    ></feBlend>
                    <feBlend
                        mode="normal"
                        in="SourceGraphic"
                        in2="effect1_dropShadow_15_286"
                        result="shape"
                    ></feBlend>
                </filter>
                <filter
                    id="filter1_d_15_286"
                    x="8.5"
                    y="11.5"
                    width="7"
                    height="7"
                    filterUnits="userSpaceOnUse"
                    color-interpolation-filters="sRGB"
                >
                    <feFlood
                        flood-opacity="0"
                        result="BackgroundImageFix"
                    ></feFlood>
                    <feColorMatrix
                        in="SourceAlpha"
                        type="matrix"
                        values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
                        result="hardAlpha"
                    ></feColorMatrix>
                    <feOffset dy="1"></feOffset>
                    <feGaussianBlur stdDeviation="0.5"></feGaussianBlur>
                    <feColorMatrix
                        type="matrix"
                        values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.1 0"
                    ></feColorMatrix>
                    <feBlend
                        mode="normal"
                        in2="BackgroundImageFix"
                        result="effect1_dropShadow_15_286"
                    ></feBlend>
                    <feBlend
                        mode="normal"
                        in="SourceGraphic"
                        in2="effect1_dropShadow_15_286"
                        result="shape"
                    ></feBlend>
                </filter>
                <filter
                    id="filter2_d_15_286"
                    x="5.5"
                    y="1.5"
                    width="3"
                    height="6"
                    filterUnits="userSpaceOnUse"
                    color-interpolation-filters="sRGB"
                >
                    <feFlood
                        flood-opacity="0"
                        result="BackgroundImageFix"
                    ></feFlood>
                    <feColorMatrix
                        in="SourceAlpha"
                        type="matrix"
                        values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
                        result="hardAlpha"
                    ></feColorMatrix>
                    <feOffset dy="1"></feOffset>
                    <feGaussianBlur stdDeviation="0.5"></feGaussianBlur>
                    <feColorMatrix
                        type="matrix"
                        values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.1 0"
                    ></feColorMatrix>
                    <feBlend
                        mode="normal"
                        in2="BackgroundImageFix"
                        result="effect1_dropShadow_15_286"
                    ></feBlend>
                    <feBlend
                        mode="normal"
                        in="SourceGraphic"
                        in2="effect1_dropShadow_15_286"
                        result="shape"
                    ></feBlend>
                </filter>
                <filter
                    id="filter3_d_15_286"
                    x="15.5"
                    y="1.5"
                    width="3"
                    height="6"
                    filterUnits="userSpaceOnUse"
                    color-interpolation-filters="sRGB"
                >
                    <feFlood
                        flood-opacity="0"
                        result="BackgroundImageFix"
                    ></feFlood>
                    <feColorMatrix
                        in="SourceAlpha"
                        type="matrix"
                        values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
                        result="hardAlpha"
                    ></feColorMatrix>
                    <feOffset dy="1"></feOffset>
                    <feGaussianBlur stdDeviation="0.5"></feGaussianBlur>
                    <feColorMatrix
                        type="matrix"
                        values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.1 0"
                    ></feColorMatrix>
                    <feBlend
                        mode="normal"
                        in2="BackgroundImageFix"
                        result="effect1_dropShadow_15_286"
                    ></feBlend>
                    <feBlend
                        mode="normal"
                        in="SourceGraphic"
                        in2="effect1_dropShadow_15_286"
                        result="shape"
                    ></feBlend>
                </filter>
            </defs>
        </g>
    </svg>
`, Y = class Y extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ke;
  }
};
o(Y, "register", () => {
  customElements.get("svg-today") || customElements.define("svg-today", Y);
});
let Vt = Y;
const ye = n`
    <style>
        * {
            box-sizing: border-box;
        }

        :host dialog * {
            box-sizing: border-box;
        }

        dialog {
            position: fixed !important;

            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);

            max-width: 100%;
            max-height: 100%;

            margin: 0;
            padding: 0;

            border: none;
            outline: none;

            background-color: transparent;

            -ms-overflow-style: none;
            scrollbar-width: none;

            z-index: 999;
        }

        dialog::-webkit-scrollbar {
            display: none;
        }

        dialog::backdrop {
            background-color: var(--ui-backdrop-bgColor);
            backdrop-filter: var(--ui-backdropFilter);
        }

        dialog > .container {
            background-color: var(--ui-bgColor);
            color: var(--ui-color);

            border: 1px solid var(--ui-borderColor);
            border-radius: var(--ui-radius);

            padding: var(--ui-spacing);

            display: flex;
            flex-direction: column;
            justify-content: space-between;

            position: relative;
        }

        :host([fullscreen]) dialog {
            width: 100%;
            height: 100%;
        }

        :host([fullscreen]) dialog > .container {
            width: calc(100% - var(--ui-spacing) * 2);
            height: calc(
                100% -
                    (
                        env(safe-area-inset-top, 0) +
                            env(safe-area-inset-bottom, 0) +
                            (var(--ui-spacing) * 2)
                    )
            );

            margin: var(--ui-spacing);
            margin-top: calc(env(safe-area-inset-top, 0) + var(--ui-spacing));
            margin-bottom: calc(
                env(safe-area-inset-bottom, 0) + var(--ui-spacing)
            );
        }

        /*
        * Header Styles
        */

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;

            border-top-right-radius: var(--ui-radius);
            border-top-left-radius: var(--ui-radius);

            width: 100%;
            height: var(--ui-dialog-header-height);
        }

        .header h4 {
            margin: auto 0;
        }

        :host([fullscreen]) .header {
            z-index: 15;
            position: absolute;
            top: var(--ui-spacing);
            right: var(--ui-spacing);
            left: var(--ui-spacing);
            width: calc(100% - var(--ui-spacing) * 2);
        }

        /*
        * Content Styles
        */

        .content {
            padding: var(--ui-spacing);
            height: fit-content;
            min-width: fit-content;
            width: 100%;
        }

        :host([fullscreen]) .content {
            z-index: 10;
            position: absolute;
            top: calc(var(--ui-dialog-header-height) + var(--ui-spacing));
            bottom: calc(var(--ui-dialog-footer-height) + var(--ui-spacing));
            right: var(--ui-spacing);
            left: var(--ui-spacing);
            padding: unset;
            height: unset;
            width: unset;
            min-width: unset;
        }

        /*
        * Footer Styles
        */

        .footer {
            margin-top: var(--ui-spacing);
            border-bottom-right-radius: var(--ui-radius);
            border-bottom-left-radius: var(--ui-radius);

            width: 100%;
            height: var(--ui-dialog-footer-height);
        }

        :host([fullscreen]) .footer {
            z-index: 15;
            position: absolute;
            right: var(--ui-spacing);
            bottom: var(--ui-spacing);
            left: var(--ui-spacing);
            width: calc(100% - var(--ui-spacing) * 2);
        }

        .footer ui-flex-grid-row {
            height: 100%;
            flex-wrap: nowrap;
            justify-content: flex-end;
            align-items: center;
        }
    </style>

    <dialog>
        <div class="container">
            <div class="header">
                <span style="white-space: nowrap;"
                    ><slot name="title"></slot
                ></span>

                <ui-icon-button
                    style="width: var(--ui-dialog-header-height); height: 100%;"
                    ghost
                >
                    <svg-close></svg-close>
                </ui-icon-button>
            </div>

            <div class="content">
                <slot></slot>
            </div>

            <div class="footer">
                <ui-flex-grid-row gap="calc(var(--ui-spacing) / 2)">
                    <slot name="actions"></slot>
                </ui-flex-grid-row>
            </div>
        </div>
    </dialog>
`, J = class J extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = ye, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      /** @type {Events<T>} */
      events: new h(),
      /**
       * @private
       * @type {HTMLElement}
       */
      h4: (() => {
        const t = document.createElement("h4");
        return t.slot = "title", this.appendChild(t), t;
      })(),
      /**
       * @private
       * @type {HTMLDialogElement}
       */
      dialog: this.shadowRoot.querySelector("dialog"),
      getFullscreen() {
        return this.root.hasAttribute("fullscreen");
      },
      /**
       * @param {boolean} state
       */
      setFullscreen(t) {
        t ? this.root.setAttribute("fullscreen", "") : this.root.removeAttribute("fullscreen");
      },
      getTitle() {
        return this.h4.innerText;
      },
      /**
       * @param {string} value
       */
      setTitle(t) {
        this.h4.innerText = t;
      },
      getDialogElement() {
        return this.dialog;
      },
      /**
       * @param {boolean} modal
       * @param {boolean} [inert] - This will prevent the autofocus on input elements (default: true)
       */
      open(t = !1, e = !0) {
        const i = this.dialog.inert;
        this.dialog.inert = e, t ? this.dialog.showModal() : this.dialog.show(), this.events.dispatch("open", null), this.dialog.inert = i;
      },
      close() {
        this.dialog.close(), this.events.dispatch("close", null);
      }
    };
  }
  connectedCallback() {
    const t = this.shadowRoot.querySelector(".header ui-icon-button"), e = () => {
      this.ui.close();
    };
    t.addEventListener("click", e);
    const i = this.shadowRoot.querySelector("dialog"), s = (l) => {
      l.preventDefault();
    };
    i.addEventListener("cancel", s), this.cleanup.add(() => {
      t.removeEventListener("click", e), i.removeEventListener("cancel", s);
    });
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
o(J, "register", () => {
  lt.register(), R.register(), A.register(), customElements.get("ui-dialog") || customElements.define("ui-dialog", J);
});
let Zt = J;
const $t = 150, Ce = n`
    <style>
        * {
            box-sizing: border-box;
        }

        :host {
            display: block;

            position: absolute !important;
            z-index: ${$t};
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;

            overflow: hidden;

            transition: left 0s ease 0.5s;
        }

        :host([open]) {
            background-color: var(--ui-backdrop-bgColor);
            -webkit-backdrop-filter: var(--ui-backdropFilter);
            backdrop-filter: var(--ui-backdropFilter);

            left: 0;

            transition: none;
        }

        aside {
            position: absolute;
            z-index: ${$t};
            top: 0;
            left: -100%;
            width: 18em;
            max-width: 100%;
            height: 100%;

            overflow-x: hidden;
            overflow-y: auto;

            -ms-overflow-style: none;
            scrollbar-width: none;

            /*
            background-color: var(--ui-card-bgColor);
            color: var(--ui-card-color);
            */
            border-right: 1px solid var(--ui-card-borderColor);
            background-color: var(--ui-backdrop-bgColor);
            -webkit-backdrop-filter: var(--ui-backdropFilter);
            backdrop-filter: var(--ui-backdropFilter);

            transition: left 0.5s ease;
        }

        :host([open]) aside {
            left: 0;
        }
    </style>

    <aside>
        <slot></slot>
    </aside>
`, w = class w extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Ce, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      aside: this.shadowRoot.querySelector("aside"),
      /**
       * @type {Events<UIDrawerEvents>}
       */
      events: new h(),
      getOpen() {
        return this.root.hasAttribute("open");
      },
      /**
       * @param {boolean} state
       */
      setOpen(t) {
        t ? this.root.setAttribute("open", "") : this.root.removeAttribute("open");
      }
    };
  }
  connectedCallback() {
    const t = (i) => {
      i.stopPropagation(), this.ui.setOpen(!1);
    }, e = (i) => {
      i.stopPropagation();
    };
    this.addEventListener("click", t), this.ui.aside.addEventListener("click", e), this.cleanup.add(() => {
      this.ui.aside.removeEventListener("click", e), this.removeEventListener("click", t);
    });
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "open":
        i !== null ? (this.classList.add("open"), this.ui.events.dispatch("open", this)) : (this.classList.remove("open"), this.ui.events.dispatch("close", this));
        break;
    }
  }
};
o(w, "register", () => {
  customElements.get("ui-drawer") || customElements.define("ui-drawer", w);
}), o(w, "observedAttributes", ["open"]);
let jt = w;
const Le = n`
    <style>
        :host {
            font-size: 1.1rem;
            font-family: var(--ui-fontFamily);
            font-variation-settings: var(--ui-text-primary-fontVariation);
        }
    </style>

    <slot></slot>
`, X = class X extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Le, this.cleanup = new a(), this.ui = {};
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
o(X, "register", () => {
  customElements.get("ui-primary") || customElements.define("ui-primary", X);
});
let H = X;
const xe = n`
    <style>
        :host {
            font-size: 0.9rem;
            font-family: var(--ui-fontFamily);
            font-variation-settings: var(--ui-text-secondary-fontVariation);
        }
    </style>

    <slot></slot>
`, Q = class Q extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = xe, this.cleanup = new a(), this.ui = {};
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
o(Q, "register", () => {
  customElements.get("ui-secondary") || customElements.define("ui-secondary", Q);
});
let p = Q;
const Me = n`
    <style>
        * {
            box-sizing: border-box;
        }

        :host {
            position: relative !important;
            display: flex !important;
            flex-direction: row;
            width: 100%;
            padding: var(--ui-spacing);
            border-radius: var(--ui-radius);
        }

        :host > .text {
            display: flex;
            flex: 1;
            flex-direction: column;
            justify-content: center;
            margin-right: var(--ui-spacing);
        }

        :host > .input {
            display: flex;
            align-items: center;
            justify-content: flex-end;
        }
    </style>

    <span class="text">
        <ui-primary></ui-primary>
        <ui-secondary></ui-secondary>
    </span>

    <span class="input">
        <slot name="input"></slot>
        <slot></slot>
    </span>
`, k = class k extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Me, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      /** @private */
      running: !1,
      /**
       * @private
       * @type {(() => void|Promise<void>) | null}
       */
      removeRipple: null,
      /** @private */
      onClick: async () => {
        this.ui.getInputSlot().forEach((t) => t.click());
      },
      /** @private */
      onInputClick: async (t) => {
        t.stopPropagation();
      },
      getPrimary() {
        return this.root.getAttribute("primary");
      },
      /**
       * @param {string | null} value
       */
      setPrimary(t) {
        if (t === null) {
          this.root.removeAttribute("primary");
          return;
        }
        this.root.setAttribute("primary", t);
      },
      getSecondary() {
        return this.root.getAttribute("secondary");
      },
      /**
       * @param {string | null} value
       */
      setSecondary(t) {
        if (t === null) {
          this.root.removeAttribute("secondary");
          return;
        }
        this.root.setAttribute("secondary", t);
      },
      /**
       * @returns {HTMLElement[]}
       */
      getInputSlot() {
        return [...this.root.querySelectorAll('[slot="input"]')];
      },
      enableRipple() {
        this.removeRipple || (this.removeRipple = ot(this.root), this.root.style.cursor = "pointer", this.startInputHandling());
      },
      disableRipple() {
        this.removeRipple && this.removeRipple(), this.stopInputHandling();
      },
      /** @private */
      startInputHandling() {
        this.running || (this.root.addEventListener("click", this.onClick), this.getInputSlot().forEach((t) => {
          t.addEventListener("click", this.onInputClick);
        }), this.running = !0);
      },
      /**
       * @private
       */
      stopInputHandling() {
        this.root.removeEventListener("click", this.onClick), this.getInputSlot().forEach((t) => {
          t.removeEventListener("click", this.onInputClick);
        }), this.running = !1;
      }
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "ripple":
        i !== null ? this.ui.enableRipple() : this.ui.disableRipple();
        break;
      case "primary":
        this.shadowRoot.querySelector("ui-primary").innerHTML = i || "";
        break;
      case "secondary":
        this.shadowRoot.querySelector("ui-secondary").innerHTML = i || "";
        break;
    }
  }
};
o(k, "register", () => {
  H.register(), p.register(), customElements.get("ui-label") || customElements.define("ui-label", k);
}), o(k, "observedAttributes", ["ripple", "secondary", "primary"]);
let Gt = k;
const Ee = n`
    <style>
        * {
            box-sizing: border-box;
        }

        li {
            padding: var(--ui-spacing) calc(var(--ui-spacing) * 1.5);
            display: flex;
            flex-direction: row;
            flex-wrap: nowrap;
        }

        ::slotted(*) {
            width: 100%;
        }
    </style>

    <li>
        <slot></slot>
    </li>
`, W = class W extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Ee, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      /**
       * @returns {boolean}
       */
      getOpen() {
        return this.root.hasAttribute("open");
      },
      /**
       * @param {boolean} state
       */
      setOpen(t) {
        t ? this.root.setAttribute("open", "") : this.root.removeAttribute("open");
      }
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
o(W, "register", () => {
  customElements.get("ui-drawer-group-item") || customElements.define("ui-drawer-group-item", W);
});
let ut = W;
const Se = n`
    <style>
        * {
            box-sizing: border-box;
        }

        ul {
            list-style: none;
            padding: var(--ui-spacing);
            overflow: hidden;
        }

        ui-drawer-group-item:not(.visible) {
            display: none;
        }
    </style>

    <ul>
        <ui-drawer-group-item class="ui-drawer-group-title">
        </ui-drawer-group-item>

        <slot></slot>
    </ul>
`, y = class y extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Se, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      getTitle() {
        return this.root.getAttribute("title") || null;
      },
      /**
       * @param {string} value
       */
      setTitle(t) {
        let e = this.root.shadowRoot.querySelector(
          ".ui-drawer-group-title"
        );
        e.classList.add("visible"), e.innerHTML = `
                    <span
                        style="
                            font-size: 1.5rem;
                            font-weight: 600;
                            font-variation-settings: var(--ui-heading-fontVariation);
                        "
                    >
                        ${t}
                    </span>
                `;
      },
      removeTitle() {
        this.root.shadowRoot.querySelector(
          ".ui-drawer-group-title"
        ).classList.remove("visible");
      }
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "title":
        i === "" ? this.removeAttribute("title") : i !== null ? this.ui.setTitle(i) : this.ui.removeTitle();
        break;
    }
  }
};
o(y, "register", () => {
  ut.register(), H.register(), customElements.get("ui-drawer-group") || customElements.define("ui-drawer-group", y);
}), o(y, "observedAttributes", ["title"]);
let Bt = y;
const Ae = n`
    <style>
        :host {
            display: block;
            position: relative;
            width: 100%;
        }

        input {
            width: calc(100% - var(--ui-spacing) * 4);
            display: block;
            margin: 0;
            padding: var(--ui-spacing) calc(var(--ui-spacing) * 2);
            border: none !important;
            border-radius: inherit;
            outline: none !important;
            font-size: 0.9rem;
            font-family: var(--ui-fontFamily);
            font-variation-settings: var(--ui-input-fontVariation);
            accent-color: var(--ui-primary-bgColor);
            background-color: transparent !important;
        }

        .container {
            width: 100%;
            border: none;
            border-bottom: 1px solid var(--ui-borderColor);
            border-radius: 0;
            transition: border-color 0.25s linear;
        }

        .container:has(input:focus) {
            border-color: var(--ui-primary-bgColor);
        }

        :host([invalid]) .container {
            border-color: var(--ui-destructive-bgColor);
        }

        ::slotted([slot="title"]) {
            display: block;
            padding: 0 var(--ui-spacing);
            user-select: none;
            transform: translateY(calc(var(--ui-spacing) / 2));
        }
    </style>

    <div class="container">
        <slot name="title"></slot>
        <input />
    </div>
`, C = class C extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Ae, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      input: (() => {
        const t = this.shadowRoot.querySelector("input");
        return t.type = this.getAttribute("type") || "text", t.oninput = () => this.ui.events.dispatch("input", this.ui.getValue()), t.onchange = () => this.ui.events.dispatch("change", this.ui.getValue()), t;
      })(),
      /**
       * @type {Events<E>}
       */
      events: new h(),
      /**
       * @param {string | null} v
       */
      setTitle(t) {
        if (t === null) {
          this.root.removeAttribute("title");
          return;
        }
        this.root.setAttribute("title", t);
      },
      getTitle() {
        return this.root.getAttribute("title");
      },
      /**
       * @param {UIInputTypes | null} value
       */
      setType(t) {
        if (t === null) {
          this.root.removeAttribute("type");
          return;
        }
        this.root.setAttribute("type", t);
      },
      /**
       * @returns {UIInputTypes}
       */
      getType() {
        return this.root.getAttribute("type") || "text";
      },
      /**
       * @param {UIInputTypeValues[T] | null} value
       */
      setValue(t) {
        this.input.value = (t || "").toString();
      },
      /**
       * @returns {UIInputTypeValues[T]}
       */
      getValue() {
        const t = this.input.value;
        switch (this.getType()) {
          case "number":
            return t ? parseFloat(t) : NaN;
          default:
            return t;
        }
      },
      /**
       * @param {string | null} value
       */
      setPlaceholder(t) {
        if (t === null) {
          this.root.removeAttribute("placeholder");
          return;
        }
        this.root.setAttribute("placeholder", t);
      },
      /**
       * @returns {string}
       */
      getPlaceholder() {
        return this.root.getAttribute("placeholder");
      },
      /**
       * @param {boolean} state
       */
      setInvalid(t) {
        if (t === null || t === !1) {
          this.root.removeAttribute("invalid");
          return;
        }
        this.root.setAttribute("invalid", "");
      },
      /**
       * @returns {boolean}
       */
      getInvalid() {
        return this.root.hasAttribute("invalid");
      },
      /**
       * @param {UIInputTypeValues[T] | null} n
       */
      setMin(t) {
        if (t === null) {
          this.root.removeAttribute("min");
          return;
        }
        this.root.setAttribute("min", t.toString());
      },
      /**
       * @returns {UIInputTypeValues[T]}
       */
      getMin() {
        const t = this.root.getAttribute("min");
        switch (this.input.type) {
          case "number":
            return t ? parseFloat(t) : NaN;
          default:
            return t;
        }
      },
      /**
       * @param {UIInputTypeValues[T] | null} n
       */
      setMax(t) {
        t === null && this.root.removeAttribute("max"), this.root.setAttribute("max", t.toString());
      },
      /**
       * @returns {UIInputTypeValues[T]}
       */
      getMax() {
        const t = this.root.getAttribute("max");
        switch (this.input.type) {
          case "number":
            return t ? parseFloat(t) : NaN;
          default:
            return t;
        }
      }
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "title":
        let s = this.querySelector('[slot="title"]');
        if (i === null && s && (this.removeChild(s), s = null), i === null)
          return;
        s || (s = new p(), s.slot = "title", this.appendChild(s)), s.innerHTML = i;
        break;
      case "type":
        this.ui.input.type = i || "text";
        break;
      case "value":
        this.ui.setValue(i);
        break;
      case "placeholder":
        this.ui.input.placeholder = i || "";
        break;
      case "invalid":
        this.ui.input.ariaInvalid = i;
        break;
      case "min":
        this.ui.input.min = i || "";
        break;
      case "max":
        this.ui.input.max = i || "";
        break;
    }
  }
  /**
   * @param {FocusOptions | null} [options]
   */
  focus(t = null) {
    this.shadowRoot.querySelector("input").focus(t);
  }
  blur() {
    this.shadowRoot.querySelector("input").blur();
  }
};
o(C, "register", () => {
  p.register(), customElements.get("ui-input") || customElements.define("ui-input", C);
}), o(C, "observedAttributes", [
  "title",
  "type",
  "value",
  "placeholder",
  "invalid",
  "min",
  "max"
]);
let Ft = C;
const Re = n`
    <style>
        :host {
            display: none;
            align-items: center;

            padding: var(--ui-spacing);
            padding-right: 2rem;

            height: calc(1em * var(--ui-lineHeight) + var(--ui-spacing) * 2);

            white-space: nowrap;
            text-overflow: ellipsis;

            transition:
                background-color 0.25s linear,
                color 0.25s linear;

            overflow: hidden;
        }
    </style>

    <slot></slot>
`, I = class I extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Re, this.setAttribute("role", "button"), this.ui = {
      /** @private */
      root: this,
      getValue() {
        return this.root.getAttribute("value");
      },
      /**
       * @param {string | null} value
       */
      setValue(t) {
        if (t === null) {
          this.root.removeAttribute("value");
          return;
        }
        this.root.setAttribute("value", t);
      },
      getSelected() {
        return this.root.hasAttribute("selected");
      },
      /**
       * @param {boolean} state
       */
      setSelected(t) {
        if (!t) {
          this.root.removeAttribute("selected");
          return;
        }
        this.root.setAttribute("selected", "");
      }
    };
  }
};
o(I, "register", () => {
  customElements.get("ui-select-option") || customElements.define("ui-select-option", I);
});
let T = I;
const He = n`
    <style>
        * {
            box-sizing: border-box;
        }

        :host {
            --ui-bgColor: "transparent";
            --items-length: 0;

            position: relative !important;
            display: block !important;

            width: 100%;
            height: calc(1em * var(--ui-lineHeight) + var(--ui-spacing) * 2);
            transition: height 0.25s ease;

            background-color: var(--ui-bgColor);
            color: var(--ui-color);

            border: 1px solid var(--ui-borderColor);
            border-radius: var(--ui-radius);

            line-height: 1.15;

            overflow: hidden;

            font-size: 0.9rem;
            font-family: var(--ui-fontFamily);
            font-variation-settings: var(--ui-select-fontVariation);
        }

        .options {
            cursor: pointer;
            display: none;
            display: flex;
            flex-direction: column;
            min-height: 100%;
        }

        .icon {
            display: flex;
            justify-content: center;
            align-items: center;
            position: absolute;
            top: 0;
            right: 0;
            width: 2.5rem;
            height: 100%;
            color: var(--ui-primary-bgColor);
        }

        ::slotted(ui-select-option) {
            display: flex;
        }

        :host(.open) {
            height: calc(
                (1em * var(--ui-lineHeight) + var(--ui-spacing) * 2) *
                    var(--items-length)
            );
        }

        :host(.open) .options {
            display: block;
        }

        :host(.open) .icon {
            display: none;
        }

        :host(.open) ::slotted(ui-select-option[selected]) {
            background-color: var(--ui-primary-bgColor);
            color: var(--ui-primary-color);
        }

        :host(.open) ::slotted(ui-select-option:not([selected]):hover) {
            background-color: hsla(var(--ui-color-hsl), 0.1);
        }

        :host(:not(.open))
            .options:has(> ::slotted(ui-select-option[selected])) {
            display: block;
        }

        :host(:not(.open)) ::slotted(ui-select-option:not([selected])) {
            display: none;
        }
    </style>

    <div class="options">
        <div class="icon"><svg-chevron-down></svg-chevron-down></div>

        <slot></slot>
    </div>
`, U = class U extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = He, this.cleanup = new a(), this.ui = {
      /**
       *  @type {Events<UISelectEvents>}
       */
      events: new h()
    };
  }
  connectedCallback() {
    const t = this.shadowRoot.querySelector(".options"), e = async (s) => {
      (s.composedPath() || []).forEach((l) => {
        l instanceof T && ([...this.querySelectorAll("ui-select-option")].forEach(
          (c) => c.removeAttribute("selected")
        ), l.setAttribute("selected", ""), this.ui.events.dispatch("change", l));
      });
    }, i = (s) => {
      this.classList.toggle("open") ? (s.stopPropagation(), this.addEventListener("click", e)) : setTimeout(
        () => this.removeEventListener("click", e)
      );
    };
    t.addEventListener("click", i), this.cleanup.add(() => {
      this.removeEventListener("click", i), t.removeEventListener("click", i);
    }), this.style.setProperty(
      "--items-length",
      this.querySelectorAll("ui-select-option").length.toString()
    );
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
o(U, "register", () => {
  at.register(), T.register(), customElements.get("ui-select") || customElements.define("ui-select", U);
});
let zt = U;
const Te = n`
    <style>
        * {
            box-sizing: border-box;
        }

        :host {
            display: block;
            position: relative;
            width: 100%;
        }

        input {
            width: calc(100% - var(--ui-spacing) * 4);
            display: block;
            margin: 0;
            padding: var(--ui-spacing) calc(var(--ui-spacing) * 2);
            border: none !important;
            border-radius: inherit;
            outline: none !important;
            font-size: 0.9rem;
            font-family: var(--ui-fontFamily);
            font-variation-settings: var(--ui-input-fontVariation);
            accent-color: var(--ui-primary-bgColor);
            background-color: transparent !important;
        }

        .container {
            position: relative;
            width: 100%;
            border: none;
            border: 1px solid var(--ui-borderColor);
            border-radius: var(--ui-radius);
            transition: border-color 0.25s linear;
            background-color: var(--ui-backdrop-bgColor);
            -webkit-backdrop-filter: var(--ui-backdropFilter);
            backdrop-filter: var(--ui-backdropFilter);
        }

        .container:has(input:focus) {
            border-color: var(--ui-primary-bgColor);
        }

        :host([invalid]) .container {
            border-color: var(--ui-destructive-bgColor);
        }

        ::slotted([slot="title"]) {
            display: block;
            padding: 0 var(--ui-spacing);
            user-select: none;
            transform: translateY(calc(var(--ui-spacing) / 2));
        }

        ui-icon-button {
            position: absolute;
            top: 0;
            right: 0;
            height: 100%;
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }
    </style>

    <div class="container">
        <slot name="title"></slot>
        <input type="search" />
        <ui-icon-button ghost>
            <svg-search></svg-search>
        </ui-icon-button>
    </div>
`, L = class L extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Te, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      /**
       * @type {boolean}
       */
      useStorage: !1,
      /**
       * @type {string | null}
       */
      storagePrefix: null,
      submit: (() => {
        const t = this.shadowRoot.querySelector("ui-icon-button");
        return t.ui.events.on("click", () => {
          this.ui.events.dispatch("submit", this.ui.getValue());
        }), t;
      })(),
      input: (() => {
        const t = this.shadowRoot.querySelector("input");
        t.type = "text", t.onkeydown = async (i) => {
          this.ui.hasSubmit() && i.key === "Enter" && this.ui.submit.click();
        }, t.oninput = async () => {
          this.ui.useStorage && (e !== null && clearTimeout(e), e = setTimeout(() => {
            localStorage.setItem(
              (this.ui.storagePrefix || "") + this.ui.getKey(),
              t.value
            ), e = null;
          }, 250)), this.ui.events.dispatch("input", t.value);
        };
        let e = null;
        return t.onchange = async () => this.ui.events.dispatch("change", t.value), t;
      })(),
      /** @type {Events<E>} */
      events: new h(),
      /**
       *  @param {string | null} value
       */
      setKey(t) {
        if (t === null) {
          this.root.removeAttribute("key"), this.setValue("");
          return;
        }
        this.root.setAttribute("key", t), this.setValue(
          localStorage.getItem(this.storagePrefix + this.getKey())
        );
      },
      getKey() {
        return this.root.getAttribute("key") || "";
      },
      hasSubmit() {
        return !!this.submit.parentElement;
      },
      disableSubmit() {
        this.hasSubmit() && this.submit.parentElement.removeChild(this.submit);
      },
      enableSubmit() {
        if (!this.hasSubmit())
          return;
        this.root.shadowRoot.querySelector(".container").appendChild(this.submit);
      },
      /**
       * @param {string | null} value
       */
      setTitle(t) {
        t === null ? this.root.removeAttribute("title") : this.root.setAttribute("title", t);
      },
      getTitle() {
        return this.root.getAttribute("title");
      },
      /**
       * @param {string | null} value
       */
      setValue(t) {
        this.input.value = t || "";
      },
      getValue() {
        return this.input.value;
      },
      /**
       * @param {string | null} value
       */
      setPlaceholder(t) {
        if (t === null) {
          this.root.removeAttribute("placeholder");
          return;
        }
        this.root.setAttribute("placeholder", t);
      },
      /**
       * @returns {string}
       */
      getPlaceholder() {
        return this.root.getAttribute("placeholder");
      },
      /**
       * @param {boolean} state
       */
      setInvalid(t) {
        if (t === null || t === !1) {
          this.root.setAttribute("invalid", "");
          return;
        }
        this.root.removeAttribute("invalid");
      },
      /**
       * @returns {boolean}
       */
      getInvalid() {
        return this.root.hasAttribute("invalid");
      }
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "title":
        let s = this.querySelector('[slot="title"]');
        i === null && s && (this.removeChild(s), s = null), s || (s = new p(), s.slot = "title", this.appendChild(s)), s.innerHTML = i || "";
        break;
      case "value":
        this.ui.setValue(i);
        break;
      case "placeholder":
        this.ui.input.placeholder = i || "";
        break;
      case "invalid":
        this.ui.input.ariaInvalid = i !== null ? "" : null;
        break;
      case "no-submit":
        i !== null ? this.ui.disableSubmit() : this.ui.enableSubmit();
        break;
      case "use-storage":
        this.ui.useStorage = i !== null;
        break;
      case "storage-prefix":
        this.ui.storagePrefix = i;
        break;
    }
  }
  /**
   * @param {FocusOptions | null} [options]
   */
  focus(t = null) {
    this.shadowRoot.querySelector("input").focus(t);
  }
  blur() {
    this.shadowRoot.querySelector("input").blur();
  }
};
o(L, "register", () => {
  p.register(), R.register(), ct.register(), customElements.get("ui-search") || customElements.define("ui-search", L);
}), o(L, "observedAttributes", [
  "title",
  "value",
  "placeholder",
  "invalid",
  "no-submit",
  "use-storage",
  "storage-prefix"
]);
let qt = L;
const tt = class tt extends HTMLElement {
  constructor() {
    super(), this.ui = {
      /** @private */
      root: this,
      getName() {
        return this.root.getAttribute("name");
      },
      /**
       * @param {string | null} value
       */
      setName(t) {
        if (t === null) {
          this.root.removeAttribute("name");
          return;
        }
        this.root.setAttribute("name", t);
      },
      getHref() {
        return this.root.getAttribute("href");
      },
      /**
       * @param {string | null} value
       */
      setHref(t) {
        if (t === null) {
          this.root.removeAttribute("href");
          return;
        }
        this.root.setAttribute("href", t);
      },
      getFallback() {
        return this.root.hasAttribute("fallback");
      },
      /**
       * @param {boolean} state
       */
      setFallback(t) {
        if (!t) {
          this.root.removeAttribute("fallback");
          return;
        }
        this.root.setAttribute("fallback", "");
      }
    };
  }
};
o(tt, "register", () => {
  customElements.get("ui-lang-type") || customElements.define("ui-lang-type", tt);
});
let ht = tt;
const x = class x extends HTMLElement {
  constructor() {
    super(), this.ui = {
      /** @private */
      root: this,
      /**
       * @private
       * @type {Events<{ "change": UILangType}>}
       */
      events: new h(),
      /**
       * @type {{
       *  [key: string]: {
       *      [key: string]: string;
       *  };
       * }}
       */
      data: {},
      /**
       *@type {UILangType | null}
       */
      langType: null,
      getCurrent() {
        return this.root.getAttribute("current");
      },
      /**
       * @param {string | null} v
       */
      setCurrent(t) {
        if (t === null) {
          this.root.removeAttribute("current");
          return;
        }
        this.root.setAttribute("current", t);
      },
      /**
       * @returns {UILangType}
       */
      getFallbackElement() {
        return this.root.querySelector("ui-lang-type[fallback]");
      },
      /**
       * @param {UILangType} langType
       * @param {{
       *  [key: string]: {
       *      [key: string]: string;
       *  };
       * }} data
       */
      new(t, e) {
        this.langType = t, this.data = e, this.events.dispatch("change", this.langType);
      },
      /**
       * @param {string} group
       * @param {string} key
       */
      get(t, e) {
        var i, s;
        return ((s = (i = this.data) == null ? void 0 : i[t]) == null ? void 0 : s[e]) || null;
      },
      /**
       * @param {"change"} key
       * @param {(langType: UILangType | null) => void|Promise<void>} callback
       * @param {boolean} [trigger] - this will run the callback first
       * @returns {() => void} clean up function
       */
      on(t, e, i = !1) {
        if (typeof e != "function")
          throw "callback is not a function";
        return i && e(this.langType), this.events.on(t, e);
      }
    };
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "current":
        i !== null && this.loadLanguage(i);
        break;
    }
  }
  /**
   * @private
   * @param {string} name
   */
  async loadLanguage(t) {
    const e = this.querySelector(`ui-lang-type[name="${t}"]`) || this.ui.getFallbackElement();
    if (!e)
      return;
    if (!e.ui.getHref())
      throw "Missing href attribute!";
    const i = await fetch(e.ui.getHref());
    this.ui.new(e, await i.json());
  }
};
o(x, "register", () => {
  ht.register(), customElements.get("ui-lang") || customElements.define("ui-lang", x);
}), o(x, "observedAttributes", ["current"]);
let _t = x;
const Ve = n`
    <style>
        .background {
            z-index: 999;
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            background-color: var(--ui-backdrop-bgColor);
            -webkit-backdrop-filter: var(--ui-backdropFilter);
            backdrop-filter: var(--ui-backdropFilter);
        }

        .spinner {
            z-index: 1000;
            content: "";
            box-sizing: border-box;
            position: absolute;
            top: 50%;
            left: 50%;
            width: 2.5rem;
            height: 2.5rem;
            margin-top: -1.25rem;
            margin-left: -1.25rem;
            border-radius: 50%;
            border: 2px solid var(--ui-borderColor);
            border-top-color: var(--ui-primary-bgColor);
            animation: spinner 0.6s linear infinite;
        }

        @keyframes spinner {
            to {
                transform: rotate(360deg);
            }
        }
    </style>

    <div class="background"></div>
    <div class="spinner"></div>
`, et = class et extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Ve, this.cleanup = new a(), this.ui = {};
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
o(et, "register", () => {
  customElements.get("ui-spinner") || customElements.define("ui-spinner", et);
});
let Ot = et;
const Ze = n`
    <style>
        :host {
            display: block !important;
            position: absolute !important;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            animation: fade-in 0.5s;
            transition: opacity 0.5s ease;
        }

        :host(:last-child) {
            opacity: 1;
        }

        @keyframes fade-in {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }
    </style>

    <slot></slot>
`, it = class it extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = Ze, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      getName() {
        return this.root.getAttribute("name");
      },
      /**
       * @param {string | null} value
       */
      setName(t) {
        t === null && this.root.removeAttribute("name"), this.root.setAttribute("name", t);
      }
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
};
o(it, "register", () => {
  customElements.get("ui-stack-layout-page") || customElements.define("ui-stack-layout-page", it);
});
let dt = it;
const $e = n`
    <style>
        :host {
            display: block !important;
            position: relative !important;
            width: 100%;
            height: 100%;
        }
    </style>

    <slot></slot>
`, M = class M extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" }), this.shadowRoot.innerHTML = $e, this.cleanup = new a(), this.ui = {
      /** @private */
      root: this,
      /**
       * @private
       * @type {Pages}
       */
      pages: {},
      /**
       * @private
       * @type {UIStackLayoutPage[]}
       */
      stack: [],
      /**
       * @type {((ev: PopStateEvent) => void|Promise<void>) | null}
       */
      onpopstate: null,
      /**
       * @type {Events<{ "change": { oldPage: UIStackLayoutPage | null, newPage: UIStackLayoutPage | null } }>}
       */
      events: new h(),
      lock: !1,
      enableHistory() {
        this.onpopstate === null && (this.onpopstate = async () => {
          this._goBack();
        }, window.addEventListener("popstate", this.onpopstate));
      },
      disableHistory() {
        this.onpopstate === null && window.removeEventListener("popstate", this.onpopstate);
      },
      usesHistory() {
        return this.onpopstate !== null;
      },
      /**
       * @param {string} name
       * @param {() => (UIStackLayoutPage)} cb
       */
      registerPage(t, e) {
        this.pages[t] = e;
      },
      /**
       * @param {string} name
       */
      unregisterPage(t) {
        delete this.pages[t];
      },
      clearStack() {
        for (; this.stackSize() > 0; )
          this.root.removeChild(this.stack.pop());
      },
      stackSize() {
        return this.stack.length;
      },
      goBack() {
        if (!(!this.stack.length || this.lock)) {
          if (this.onpopstate !== null) {
            history.back();
            return;
          }
          this._goBack();
        }
      },
      /**
       * @private
       */
      _goBack() {
        const t = this.root.removeChild(this.stack.pop());
        this.stack.length > 0 && (this.stack[this.stack.length - 1].parentElement || this.root.appendChild(
          this.stack[this.stack.length - 1]
        )), this.dispatchChangeEvent(t);
      },
      /**
       * @param {string} name
       * @param {((page: UIStackLayoutPage) => void|Promise<void>) | null} [cb]
       * @param {boolean} [keepOldPage]
       */
      setPage(t, e = null, i = !1) {
        if (this.lock)
          return;
        const s = this.pages[t]();
        this.stack.push(this.root.appendChild(s)), typeof e == "function" && setTimeout(() => e(s));
        let l = null;
        this.stack.length > 1 && !i && (l = this.stack[this.stack.length - 2], l.parentElement.removeChild(l)), this.dispatchChangeEvent(l), this.onpopstate !== null && history.pushState(null, document.title, location.href);
      },
      /**
       * @param {UIStackLayoutPage} oldChild
       */
      async dispatchChangeEvent(t) {
        this.events.dispatch("change", {
          newPage: this.stack[this.stack.length - 1] || null,
          oldPage: t || this.stack[this.stack.length - 2] || null
        });
      }
    };
  }
  connectedCallback() {
  }
  disconnectedCallback() {
    this.cleanup.run();
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "use-history":
        i !== null ? this.ui.enableHistory() : this.ui.disableHistory();
        break;
    }
  }
};
o(M, "register", () => {
  dt.register(), customElements.get("ui-stack-layout") || customElements.define("ui-stack-layout", M);
}), o(M, "observedAttributes", ["use-history"]);
let Pt = M;
const E = class E extends HTMLElement {
  constructor() {
    super(), this.ui = {
      /** @private */
      root: this,
      /**
       * @type {boolean}
       */
      useStorage: !1,
      /**
       * @type {string | null}
       */
      storagePrefix: null,
      /**
       * @type {any}
       */
      stores: {},
      /**
       * @type {Events<T>}
       */
      events: new h(),
      /**
       * @template {keyof T} K
       * @param {K} key
       * @returns {T[K]}
       */
      get(t) {
        return this.stores[t];
      },
      /**
       * @template {keyof T} K
       * @param {K} key
       * @param {T[K]} data
       * @param {boolean} [useDataAsFallback] Use data as fallback, if nothing found in the browsers `localStorage`
       * `this.enableLocalStorage` flag needs to be set to `true` for this to work
       */
      set(t, e, i = !1) {
        if (i && this.storagePrefix) {
          const s = JSON.parse(
            localStorage.getItem(
              (this.storagePrefix || "") + t.toString()
            ) || "null"
          );
          this.stores[t] = s ?? e;
        } else
          this.stores[t] = e;
        this.useStorage && localStorage.setItem(
          (this.storagePrefix || "") + t.toString(),
          JSON.stringify(this.stores[t])
        ), this.events.dispatch(t, this.stores[t]);
      },
      /**
       * @template {keyof T} K
       * @param {K} key
       * @param {(data: T[K]) => any} callback
       */
      update(t, e) {
        if (typeof e != "function")
          throw "callback is not a function";
        this.set(t, e(this.stores[t]));
      },
      /**
       * @template {keyof T} K
       * @param {K} key
       * @param {(data: T[K]) => void|Promise<void>} callback
       * @param {boolean} [trigger] - this will run the callback first
       * @returns {() => void} clean up function
       */
      on(t, e, i = !1) {
        if (typeof e != "function")
          throw "callback is not a function";
        return i && e(this.get(t)), this.events.on(t, e);
      }
    };
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "use-storage":
        this.ui.useStorage = i !== null;
        break;
      case "storage-prefix":
        this.ui.storagePrefix = i;
        break;
    }
  }
};
o(E, "register", () => {
  customElements.get("ui-store") || customElements.define("ui-store", E);
}), o(E, "observedAttributes", ["use-storage", "storage-prefix"]);
let Nt = E;
const S = class S extends HTMLElement {
  constructor() {
    super(), this.ui = {
      /**
       * @private
       * @type {MediaQueryList | null}
       */
      media: null,
      /**
       * @type {{ name: string; href: string } | null}
       */
      currentTheme: null,
      /**
       * @type {{ [key: string]: string }}
       */
      themes: {},
      /**
       * @param {HTMLElement} [element]
       */
      getMode(t = document.body) {
        return t.getAttribute("data-theme");
      },
      /**
       * @param {UIThemeHandlerMode} mode
       * @param {HTMLElement} [element]
       */
      setMode(t, e = document.body) {
        switch (t) {
          case "dark":
            e.setAttribute("data-theme", t);
            break;
          case "light":
            e.setAttribute("data-theme", t);
            break;
          default:
            e.removeAttribute("data-theme");
        }
      },
      /**
       * @private
       * @param {MediaQueryListEvent | MediaQueryList} ev
       */
      mediaChangeHandler: (t) => {
        t.matches ? document.body.setAttribute("data-theme", "dark") : document.body.setAttribute("data-theme", "light");
      },
      getAuto() {
        return !!this.media;
      },
      /**
       * @param {boolean} state
       * @param {HTMLElement} [element]
       */
      setAuto(t, e = document.body) {
        if (!t) {
          if (!this.media)
            return;
          this.media.removeEventListener(
            "change",
            this.mediaChangeHandler
          ), this.media = null;
          return;
        }
        if (this.setMode(null, e), this.media) {
          this.mediaChangeHandler(this.media);
          return;
        }
        this.media = window.matchMedia("(prefers-color-scheme: dark)"), this.media.addEventListener("change", this.mediaChangeHandler), this.mediaChangeHandler(this.media);
      },
      /**
       * @param {string} name
       * @param {string} href
       */
      addTheme(t, e) {
        this.themes[t] = e;
      },
      /**
       * @param {string} name
       */
      setTheme(t) {
        var i;
        if (!this.themes[t])
          throw `theme "${t}" is missing in this.themes`;
        if (((i = this.currentTheme) == null ? void 0 : i.name) == t)
          return;
        {
          const s = document.getElementById("theme");
          s && (document.head.removeChild(s), this.currentTheme = null);
        }
        const e = document.createElement("link");
        e.id = "theme", e.rel = "stylesheet", e.href = this.themes[t], document.head.appendChild(e), this.currentTheme = { name: t, href: this.themes[t] };
      }
    };
  }
  /**
   * @param {string} name
   * @param {string | null} _oldValue
   * @param {string | null} newValue
   */
  attributeChangedCallback(t, e, i) {
    switch (t) {
      case "auto":
        this.ui.setAuto(i !== null);
        break;
      case "mode":
        this.ui.setMode(i);
        break;
    }
  }
};
o(S, "register", () => {
  customElements.get("ui-theme-handler") || customElements.define("ui-theme-handler", S);
}), o(S, "observedAttributes", ["auto", "mode"]);
let Dt = S;
export {
  at as SvgChevronDown,
  xt as SvgChevronLeft,
  lt as SvgClose,
  St as SvgDocumentNew,
  Mt as SvgDownload,
  Ht as SvgMenu,
  Et as SvgPen,
  Lt as SvgPlus,
  ct as SvgSearch,
  Rt as SvgSettings,
  Tt as SvgShare,
  Vt as SvgToday,
  At as SvgTrash,
  wt as UIAppBar,
  kt as UIAppBarItem,
  yt as UIButton,
  Ct as UIContainer,
  Zt as UIDialog,
  jt as UIDrawer,
  Bt as UIDrawerGroup,
  ut as UIDrawerGroupItem,
  vt as UIFlexGrid,
  bt as UIFlexGridItem,
  A as UIFlexGridRow,
  R as UIIconButton,
  Ft as UIInput,
  Gt as UILabel,
  _t as UILang,
  ht as UILangType,
  H as UIPrimary,
  qt as UISearch,
  p as UISecondary,
  zt as UISelect,
  T as UISelectOption,
  Ot as UISpinner,
  Pt as UIStackLayout,
  dt as UIStackLayoutPage,
  Nt as UIStore,
  Dt as UIThemeHandler,
  Ge as js
};
