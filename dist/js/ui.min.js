let at = null;
function Zt() {
  return at === null && (at = Array.from(document.styleSheets).map((s) => {
    const t = new CSSStyleSheet(), e = Array.from(s.cssRules).map((i) => i.cssText).join(" ");
    return t.replaceSync(e), t;
  })), at;
}
function Ht(s) {
  s.adoptedStyleSheets.push(...Zt());
}
class bt {
  constructor() {
    this.listeners = {};
  }
  addListener(t, e) {
    return this.listeners[t] || (this.listeners[t] = []), this.listeners[t].push(e), () => this.removeListener(t, e);
  }
  removeListener(t, e) {
    this.listeners[t] && (this.listeners[t] = this.listeners[t].filter(
      (i) => i !== e
    ));
  }
  dispatch(t, e) {
    this.listeners[t] && this.listeners[t].forEach((i) => i(e));
  }
}
class cr {
  constructor() {
    this.callbacks = [];
  }
  add(...t) {
    this.callbacks.push(...t);
  }
  run() {
    this.callbacks.filter((t) => (t(), !1));
  }
}
const Kt = {
  onDragStart: null,
  onDragging: null,
  onDragEnd: null
};
function Qt(s, t, e) {
  e = { ...Kt, ...e };
  const i = [...s.children].indexOf(t);
  return t.draggable = !0, t.ondragstart = (r) => {
    r.dataTransfer && (r.dataTransfer.effectAllowed = "move", r.dataTransfer.dropEffect = "move"), s.classList.add("ui-dragging"), e.onDragStart && e.onDragStart(i);
  }, t.ondragover = (r) => (r.preventDefault(), !1), t.ondragenter = (r) => {
    r.preventDefault(), [...s.children].forEach((o, n) => {
      if (n === i) {
        o.style.background = "var(--ui-primary)", o.style.color = "var(--ui-primary-text)";
        return;
      }
      o.style.background = "inherit", o.style.color = "inherit";
    }), e.onDragging && e.onDragging(i);
  }, t.ondrop = (r) => {
    r.preventDefault(), r.dataTransfer && (r.dataTransfer.dropEffect = "move"), s.classList.remove("ui-dragging"), e.onDragEnd && e.onDragEnd(i), [...s.children].forEach((o) => {
      o.style.background = "inherit", o.style.color = "inherit";
    });
  }, () => {
    t.draggable = !1, t.ondragstart = null, t.ondragover = null, t.ondragenter = null, t.ondrop = null;
  };
}
const te = {
  onDragStart: null,
  onDragEnd: null
};
function ee(s, t) {
  t = { ...te, ...t };
  let e = null, i = null, r = null, o = !1, n = "", h = "";
  const l = (a) => {
    const v = a.currentTarget;
    !e && Array.from(v.classList).includes("draggable") && (i = (/* @__PURE__ */ new Date()).getTime(), e = v, r && clearTimeout(r), r = setTimeout(() => {
      e && (n = e.style.color, h = e.style.backgroundColor, e.style.color = "var(--ui-primary-text)", e.style.backgroundColor = "var(--ui-primary)", s.classList.add("ui-dragging"), o = !0, t != null && t.onDragStart && t.onDragStart());
    }, 200));
  }, p = (a) => {
    if (!i || !e) return;
    if (!o && (/* @__PURE__ */ new Date()).getTime() - i < 200) {
      d();
      return;
    }
    a.preventDefault(), o || (o = !0, t != null && t.onDragStart && t.onDragStart());
    let v;
    if (a instanceof TouchEvent) {
      const $ = a.targetTouches[0];
      v = {
        clientX: $.clientX,
        clientY: $.clientY
      };
    } else
      v = {
        clientX: a.clientX,
        clientY: a.clientY
      };
    let f = document.elementFromPoint(v.clientX, v.clientY);
    if (f) {
      for (; !f.classList.contains("draggable") && f.parentElement; )
        f = f.parentElement;
      f.classList.contains("draggable") && ((() => {
        let K = e == null ? void 0 : e.previousElementSibling;
        for (; K; ) {
          if (K === f)
            return !0;
          K = K.previousElementSibling;
        }
        return !1;
      })() ? s.insertBefore(e, f) : s.insertBefore(e, f.nextElementSibling));
    }
  }, d = () => {
    r !== null && (clearTimeout(r), r = null), e && (e.style.color = n, e.style.backgroundColor = h, e = null), i = null, s.classList.remove("ui-dragging"), o && (o = !1, t != null && t.onDragEnd && t.onDragEnd());
  };
  return [...s.children].forEach((a) => {
    a.classList.add("draggable"), a.onmousedown = l, a.ontouchstart = l, a.onmousemove = p, a.ontouchmove = p, s.onmouseleave = a.onmouseup = d, a.ontouchend = d;
  }), () => {
    [...s.children].forEach((a) => {
      a.classList.remove("draggable"), a.onmousedown = null, a.ontouchstart = null, a.onmousemove = null, a.ontouchmove = null, s.onmouseleave = a.onmouseup = null, a.ontouchend = null;
    });
  };
}
const hr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createMobile: ee,
  createNative: Qt
}, Symbol.toStringTag, { value: "Module" })), zt = {
  color: "var(--ui-ripple, currentColor)",
  opacity: "var(--ui-ripple-opacity, 0.2)",
  centered: !1,
  spreadDuration: ".4s",
  spreadTiming: "linear",
  clearDuration: "1s",
  clearTiming: "ease-in-out",
  usePointer: !1
};
function re(s, t) {
  t = { ...zt, ...t || {} };
  let e = null;
  const i = (h) => {
    e = dt(h, t), s.addEventListener("pointermove", o);
  }, r = () => {
    s.removeEventListener("pointermove", o), ft(e), e = null;
  }, o = () => r(), n = (h) => {
    e = dt(h, t), ft(e), e = null;
  };
  return s.classList.add("ripple-container"), s.style.overflow = "hidden", t.usePointer ? (s.addEventListener("pointerdown", i), s.addEventListener("pointerup", r), s.addEventListener("pointerleave", r)) : s.addEventListener("click", n), () => {
    if (s.classList.remove("ripple-container"), t.usePointer) {
      s.removeEventListener("pointerdown", i), s.removeEventListener("pointerup", r), s.removeEventListener("pointerleave", r), s.removeEventListener("pointermove", o);
      return;
    }
    s.removeEventListener("click", n);
  };
}
function dt(s, t) {
  const e = document.createElement("div"), i = s.currentTarget;
  i.appendChild(e), e.classList.add("ripple"), e.style.position = "absolute", e.style.color = "inherit", e.style.borderRadius = "50%", e.style.pointerEvents = "none", e.style.width = "100px", e.style.height = "100px", e.style.marginTop = "-50px", e.style.marginLeft = "-50px", e.style.opacity = `${t.opacity}`, e.style.backgroundColor = `${t.color}`, e.style.transform = "scale(0) translate(0, 0)", e.style.transition = `transform ${t.spreadDuration} ${t.spreadTiming} 0s,opacity ${t.clearDuration} ${t.clearTiming} 0s`;
  const r = i.getBoundingClientRect();
  t.centered ? (e.style.top = `${r.height / 2}px`, e.style.left = `${r.width / 2}px`) : (e.style.top = `${s.clientY - r.top}px`, e.style.left = `${s.clientX - r.left}px`);
  const o = Math.max(r.width, r.height) * 0.02;
  return e.style.transform = `scale(${o}) translate(0, 0)`, e;
}
function ft(s) {
  s && (s.addEventListener("transitionend", (t) => {
    t.propertyName === "opacity" && s.remove();
  }), s.style.opacity = "0");
}
const pr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  create: re,
  defaultOptions: zt,
  start: dt,
  stop: ft
}, Symbol.toStringTag, { value: "Module" })), ur = String.raw, dr = String.raw;
function fr() {
  return /(android)/i.test(navigator.userAgent);
}
function gr(s) {
  return Object.entries(s).map(([t, e]) => `${t.replace(/[A-Z]/g, (i) => `-${i.toLowerCase()}`)}:${e}`).join(";") + ";";
}
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Q = globalThis, mt = Q.ShadowRoot && (Q.ShadyCSS === void 0 || Q.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, _t = Symbol(), Ct = /* @__PURE__ */ new WeakMap();
let Ft = class {
  constructor(t, e, i) {
    if (this._$cssResult$ = !0, i !== _t) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (mt && t === void 0) {
      const i = e !== void 0 && e.length === 1;
      i && (t = Ct.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), i && Ct.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
const se = (s) => new Ft(typeof s == "string" ? s : s + "", void 0, _t), y = (s, ...t) => {
  const e = s.length === 1 ? s[0] : t.reduce((i, r, o) => i + ((n) => {
    if (n._$cssResult$ === !0) return n.cssText;
    if (typeof n == "number") return n;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + n + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(r) + s[o + 1], s[0]);
  return new Ft(e, s, _t);
}, ie = (s, t) => {
  if (mt) s.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
  else for (const e of t) {
    const i = document.createElement("style"), r = Q.litNonce;
    r !== void 0 && i.setAttribute("nonce", r), i.textContent = e.cssText, s.appendChild(i);
  }
}, Ot = mt ? (s) => s : (s) => s instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const i of t.cssRules) e += i.cssText;
  return se(e);
})(s) : s;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: oe, defineProperty: ne, getOwnPropertyDescriptor: ae, getOwnPropertyNames: le, getOwnPropertySymbols: ce, getPrototypeOf: he } = Object, x = globalThis, Ut = x.trustedTypes, pe = Ut ? Ut.emptyScript : "", lt = x.reactiveElementPolyfillSupport, R = (s, t) => s, tt = { toAttribute(s, t) {
  switch (t) {
    case Boolean:
      s = s ? pe : null;
      break;
    case Object:
    case Array:
      s = s == null ? s : JSON.stringify(s);
  }
  return s;
}, fromAttribute(s, t) {
  let e = s;
  switch (t) {
    case Boolean:
      e = s !== null;
      break;
    case Number:
      e = s === null ? null : Number(s);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(s);
      } catch {
        e = null;
      }
  }
  return e;
} }, $t = (s, t) => !oe(s, t), Dt = { attribute: !0, type: String, converter: tt, reflect: !1, hasChanged: $t };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), x.litPropertyMetadata ?? (x.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
class j extends HTMLElement {
  static addInitializer(t) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, e = Dt) {
    if (e.state && (e.attribute = !1), this._$Ei(), this.elementProperties.set(t, e), !e.noAccessor) {
      const i = Symbol(), r = this.getPropertyDescriptor(t, i, e);
      r !== void 0 && ne(this.prototype, t, r);
    }
  }
  static getPropertyDescriptor(t, e, i) {
    const { get: r, set: o } = ae(this.prototype, t) ?? { get() {
      return this[e];
    }, set(n) {
      this[e] = n;
    } };
    return { get() {
      return r == null ? void 0 : r.call(this);
    }, set(n) {
      const h = r == null ? void 0 : r.call(this);
      o.call(this, n), this.requestUpdate(t, h, i);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? Dt;
  }
  static _$Ei() {
    if (this.hasOwnProperty(R("elementProperties"))) return;
    const t = he(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(R("finalized"))) return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(R("properties"))) {
      const e = this.properties, i = [...le(e), ...ce(e)];
      for (const r of i) this.createProperty(r, e[r]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const e = litPropertyMetadata.get(t);
      if (e !== void 0) for (const [i, r] of e) this.elementProperties.set(i, r);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, i] of this.elementProperties) {
      const r = this._$Eu(e, i);
      r !== void 0 && this._$Eh.set(r, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const i = new Set(t.flat(1 / 0).reverse());
      for (const r of i) e.unshift(Ot(r));
    } else t !== void 0 && e.push(Ot(t));
    return e;
  }
  static _$Eu(t, e) {
    const i = e.attribute;
    return i === !1 ? void 0 : typeof i == "string" ? i : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var t;
    this._$ES = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (t = this.constructor.l) == null || t.forEach((e) => e(this));
  }
  addController(t) {
    var e;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t), this.renderRoot !== void 0 && this.isConnected && ((e = t.hostConnected) == null || e.call(t));
  }
  removeController(t) {
    var e;
    (e = this._$EO) == null || e.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const i of e.keys()) this.hasOwnProperty(i) && (t.set(i, this[i]), delete this[i]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return ie(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    var t;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (t = this._$EO) == null || t.forEach((e) => {
      var i;
      return (i = e.hostConnected) == null ? void 0 : i.call(e);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$EO) == null || t.forEach((e) => {
      var i;
      return (i = e.hostDisconnected) == null ? void 0 : i.call(e);
    });
  }
  attributeChangedCallback(t, e, i) {
    this._$AK(t, i);
  }
  _$EC(t, e) {
    var o;
    const i = this.constructor.elementProperties.get(t), r = this.constructor._$Eu(t, i);
    if (r !== void 0 && i.reflect === !0) {
      const n = (((o = i.converter) == null ? void 0 : o.toAttribute) !== void 0 ? i.converter : tt).toAttribute(e, i.type);
      this._$Em = t, n == null ? this.removeAttribute(r) : this.setAttribute(r, n), this._$Em = null;
    }
  }
  _$AK(t, e) {
    var o;
    const i = this.constructor, r = i._$Eh.get(t);
    if (r !== void 0 && this._$Em !== r) {
      const n = i.getPropertyOptions(r), h = typeof n.converter == "function" ? { fromAttribute: n.converter } : ((o = n.converter) == null ? void 0 : o.fromAttribute) !== void 0 ? n.converter : tt;
      this._$Em = r, this[r] = h.fromAttribute(e, n.type), this._$Em = null;
    }
  }
  requestUpdate(t, e, i) {
    if (t !== void 0) {
      if (i ?? (i = this.constructor.getPropertyOptions(t)), !(i.hasChanged ?? $t)(this[t], e)) return;
      this.P(t, e, i);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET());
  }
  P(t, e, i) {
    this._$AL.has(t) || this._$AL.set(t, e), i.reflect === !0 && this._$Em !== t && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(t);
  }
  async _$ET() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var i;
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [o, n] of this._$Ep) this[o] = n;
        this._$Ep = void 0;
      }
      const r = this.constructor.elementProperties;
      if (r.size > 0) for (const [o, n] of r) n.wrapped !== !0 || this._$AL.has(o) || this[o] === void 0 || this.P(o, this[o], n);
    }
    let t = !1;
    const e = this._$AL;
    try {
      t = this.shouldUpdate(e), t ? (this.willUpdate(e), (i = this._$EO) == null || i.forEach((r) => {
        var o;
        return (o = r.hostUpdate) == null ? void 0 : o.call(r);
      }), this.update(e)) : this._$EU();
    } catch (r) {
      throw t = !1, this._$EU(), r;
    }
    t && this._$AE(e);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var e;
    (e = this._$EO) == null || e.forEach((i) => {
      var r;
      return (r = i.hostUpdated) == null ? void 0 : r.call(i);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return !0;
  }
  update(t) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((e) => this._$EC(e, this[e]))), this._$EU();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
}
j.elementStyles = [], j.shadowRootOptions = { mode: "open" }, j[R("elementProperties")] = /* @__PURE__ */ new Map(), j[R("finalized")] = /* @__PURE__ */ new Map(), lt == null || lt({ ReactiveElement: j }), (x.reactiveElementVersions ?? (x.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const B = globalThis, et = B.trustedTypes, jt = et ? et.createPolicy("lit-html", { createHTML: (s) => s }) : void 0, Gt = "$lit$", w = `lit$${Math.random().toFixed(9).slice(2)}$`, qt = "?" + w, ue = `<${qt}>`, A = document, N = () => A.createComment(""), M = (s) => s === null || typeof s != "object" && typeof s != "function", wt = Array.isArray, de = (s) => wt(s) || typeof (s == null ? void 0 : s[Symbol.iterator]) == "function", ct = `[ 	
\f\r]`, k = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, It = /-->/g, Tt = />/g, P = RegExp(`>|${ct}(?:([^\\s"'>=/]+)(${ct}*=${ct}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), Lt = /'/g, kt = /"/g, Vt = /^(?:script|style|textarea|title)$/i, fe = (s) => (t, ...e) => ({ _$litType$: s, strings: t, values: e }), m = fe(1), I = Symbol.for("lit-noChange"), g = Symbol.for("lit-nothing"), Rt = /* @__PURE__ */ new WeakMap(), S = A.createTreeWalker(A, 129);
function Wt(s, t) {
  if (!wt(s) || !s.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return jt !== void 0 ? jt.createHTML(t) : t;
}
const ge = (s, t) => {
  const e = s.length - 1, i = [];
  let r, o = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", n = k;
  for (let h = 0; h < e; h++) {
    const l = s[h];
    let p, d, a = -1, v = 0;
    for (; v < l.length && (n.lastIndex = v, d = n.exec(l), d !== null); ) v = n.lastIndex, n === k ? d[1] === "!--" ? n = It : d[1] !== void 0 ? n = Tt : d[2] !== void 0 ? (Vt.test(d[2]) && (r = RegExp("</" + d[2], "g")), n = P) : d[3] !== void 0 && (n = P) : n === P ? d[0] === ">" ? (n = r ?? k, a = -1) : d[1] === void 0 ? a = -2 : (a = n.lastIndex - d[2].length, p = d[1], n = d[3] === void 0 ? P : d[3] === '"' ? kt : Lt) : n === kt || n === Lt ? n = P : n === It || n === Tt ? n = k : (n = P, r = void 0);
    const f = n === P && s[h + 1].startsWith("/>") ? " " : "";
    o += n === k ? l + ue : a >= 0 ? (i.push(p), l.slice(0, a) + Gt + l.slice(a) + w + f) : l + w + (a === -2 ? h : f);
  }
  return [Wt(s, o + (s[e] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), i];
};
class H {
  constructor({ strings: t, _$litType$: e }, i) {
    let r;
    this.parts = [];
    let o = 0, n = 0;
    const h = t.length - 1, l = this.parts, [p, d] = ge(t, e);
    if (this.el = H.createElement(p, i), S.currentNode = this.el.content, e === 2 || e === 3) {
      const a = this.el.content.firstChild;
      a.replaceWith(...a.childNodes);
    }
    for (; (r = S.nextNode()) !== null && l.length < h; ) {
      if (r.nodeType === 1) {
        if (r.hasAttributes()) for (const a of r.getAttributeNames()) if (a.endsWith(Gt)) {
          const v = d[n++], f = r.getAttribute(a).split(w), $ = /([.?@])?(.*)/.exec(v);
          l.push({ type: 1, index: o, name: $[2], strings: f, ctor: $[1] === "." ? ye : $[1] === "?" ? be : $[1] === "@" ? me : ot }), r.removeAttribute(a);
        } else a.startsWith(w) && (l.push({ type: 6, index: o }), r.removeAttribute(a));
        if (Vt.test(r.tagName)) {
          const a = r.textContent.split(w), v = a.length - 1;
          if (v > 0) {
            r.textContent = et ? et.emptyScript : "";
            for (let f = 0; f < v; f++) r.append(a[f], N()), S.nextNode(), l.push({ type: 2, index: ++o });
            r.append(a[v], N());
          }
        }
      } else if (r.nodeType === 8) if (r.data === qt) l.push({ type: 2, index: o });
      else {
        let a = -1;
        for (; (a = r.data.indexOf(w, a + 1)) !== -1; ) l.push({ type: 7, index: o }), a += w.length - 1;
      }
      o++;
    }
  }
  static createElement(t, e) {
    const i = A.createElement("template");
    return i.innerHTML = t, i;
  }
}
function T(s, t, e = s, i) {
  var n, h;
  if (t === I) return t;
  let r = i !== void 0 ? (n = e._$Co) == null ? void 0 : n[i] : e._$Cl;
  const o = M(t) ? void 0 : t._$litDirective$;
  return (r == null ? void 0 : r.constructor) !== o && ((h = r == null ? void 0 : r._$AO) == null || h.call(r, !1), o === void 0 ? r = void 0 : (r = new o(s), r._$AT(s, e, i)), i !== void 0 ? (e._$Co ?? (e._$Co = []))[i] = r : e._$Cl = r), r !== void 0 && (t = T(s, r._$AS(s, t.values), r, i)), t;
}
class ve {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: e }, parts: i } = this._$AD, r = ((t == null ? void 0 : t.creationScope) ?? A).importNode(e, !0);
    S.currentNode = r;
    let o = S.nextNode(), n = 0, h = 0, l = i[0];
    for (; l !== void 0; ) {
      if (n === l.index) {
        let p;
        l.type === 2 ? p = new W(o, o.nextSibling, this, t) : l.type === 1 ? p = new l.ctor(o, l.name, l.strings, this, t) : l.type === 6 && (p = new _e(o, this, t)), this._$AV.push(p), l = i[++h];
      }
      n !== (l == null ? void 0 : l.index) && (o = S.nextNode(), n++);
    }
    return S.currentNode = A, r;
  }
  p(t) {
    let e = 0;
    for (const i of this._$AV) i !== void 0 && (i.strings !== void 0 ? (i._$AI(t, i, e), e += i.strings.length - 2) : i._$AI(t[e])), e++;
  }
}
class W {
  get _$AU() {
    var t;
    return ((t = this._$AM) == null ? void 0 : t._$AU) ?? this._$Cv;
  }
  constructor(t, e, i, r) {
    this.type = 2, this._$AH = g, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = i, this.options = r, this._$Cv = (r == null ? void 0 : r.isConnected) ?? !0;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = T(this, t, e), M(t) ? t === g || t == null || t === "" ? (this._$AH !== g && this._$AR(), this._$AH = g) : t !== this._$AH && t !== I && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : de(t) ? this.k(t) : this._(t);
  }
  O(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
  }
  _(t) {
    this._$AH !== g && M(this._$AH) ? this._$AA.nextSibling.data = t : this.T(A.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    var o;
    const { values: e, _$litType$: i } = t, r = typeof i == "number" ? this._$AC(t) : (i.el === void 0 && (i.el = H.createElement(Wt(i.h, i.h[0]), this.options)), i);
    if (((o = this._$AH) == null ? void 0 : o._$AD) === r) this._$AH.p(e);
    else {
      const n = new ve(r, this), h = n.u(this.options);
      n.p(e), this.T(h), this._$AH = n;
    }
  }
  _$AC(t) {
    let e = Rt.get(t.strings);
    return e === void 0 && Rt.set(t.strings, e = new H(t)), e;
  }
  k(t) {
    wt(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let i, r = 0;
    for (const o of t) r === e.length ? e.push(i = new W(this.O(N()), this.O(N()), this, this.options)) : i = e[r], i._$AI(o), r++;
    r < e.length && (this._$AR(i && i._$AB.nextSibling, r), e.length = r);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var i;
    for ((i = this._$AP) == null ? void 0 : i.call(this, !1, !0, e); t && t !== this._$AB; ) {
      const r = t.nextSibling;
      t.remove(), t = r;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this._$Cv = t, (e = this._$AP) == null || e.call(this, t));
  }
}
class ot {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, i, r, o) {
    this.type = 1, this._$AH = g, this._$AN = void 0, this.element = t, this.name = e, this._$AM = r, this.options = o, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = g;
  }
  _$AI(t, e = this, i, r) {
    const o = this.strings;
    let n = !1;
    if (o === void 0) t = T(this, t, e, 0), n = !M(t) || t !== this._$AH && t !== I, n && (this._$AH = t);
    else {
      const h = t;
      let l, p;
      for (t = o[0], l = 0; l < o.length - 1; l++) p = T(this, h[i + l], e, l), p === I && (p = this._$AH[l]), n || (n = !M(p) || p !== this._$AH[l]), p === g ? t = g : t !== g && (t += (p ?? "") + o[l + 1]), this._$AH[l] = p;
    }
    n && !r && this.j(t);
  }
  j(t) {
    t === g ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
}
class ye extends ot {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === g ? void 0 : t;
  }
}
class be extends ot {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== g);
  }
}
class me extends ot {
  constructor(t, e, i, r, o) {
    super(t, e, i, r, o), this.type = 5;
  }
  _$AI(t, e = this) {
    if ((t = T(this, t, e, 0) ?? g) === I) return;
    const i = this._$AH, r = t === g && i !== g || t.capture !== i.capture || t.once !== i.once || t.passive !== i.passive, o = t !== g && (i === g || r);
    r && this.element.removeEventListener(this.name, this, i), o && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e;
    typeof this._$AH == "function" ? this._$AH.call(((e = this.options) == null ? void 0 : e.host) ?? this.element, t) : this._$AH.handleEvent(t);
  }
}
class _e {
  constructor(t, e, i) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = i;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    T(this, t);
  }
}
const ht = B.litHtmlPolyfillSupport;
ht == null || ht(H, W), (B.litHtmlVersions ?? (B.litHtmlVersions = [])).push("3.2.1");
const $e = (s, t, e) => {
  const i = (e == null ? void 0 : e.renderBefore) ?? t;
  let r = i._$litPart$;
  if (r === void 0) {
    const o = (e == null ? void 0 : e.renderBefore) ?? null;
    i._$litPart$ = r = new W(t.insertBefore(N(), o), o, void 0, e ?? {});
  }
  return r._$AI(s), r;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let u = class extends j {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var e;
    const t = super.createRenderRoot();
    return (e = this.renderOptions).renderBefore ?? (e.renderBefore = t.firstChild), t;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = $e(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this._$Do) == null || t.setConnected(!0);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this._$Do) == null || t.setConnected(!1);
  }
  render() {
    return I;
  }
};
var Mt;
u._$litElement$ = !0, u.finalized = !0, (Mt = globalThis.litElementHydrateSupport) == null || Mt.call(globalThis, { LitElement: u });
const pt = globalThis.litElementPolyfillSupport;
pt == null || pt({ LitElement: u });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.1.1");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const b = (s) => (t, e) => {
  e !== void 0 ? e.addInitializer(() => {
    customElements.define(s, t);
  }) : customElements.define(s, t);
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const we = { attribute: !0, type: String, converter: tt, reflect: !1, hasChanged: $t }, xe = (s = we, t, e) => {
  const { kind: i, metadata: r } = e;
  let o = globalThis.litPropertyMetadata.get(r);
  if (o === void 0 && globalThis.litPropertyMetadata.set(r, o = /* @__PURE__ */ new Map()), o.set(e.name, s), i === "accessor") {
    const { name: n } = e;
    return { set(h) {
      const l = t.get.call(this);
      t.set.call(this, h), this.requestUpdate(n, l, s);
    }, init(h) {
      return h !== void 0 && this.P(n, void 0, s), h;
    } };
  }
  if (i === "setter") {
    const { name: n } = e;
    return function(h) {
      const l = this[n];
      t.call(this, h), this.requestUpdate(n, l, s);
    };
  }
  throw Error("Unsupported decorator location: " + i);
};
function c(s) {
  return (t, e) => typeof e == "object" ? xe(s, t, e) : ((i, r, o) => {
    const n = r.hasOwnProperty(o);
    return r.constructor.createProperty(o, n ? { ...i, wrapped: !0 } : i), n ? Object.getOwnPropertyDescriptor(r, o) : void 0;
  })(s, t, e);
}
var Pe = Object.defineProperty, Se = Object.getOwnPropertyDescriptor, xt = (s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? Se(t, e) : t, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (r = (i ? n(t, e, r) : n(r)) || r);
  return i && r && Pe(t, e, r), r;
};
let z = class extends u {
  constructor() {
    super(...arguments), this.variant = "info", this.message = "", this.role = "button";
  }
  static get styles() {
    return y`
            :host {
                position: relative;

                flex: 1;
                display: block;

                border-radius: var(--ui-radius);
                border: 1px solid var(--ui-borderColor);

                padding: var(--ui-spacing);

                width: 28rem;
                max-width: 100%;

                cursor: pointer;
            }

            :host([variant="info"]) {
                background-color: var(--ui-info);
                color: var(--ui-info-text));
            }

            :host([variant="warning"]) {
                background-color: hsl(48, 100%, 50%);
                background-color: var(--ui-warning);
                color: var(--ui-warning-text);
            }

            :host([variant="error"]) {
                background-color: var(--ui-error);
                color: var(--ui-error-text);
            }

            ui-text {
                flex-grow: 1;
            }
        `;
  }
  render() {
    return m` <ui-text style="font-size: 0.9rem;">${this.message}</ui-text> `;
  }
  firstUpdated(s) {
    super.firstUpdated(s), this.addEventListener("click", () => {
      this.parentElement && this.parentElement.removeChild(this);
    });
  }
};
xt([
  c({ type: String, attribute: "variant", reflect: !0 })
], z.prototype, "variant", 2);
xt([
  c({ type: String, attribute: "message" })
], z.prototype, "message", 2);
z = xt([
  b("ui-alert")
], z);
const br = z;
var Ae = Object.defineProperty, Ee = Object.getOwnPropertyDescriptor, Ce = (s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? Ee(t, e) : t, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (r = (i ? n(t, e, r) : n(r)) || r);
  return i && r && Ae(t, e, r), r;
};
let gt = class extends u {
  static get styles() {
    return y`
            :host {
                display: block;

                z-index: 999;
                position: fixed !important;
                right: 0;
                bottom: 0;

                width: fit-content;
                max-width: 100%;
                height: fit-content;
                max-height: 100%;

                background: transparent;

                border-radius: var(--ui-radius);

                overflow: auto;

                /* Disable touch actions and pointer events */

                pointer-events: none;

                -ms-touch-action: none;
                touch-action: none;
            }

            ui-flex-grid {
                padding: var(--ui-spacing);
            }

            ::slotted(*) {
                pointer-events: auto;

                -ms-touch-action: auto;
                touch-action: auto;
            }
        `;
  }
  render() {
    return m`
            <ui-flex-grid class="container" gap="0.25rem">
                <slot></slot>
            </ui-flex-grid>
        `;
  }
  addAlert(s) {
    var e;
    const t = (e = this.shadowRoot) == null ? void 0 : e.querySelector(".container");
    return t && t.append(s), () => this.removeAlert(s);
  }
  removeAlert(s) {
    var e;
    const t = (e = this.shadowRoot) == null ? void 0 : e.querySelector(".container");
    t && t.removeChild(s);
  }
};
gt = Ce([
  b("ui-alerts")
], gt);
const mr = gt;
var Oe = Object.defineProperty, Ue = Object.getOwnPropertyDescriptor, Pt = (s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? Ue(t, e) : t, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (r = (i ? n(t, e, r) : n(r)) || r);
  return i && r && Oe(t, e, r), r;
};
let F = class extends u {
  constructor() {
    super(...arguments), this.position = "top", this.fixed = !1;
  }
  static get styles() {
    return y`
            :host {
                z-index: 999;

                display: flex;
                flex-flow: row nowrap;
                align-items: center;
                justify-content: space-between;

                width: 100%;

                overflow: hidden;

                padding: calc(var(--ui-spacing) / 2);

                background-color: var(--ui-backdrop);
                -webkit-backdrop-filter: var(--ui-backdropFilter);
                backdrop-filter: var(--ui-backdropFilter);

                gap: var(--ui-spacing, 0.25rem);
            }

            :host([position="top"]),
            :host([position="bottom"]) {
                position: absolute !important;
                left: 0;
                right: 0;
                height: var(--ui-app-bar-height);
            }

            :host([position="top"]):host([fixed]),
            :host([position="bottom"]):host([fixed]) {
                position: fixed !important;
            }

            :host([position="top"]) {
                top: 0;
                border-bottom: 1px solid var(--ui-borderColor);
            }

            :host([position="bottom"]) {
                bottom: 0;
                border-top: 1px solid var(--ui-borderColor);
            }

            :host .container {
                height: 100%;
                width: 100%;
            }

            :host .container.left,
            :host .container.right {
                width: fit-content;
            }

            :host ::slotted([slot="center"]) {
                width: 100%;
            }
        `;
  }
  render() {
    return m`
            <ui-flex-grid-row class="container left" part="container left" align="center">
                <slot name="left"></slot>
            </ui-flex-grid-row>

            <ui-flex-grid-row
                class="container center"
                part="container center"
                style="overflow: hidden;"
                align="center"
            >
                <slot name="center"></slot>
            </ui-flex-grid-row>

            <ui-flex-grid-row class="container right" part="container right" align="center">
                <slot name="right"></slot>
            </ui-flex-grid-row>
        `;
  }
  content(s) {
    return [...this.querySelectorAll(`[slot="${s}"]`)];
  }
  contentName(s) {
    return this.querySelector(`[name="${s}"]`);
  }
};
Pt([
  c({ type: String, attribute: "position", reflect: !0 })
], F.prototype, "position", 2);
Pt([
  c({ type: Boolean, attribute: "fixed", reflect: !0 })
], F.prototype, "fixed", 2);
F = Pt([
  b("ui-app-bar")
], F);
const _r = F;
var De = Object.defineProperty, je = Object.getOwnPropertyDescriptor, St = (s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? je(t, e) : t, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (r = (i ? n(t, e, r) : n(r)) || r);
  return i && r && De(t, e, r), r;
};
let G = class extends u {
  constructor() {
    super(...arguments), this.name = "", this.hidden = !1;
  }
  static get styles() {
    return y`
            * {
                box-sizing: border-box;
            }

            :host {
                display: block;
                flex: 1;
            }

            :host([hidden]) {
                display: none;
            }

            ::slotted(*) {
                flex-grow: 1;
            }
        `;
  }
  render() {
    return m`<slot></slot>`;
  }
  content() {
    return [...this.children];
  }
  contentAt(s = 0) {
    return this.children[s];
  }
  show() {
    this.hidden = !1;
  }
  hide() {
    this.hidden = !0;
  }
};
St([
  c({ type: String, attribute: "name", reflect: !0 })
], G.prototype, "name", 2);
St([
  c({ type: Boolean, attribute: "hidden", reflect: !0 })
], G.prototype, "hidden", 2);
G = St([
  b("ui-app-bar-item")
], G);
const $r = G;
var Ie = Object.defineProperty, Te = Object.getOwnPropertyDescriptor, D = (s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? Te(t, e) : t, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (r = (i ? n(t, e, r) : n(r)) || r);
  return i && r && Ie(t, e, r), r;
};
let _ = class extends u {
  constructor() {
    super(...arguments), this.title = "", this.fullscreen = "", this.noFooter = "", this.open = !1, this.modal = !1, this.inert = !1;
  }
  static get styles() {
    return y`
            * {
                box-sizing: border-box;
            }

            dialog {
                z-index: 998; /* UIAlerts z-index is 999 */

                position: fixed !important;
                top: 50%;
                left: 50%;

                max-width: 100%;
                max-height: 100%;

                margin: 0;
                padding: 0;

                border: none;
                outline: none;

                background-color: transparent;

                transform: translate(-50%, -50%);

                /* Remove Scrollbar */
                -ms-overflow-style: none;
                scrollbar-width: none;
                scroll-behavior: smooth;
            }

            /* Remove Scrollbar */
            dialog::-webkit-scrollbar {
                display: none;
            }

            dialog::backdrop {
                background-color: var(--ui-backdrop-color);
                -webkit-backdrop-filter: var(--ui-backdrop-filter);
                backdrop-filter: var(--ui-backdrop-filter);
            }

            :host([fullscreen]) dialog {
                width: 100%;
                height: 100%;
            }

            dialog > .container {
                background-color: var(--ui-bg);
                color: var(--ui-text);

                border: 1px solid var(--ui-border-color);
                border-radius: var(--ui-radius);

                padding: var(--ui-spacing);

                display: flex;
                flex-direction: column;
                justify-content: space-between;

                position: relative;
            }

            :host([fullscreen]) dialog > .container {
                width: calc(100% - var(--ui-spacing) * 2);
                height: calc(100% - var(--ui-spacing) * 2);

                margin: var(--ui-spacing);
            }

            /*
             * Header Styles
             */

            .header {
                display: flex;
                align-items: center;
                justify-content: space-between;

                border-top-right-radius: var(--ui-radius);
                border-top-left-radius: var(--ui-radius);

                width: 100%;
                height: var(--ui-dialog-header-height);
            }

            :host([fullscreen]) .header {
                z-index: 15;
                position: absolute;
                top: var(--ui-spacing);
                right: var(--ui-spacing);
                left: var(--ui-spacing);
                width: calc(100% - var(--ui-spacing) * 2);
            }

            /*
             * Content Styles
             */

            .content {
                padding: var(--ui-spacing);
                height: fit-content;
                min-width: fit-content;
                width: 100%;
            }

            :host([fullscreen]) .content {
                z-index: 10;
                position: absolute;
                top: calc(var(--ui-dialog-header-height) + var(--ui-spacing));
                bottom: calc(var(--ui-dialog-footer-height) + var(--ui-spacing));
                right: var(--ui-spacing);
                left: var(--ui-spacing);
                padding: unset;
                height: unset;
                width: unset;
                min-width: unset;
            }

            :host([no-footer]) .content {
                bottom: var(--ui-spacing);
            }

            /*
             * Footer Styles
             */

            .footer {
                margin-top: var(--ui-spacing);
                border-bottom-right-radius: var(--ui-radius);
                border-bottom-left-radius: var(--ui-radius);

                width: 100%;
                height: var(--ui-dialog-footer-height);
            }

            :host([fullscreen]) .footer {
                z-index: 15;
                position: absolute;
                right: var(--ui-spacing);
                bottom: var(--ui-spacing);
                left: var(--ui-spacing);
                width: calc(100% - var(--ui-spacing) * 2);
            }

            :host([no-footer]) .footer {
                display: none;
            }

            .footer ui-flex-grid-row {
                height: 100%;
                flex-wrap: nowrap;
                justify-content: flex-end;
                align-items: center;
            }
        `;
  }
  render() {
    return m`
            <dialog
                @cancel=${(s) => {
      s.preventDefault();
    }}
            >
                <div class="container">
                    <div class="header">
                        <h4>${this.title}</h4>

                        <button
                            class="ui-icon"
                            style="width: var(--ui-dialog-header-height);"
                            variant="ghost"
                            @click=${() => {
      this.close();
    }}
                        ></button>
                    </div>

                    <div class="content">
                        <slot></slot>
                    </div>

                    <div class="footer">
                        <ui-flex-grid-row gap="calc(var(--ui-spacing) / 2)">
                            <slot name="actions"></slot>
                        </ui-flex-grid-row>
                    </div>
                </div>
            </dialog>
        `;
  }
  firstUpdated(s) {
    this.shadowRoot !== null && Ht(this.shadowRoot);
  }
  updated(s) {
    this.open ? this.show() : this.close();
  }
  show() {
    this.open || (this.open = !0);
    const s = this.shadowRoot.querySelector("dialog");
    if (s === null) return;
    const t = s.inert;
    s.inert = this.inert, this.modal ? s.showModal() : s.show(), s.inert = t, this.dispatchEvent(new Event("open"));
  }
  close() {
    this.dispatchEvent(new Event("close")), this.shadowRoot.querySelector("dialog").close();
  }
  addDialogActionButton(s, t) {
    const e = new O();
    e.flex = (t == null ? void 0 : t.flex) || 1, e.slot = "actions", this.appendChild(e);
    let i = document.createElement("button");
    return e.appendChild(i), i.innerHTML = s, t != null && t.variant && i.setAttribute("variant", t.variant), t != null && t.color && i.setAttribute("color", t.color), i.onclick = (t == null ? void 0 : t.onClick) || null, i;
  }
};
D([
  c({ type: String, attribute: "title", reflect: !0 })
], _.prototype, "title", 2);
D([
  c({ type: Boolean, attribute: "fullscreen", reflect: !0 })
], _.prototype, "fullscreen", 2);
D([
  c({ type: Boolean, attribute: "no-footer", reflect: !0 })
], _.prototype, "noFooter", 2);
D([
  c({ type: Boolean, attribute: "open", reflect: !0 })
], _.prototype, "open", 2);
D([
  c({ type: Boolean, attribute: "modal", reflect: !0 })
], _.prototype, "modal", 2);
D([
  c({ type: Boolean, attribute: "inert", reflect: !0 })
], _.prototype, "inert", 2);
_ = D([
  b("ui-dialog")
], _);
const wr = _;
var Le = Object.defineProperty, ke = Object.getOwnPropertyDescriptor, X = (s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? ke(t, e) : t, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (r = (i ? n(t, e, r) : n(r)) || r);
  return i && r && Le(t, e, r), r;
};
const Re = "0";
let E = class extends u {
  constructor() {
    super(...arguments), this.title = "", this.gap = Re, this.open = !1, this.noFold = !1;
  }
  static get styles() {
    return y`
            :host {
                display: block;
                margin: 0;
                list-style: none;
                padding: var(--ui-spacing);
                overflow: hidden;
            }

            .fold {
                display: flex;
                position: relative;
                border-radius: var(--ui-radius);
                cursor: pointer;
            }

            :host([no-fold]) .fold {
                display: none;
            }

            .fold .icon {
                transition: transform 0.25s ease;
                display: flex;
                justify-content: center;
                align-items: center;
            }

            :host(:not([open])) .fold .icon {
                transform: rotate(-90deg);
            }

            :host(:not([open])):host(:not([no-fold])) ::slotted(*) {
                display: none !important;
            }
        `;
  }
  render() {
    return m`
            <ui-flex-grid gap="${this.gap}">
                <ui-drawer-group-item
                    class="fold"
                    role="button"
                    @click=${async () => {
      this.open = !this.open, setTimeout(() => {
        this.open ? this.dispatchEvent(new Event("unfold")) : this.dispatchEvent(new Event("fold"));
      });
    }}
                >
                    <ui-flex-grid-row>
                        <ui-flex-grid-item align="center" style="padding-right: var(--ui-spacing);">
                            <h4>${this.title}</h4>
                        </ui-flex-grid-item>

                        <ui-flex-grid-item class="icon" align="center" flex="0">
                            <div
                                class="ui-icon ui-icon-chevron-down"
                                style="width: 2.5rem, height: 2.5rem"
                            ></div>
                        </ui-flex-grid-item>
                    </ui-flex-grid-row>
                </ui-drawer-group-item>

                <slot></slot>
            </ui-flex-grid>
        `;
  }
  firstUpdated(s) {
    this.shadowRoot !== null && Ht(this.shadowRoot);
  }
};
X([
  c({ type: String, attribute: "title", reflect: !0 })
], E.prototype, "title", 2);
X([
  c({ type: String, attribute: "gap" })
], E.prototype, "gap", 2);
X([
  c({ type: Boolean, attribute: "open", reflect: !0 })
], E.prototype, "open", 2);
X([
  c({ type: Boolean, attribute: "no-fold", reflect: !0 })
], E.prototype, "noFold", 2);
E = X([
  b("ui-drawer-group")
], E);
const Be = E;
var Ne = Object.defineProperty, Me = Object.getOwnPropertyDescriptor, At = (s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? Me(t, e) : t, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (r = (i ? n(t, e, r) : n(r)) || r);
  return i && r && Ne(t, e, r), r;
};
let q = class extends u {
  constructor() {
    super(...arguments), this.open = !1, this.role = "button", this.handleUnfold = (s) => {
      s.currentTarget.scrollIntoView(!0);
    };
  }
  static get styles() {
    return y`
            * {
                box-sizing: border-box;
            }

            :host {
                display: block;

                position: fixed !important;
                z-index: 150;
                top: 0;
                left: -100%;
                width: 100%;
                height: 100%;

                overflow: hidden;

                transition: left 0s ease 0.25s;
            }

            :host([open]) {
                left: 0;
                transition: none;
            }

            :host(:not([open])) {
            }

            aside {
                position: absolute;
                z-index: 150;
                top: 0;
                left: -100%;
                width: var(--_width, fit-content);
                max-width: calc(100% - 2.5rem);
                height: 100%;

                overflow-x: hidden;
                overflow-y: scroll;

                border-right: var(--ui-border-width) var(--ui-border-style) var(--ui-border-color);

                transition: left 0.5s ease;

                /* Remove Scrollbar */
                -ms-overflow-style: none;
                scrollbar-width: none;
                scroll-behavior: smooth;

                /* Backdrop Blur */
                background-color: var(--ui-backdrop-color);
                -webkit-backdrop-filter: var(--ui-backdrop-filter);
                backdrop-filter: var(--ui-backdrop-filter);
            }

            aside::-webkit-scrollbar {
                display: none;
            }

            :host([open]) aside {
                left: 0;
            }
        `;
  }
  render() {
    return m`
            <aside
                @click=${(s) => {
      s.stopPropagation();
    }}
            >
                <slot></slot>
            </aside>
        `;
  }
  firstUpdated(s) {
    this.classList.add("ui-backdrop-blur"), this.addEventListener("click", () => {
      this.open = !1;
    });
  }
  updated(s) {
    [...this.children].forEach(async (t) => {
      t instanceof Be && t.addEventListener("unfold", this.handleUnfold);
    });
  }
  attributeChangedCallback(s, t, e) {
    switch (super.attributeChangedCallback(s, t, e), s) {
      case "width":
        e !== null ? this.style.setProperty("--_width", e) : this.style.removeProperty("--_width");
        break;
      case "open":
        e !== null ? (history.pushState(null, "ui-drawer", location.href), this.dispatchEvent(new Event("open"))) : this.dispatchEvent(new Event("close"));
        break;
    }
  }
};
At([
  c({ type: String, attribute: "width", reflect: !0 })
], q.prototype, "width", 2);
At([
  c({ type: Boolean, attribute: "open", reflect: !0 })
], q.prototype, "open", 2);
q = At([
  b("ui-drawer")
], q);
const xr = q;
var He = Object.defineProperty, ze = Object.getOwnPropertyDescriptor, Fe = (s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? ze(t, e) : t, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (r = (i ? n(t, e, r) : n(r)) || r);
  return i && r && He(t, e, r), r;
};
let vt = class extends u {
  static get styles() {
    return y`
            * {
                box-sizing: border-box;
            }

            :host {
                width: 100%;

                display: flex;
                flex-direction: row;
                flex-wrap: nowrap;
            }

            ::slotted(*) {
                width: 100%;
            }
        `;
  }
  render() {
    return m`<slot></slot>`;
  }
};
vt = Fe([
  b("ui-drawer-group-item")
], vt);
const Pr = vt;
var Ge = Object.defineProperty, qe = Object.getOwnPropertyDescriptor, Y = (s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? qe(t, e) : t, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (r = (i ? n(t, e, r) : n(r)) || r);
  return i && r && Ge(t, e, r), r;
};
const Bt = "0";
let C = class extends u {
  constructor() {
    super(...arguments), this.gap = Bt;
  }
  static get styles() {
    return y`
            :host {
                display: flex !important;
                flex-direction: column !important;
                flex-flow: column var(--_wrap, nowrap);
                justify-content: var(--_justify);
                align-items: var(--_align);

                position: relative;
                width: 100%;
                height: fit-content;

                gap: var(--_gap);
            }
        `;
  }
  render() {
    return m`<slot></slot>`;
  }
  attributeChangedCallback(s, t, e) {
    switch (super.attributeChangedCallback(s, t, e), s) {
      case "gap":
        e ? this.style.setProperty("--_gap", e || Bt) : this.style.removeProperty("--_gap");
        break;
      case "justify":
        e ? this.style.setProperty("--_justify", e || "") : this.style.removeProperty("--_justify");
        break;
      case "align":
        e ? this.style.setProperty("--_align", e || "") : this.style.removeProperty("--_align");
        break;
      case "wrap":
        e ? this.style.setProperty("--_wrap", e || "") : this.style.removeProperty("--_wrap");
        break;
    }
  }
};
Y([
  c({ type: String, attribute: "gap" })
], C.prototype, "gap", 2);
Y([
  c({ type: String, attribute: "justify" })
], C.prototype, "justify", 2);
Y([
  c({ type: String, attribute: "align" })
], C.prototype, "align", 2);
Y([
  c({ type: String, attribute: "wrap" })
], C.prototype, "wrap", 2);
C = Y([
  b("ui-flex-grid")
], C);
const Sr = C;
var Ve = Object.defineProperty, We = Object.getOwnPropertyDescriptor, J = (s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? We(t, e) : t, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (r = (i ? n(t, e, r) : n(r)) || r);
  return i && r && Ve(t, e, r), r;
};
const ut = 1;
let O = class extends u {
  constructor() {
    super(...arguments), this.flex = ut;
  }
  static get styles() {
    return y`
            :host {
                flex: var(--_flex, ${ut});
                display: flex;
                flex-direction: var(--_direction, row);
                justify-content: var(--_justify);
                align-items: var(--_align);
            }

            ::slotted(*) {
                flex-grow: 1;
            }
        `;
  }
  render() {
    return m`<slot></slot>`;
  }
  attributeChangedCallback(s, t, e) {
    switch (super.attributeChangedCallback(s, t, e), s) {
      case "flex":
        this.style.setProperty(
          "--_flex",
          e || ut.toString()
        );
        break;
      case "direction":
        e ? this.style.setProperty("--_direction", e) : this.style.removeProperty("--_direction");
        break;
      case "justify":
        e ? this.style.setProperty("--_justify", e) : this.style.removeProperty("--_justify");
        break;
      case "align":
        e ? this.style.setProperty("--_align", e) : this.style.removeProperty("--_align");
        break;
    }
  }
};
J([
  c({ type: Number, attribute: "flex" })
], O.prototype, "flex", 2);
J([
  c({ type: String, attribute: "direction", reflect: !0 })
], O.prototype, "direction", 2);
J([
  c({ type: String, attribute: "justify" })
], O.prototype, "justify", 2);
J([
  c({ type: String, attribute: "align" })
], O.prototype, "align", 2);
O = J([
  b("ui-flex-grid-item")
], O);
var Xe = Object.defineProperty, Ye = Object.getOwnPropertyDescriptor, Z = (s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? Ye(t, e) : t, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (r = (i ? n(t, e, r) : n(r)) || r);
  return i && r && Xe(t, e, r), r;
};
const Nt = "0.25rem";
let U = class extends u {
  constructor() {
    super(...arguments), this.gap = Nt;
  }
  static get styles() {
    return y`
            :host {
                display: flex;
                flex-direction: row;
                flex-flow: row var(--_wrap, nowrap);

                justify-content: var(--_justify);
                align-items: var(--_align);

                width: 100%;
                min-height: fit-content;

                gap: var(--_gap, 0.25rem);
            }
        `;
  }
  render() {
    return m`<slot></slot>`;
  }
  attributeChangedCallback(s, t, e) {
    switch (super.attributeChangedCallback(s, t, e), s) {
      case "gap":
        e ? this.style.setProperty("--_gap", e || Nt) : this.style.removeProperty("--_gap");
        break;
      case "justify":
        e ? this.style.setProperty("--_justify", e || "") : this.style.removeProperty("--_justify");
        break;
      case "align":
        e ? this.style.setProperty("--_align", e || "") : this.style.removeProperty("--_align");
        break;
      case "wrap":
        e === null ? this.style.removeProperty("--_wrap") : this.style.setProperty("--_wrap", "wrap");
        break;
    }
  }
};
Z([
  c({ type: String, attribute: "gap", reflect: !0 })
], U.prototype, "gap", 2);
Z([
  c({ type: String, attribute: "justify", reflect: !0 })
], U.prototype, "justify", 2);
Z([
  c({ type: String, attribute: "align", reflect: !0 })
], U.prototype, "align", 2);
Z([
  c({ type: Boolean, attribute: "wrap", reflect: !0 })
], U.prototype, "wrap", 2);
U = Z([
  b("ui-flex-grid-row")
], U);
const Ar = U;
var Je = Object.defineProperty, Ze = Object.getOwnPropertyDescriptor, nt = (s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? Ze(t, e) : t, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (r = (i ? n(t, e, r) : n(r)) || r);
  return i && r && Je(t, e, r), r;
};
let L = class extends u {
  constructor() {
    super(...arguments), this.name = "", this.href = "", this.fallback = !1;
  }
  static get styles() {
    return y`
            :host {
                display: none;
            }
        `;
  }
};
nt([
  c({ type: String, attribute: "name", reflect: !0 })
], L.prototype, "name", 2);
nt([
  c({ type: String, attribute: "href", reflect: !0 })
], L.prototype, "href", 2);
nt([
  c({ type: Boolean, attribute: "fallback", reflect: !0 })
], L.prototype, "fallback", 2);
L = nt([
  b("ui-lang-type")
], L);
const Er = L;
var Ke = Object.defineProperty, Qe = Object.getOwnPropertyDescriptor, Xt = (s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? Qe(t, e) : t, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (r = (i ? n(t, e, r) : n(r)) || r);
  return i && r && Ke(t, e, r), r;
};
let rt = class extends u {
  constructor() {
    super(...arguments), this.data = {}, this.events = new bt(), this.current = "";
  }
  static get styles() {
    return y`
            :host {
                display: none;
            }
        `;
  }
  render() {
    return m`<slot></slot>`;
  }
  attributeChangedCallback(s, t, e) {
    switch (super.attributeChangedCallback(s, t, e), s) {
      case "current":
        this.setCurrent(e || "");
        break;
    }
  }
  fallback() {
    return this.querySelector("ui-lang-type[fallback]");
  }
  get(s, t) {
    var e, i;
    return ((i = (e = this.data) == null ? void 0 : e[s]) == null ? void 0 : i[t]) || null;
  }
  async setCurrent(s) {
    const t = (s !== "" ? this.querySelector(`ui-lang-type[name="${s}"]`) : this.fallback()) || this.fallback();
    if (t) {
      if (!t.href) throw "Missing href attribute!";
      try {
        this.data = await (await fetch(t.href)).json();
      } catch (e) {
        console.error(e);
      }
      this.events.dispatch("change", t);
    }
  }
};
Xt([
  c({ type: String, attribute: "current", reflect: !0 })
], rt.prototype, "current", 2);
rt = Xt([
  b("ui-lang")
], rt);
const Cr = rt;
var tr = Object.defineProperty, er = Object.getOwnPropertyDescriptor, Yt = (s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? er(t, e) : t, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (r = (i ? n(t, e, r) : n(r)) || r);
  return i && r && tr(t, e, r), r;
};
let st = class extends u {
  constructor() {
    super(...arguments), this.nobg = !1;
  }
  static get styles() {
    return y`
            :host {
                position: absolute !important;
                top: 0;
                right: 0;
                bottom: 0;
                left: 0;
            }

            .background {
                display: "block";

                z-index: 999;
                position: absolute;
                top: 0;
                right: 0;
                bottom: 0;
                left: 0;

                background-color: var(--ui-backdrop);
                -webkit-backdrop-filter: var(--ui-backdropFilter);
                backdrop-filter: var(--ui-backdropFilter);
            }

            :host([nobg]) .background {
                display: none;
            }

            .spinner {
                content: "";
                box-sizing: border-box;

                z-index: 1000;
                position: absolute;
                top: 50%;
                left: 50%;
                width: 2.5rem;
                height: 2.5rem;

                margin-top: -1.25rem;
                margin-left: -1.25rem;

                border: 2px solid var(--ui-borderColor);
                border-top-color: var(--ui-primary);
                border-radius: 50%;

                animation: spinner 0.6s linear infinite;
            }

            @keyframes spinner {
                to {
                    transform: rotate(360deg);
                }
            }
        `;
  }
  render() {
    return m`
            <div class="background"></div>
            <div class="spinner"></div>
        `;
  }
};
Yt([
  c({ type: Boolean, attribute: "nobg", reflect: !0 })
], st.prototype, "nobg", 2);
st = Yt([
  b("ui-spinner")
], st);
const Or = st;
var rr = Object.defineProperty, sr = Object.getOwnPropertyDescriptor, ir = (s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? sr(t, e) : t, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (r = (i ? n(t, e, r) : n(r)) || r);
  return i && r && rr(t, e, r), r;
};
let yt = class extends u {
  constructor() {
    super(...arguments), this.events = new bt(), this.stack = [], this.onpopstate = () => {
      if (this.stack.length === 0) {
        this.dispatchChangeEvent(null);
        return;
      }
      const s = this.removeChild(this.stack.pop());
      this.stack.length > 0 && (this.stack[this.stack.length - 1].parentElement || this.appendChild(this.stack[this.stack.length - 1])), this.dispatchChangeEvent(s);
    }, this.pages = {}, this.lockNavigation = !1;
  }
  static get styles() {
    return y`
            :host {
                display: block;
                position: relative;
                width: 100%;
                height: 100%;
            }
        `;
  }
  render() {
    return m`<slot></slot>`;
  }
  connectedCallback() {
    super.connectedCallback(), window.addEventListener("popstate", this.onpopstate);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), window.removeEventListener("popstate", this.onpopstate);
  }
  stackSize() {
    return this.stack.length;
  }
  clearStack() {
    for (; this.stack.length > 0; )
      this.removeChild(this.stack.pop());
    this.dispatchChangeEvent(null);
  }
  goBack() {
    this.stack.length === 0 || this.lockNavigation || history.back();
  }
  registerPage(s, t) {
    this.pages[s] = t;
  }
  unregisterPage(s) {
    delete this.pages[s];
  }
  async setPage(s, t = null, e = !1) {
    var o;
    if (this.lockNavigation) return;
    if (!(s in this.pages))
      throw new Error(`page "${s}" not found`);
    const i = await this.pages[s]();
    this.stack.push(this.appendChild(i)), typeof t == "function" && t(i);
    let r = null;
    this.stack.length > 1 && !e && (r = this.stack[this.stack.length - 2], (o = r.parentElement) == null || o.removeChild(r)), this.dispatchChangeEvent(r), this.onpopstate !== null && history.pushState(null, document.title, location.href);
  }
  async dispatchChangeEvent(s) {
    this.events.dispatch("change", {
      old: s || this.stack[this.stack.length - 2] || null,
      current: this.stack[this.stack.length - 1] || null
    });
  }
};
yt = ir([
  b("ui-stack-layout")
], yt);
const Ur = yt;
var or = Object.defineProperty, nr = Object.getOwnPropertyDescriptor, Jt = (s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? nr(t, e) : t, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (r = (i ? n(t, e, r) : n(r)) || r);
  return i && r && or(t, e, r), r;
};
let it = class extends u {
  constructor() {
    super(...arguments), this.name = "";
  }
  static get styles() {
    return y`
            :host {
                display: block;

                position: absolute !important;
                top: 0;
                right: 0;
                bottom: 0;
                left: 0;
                width: 100%;
                height: 100%;

                opacity: 0;

                transition: opacity 0.5s ease;
                animation: fade-in 0.5s;
            }

            :host(:last-child) {
                opacity: 1;
            }

            @keyframes fade-in {
                0% {
                    opacity: 0;
                }
                100% {
                    opacity: 1;
                }
            }
        `;
  }
  render() {
    return m`<slot></slot>`;
  }
};
Jt([
  c({ type: String, attribute: "name", reflect: !0 })
], it.prototype, "name", 2);
it = Jt([
  b("ui-stack-layout-page")
], it);
const Dr = it;
var ar = Object.defineProperty, lr = Object.getOwnPropertyDescriptor, Et = (s, t, e, i) => {
  for (var r = i > 1 ? void 0 : i ? lr(t, e) : t, o = s.length - 1, n; o >= 0; o--)
    (n = s[o]) && (r = (i ? n(t, e, r) : n(r)) || r);
  return i && r && ar(t, e, r), r;
};
let V = class extends u {
  constructor() {
    super(...arguments), this.data = {}, this.events = new bt(), this.storage = !1, this.storagePrefix = "";
  }
  static get styles() {
    return y`
            :host {
                display: none;
            }
        `;
  }
  getData(s) {
    if (this.storage) {
      const t = localStorage.getItem(
        `${this.storagePrefix}${s}`
      );
      if (t !== null) return JSON.parse(t);
    }
    if (this.data.hasOwnProperty(s))
      return this.data[s];
  }
  setData(s, t, e = !1) {
    if (e && this.storage) {
      const i = localStorage.getItem(
        `${this.storagePrefix}${s}`
      );
      i !== null ? this.data[s] = JSON.parse(i) : this.data.hasOwnProperty(s) || (this.data[s] = t);
    } else
      this.data[s] = t;
    this.storage && localStorage.setItem(
      `${this.storagePrefix}${s}`,
      JSON.stringify(this.data[s])
    ), this.events.dispatch(s, this.data[s]);
  }
  updateData(s, t) {
    const e = this.getData(s);
    if (e === void 0)
      throw new Error(`"${s}" not found, use \`setData\``);
    this.setData(s, t(e));
  }
  /**
   * This function is just a wrapper for `this.events.addListener(key, data)`,
   * but with an option to trigger the callback once.
   */
  addListener(s, t, e = !1) {
    if (e) {
      const i = this.getData(s);
      i !== void 0 && setTimeout(() => t(i));
    }
    return this.events.addListener(s, t);
  }
};
Et([
  c({ type: Boolean, attribute: "storage", reflect: !0 })
], V.prototype, "storage", 2);
Et([
  c({ type: String, attribute: "storage-prefix", reflect: !0 })
], V.prototype, "storagePrefix", 2);
V = Et([
  b("ui-store")
], V);
const jr = V;
export {
  cr as CleanUp,
  bt as Events,
  br as UIAlert,
  mr as UIAlerts,
  _r as UIAppBar,
  $r as UIAppBarItem,
  wr as UIDialog,
  xr as UIDrawer,
  Be as UIDrawerGroup,
  Pr as UIDrawerGroupItem,
  Sr as UIFlexGrid,
  O as UIFlexGridItem,
  Ar as UIFlexGridRow,
  Cr as UILang,
  Er as UILangType,
  Or as UISpinner,
  Ur as UIStackLayout,
  Dr as UIStackLayoutPage,
  jr as UIStore,
  Ht as addGlobalStylesToShadowRoot,
  dr as css,
  hr as draggable,
  ur as html,
  fr as isAndroid,
  pr as ripple,
  gr as styles
};
